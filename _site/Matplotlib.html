<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <link href="https://fonts.googleapis.com/css?family=Maven+Pro:400,500&amp;subset=latin-ext,vietnamese" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Dancing+Script:400,700&amp;subset=vietnamese" rel="stylesheet">
  <meta name="google-site-verification" content="8zqeFQNuNAWS7ye6oN69hdEeYC_RsDyAlhht79xtAQo" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta property="og:image" content="/assets/res/banner.png" />

  

  <title>
    
      Matplotlib - appunti | 4Phycs
    
  </title>

  

  <!-- page's cover -->
  
    <meta property="og:image" content="http://localhost:4000/images/defaultCoverPost.png" />
    <meta property="og:image:type" content="image/png">
    <meta property="og:image:width" content="1234">
    <meta property="og:image:height" content="592">
  

  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <script type="text/javascript" async
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
  

  <link rel="shortcut icon" type="image/x-icon" href="/assets/res/favicon.png">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/materialize/0.99.0/css/materialize.min.css">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="/assets/css/main.css">

  <link rel="stylesheet" href="/assets/css/thi_scss.css">

  
    
      <link rel="stylesheet" href="/assets/css/post.css">
    
  

  

  <link rel="stylesheet" href="/assets/css/syntax.css">
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml">
  <link rel="sitemap" type="application/xml" title="Sitemap" href="/sitemap.xml">
  
  <!-- Begin Jekyll SEO tag v2.6.1 -->
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Matplotlib - appunti" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Matplotlib Queste sono le mie (Paolo Avogadro) note basate sul video di Derek Banas riguardo a Matplotlib. Oltre agli esempi suggeriti aggiungo dei miei test e considerazioni. Qualunque errore e’ esclusivamente dovuto ad una mia erronea interpretazione dei comandi. Lo scopo di queste note non e’ di presentare esempi perfettamente funzionanti, ma serve a me come spunto per ricordare i comandi di Matplotlib, e il modello mentale che io ho sul pacchetto. La versione originale di queste note ha la forma di un Jupyter Notebook e quindi possono esserci dei riferimenti ai notebook all’interno del testo. Dopo avere imparato Matplotlib puo’ essere interessante impararare ad usare Seaborn. Cerco di ricostruire gli esempi presentati e fare delle piccole varianti per capire meglio. Queste note suppongono che ci sia una certa conoscenza di base di come fare i grafici al computer, per esempio partendo da Gnuplot. Notazione: cerco di usare l’evidenziatore per i comandi cerco di usare il grassetto per i termini principali Micro-riassunto: Ci sono 2 modi principali per fare un grafico: modo veloce: con le funzioni di plotting, per esempio: plt.plot(x_1, y_1) (dove x_1 e x_2 sono due oggetti contenenti lo stesso numero di variabili). Si possono inoltre aggiungere delle funzioni per controllare le label, il titolo ecc. modo esteso: prima si definisce una figure, per esempio: fig_1 = plt.figure(figsize=(5,4), dpi =100); pensa alla figure come un’immagine bianca. poi si costruisce uno (o piu’) axes (assi) con un metodo delle figure: axes_1 = fig_1.add_axes([0.1,0.1,0.9,0.9]) (dove specifichiamo la posizione degli assi all’interno della figura). Gli assi determineranno la posizione del grafico. Per esempio se hai un solo quadrante per il tuo grafico puoi immaginare gli assi come un rettangolo (vuoto all’interno). A questo punto si fa partire un grafico, usando un metodo degli assi, per esempio: axes_1.plot(x_1,y_1); Nota che questi metodi sono in pratica le stesse funzioni del punto 1 (solo che vengono chiamati come metodi dell’asse). Nota se non sei in un jupyter notebook dovrai usare un plt.show() se sei su un notebook invece, serve un magic command (e’ una di quelle cose decorate con il percentuale), ci sono vari di questi comandi, tra cui: %matplotlib inline (questo fa apparire delle immagini png statiche nel notebook) %matplotlib notebook (si possono fare zoom delle immagini) %matplotlib tk (tkinter GUI) Una lista di termini utili: alpha=0.75 definisce la trasparenza lw=2 larghezza delle linee del grafico ls =&#39;-.&#39; line style, se e’ una linea continua, oppure trattino e punto, ecc… marker = &#39;o&#39; marker sono i punti di gnuplot. Cosa viene messo nei punti? in questo caso dei cerchietti =o) markersize=7 la grandezza dei punti markerfacecolor =&#39;y&#39; il colore dell’interno dei punti markeredgecolor=&#39;k&#39; il colore dei contorni dei punti markeredgewidth=2 la larghezza del contorno dei punti projection=&#39;3d&#39; argomento per quando si creano degli assi e devono avere un 3D goog_df = pd.read_csv(&#39;GOOG.csv&#39;, index_col = 0, parse_dates=True) trasforma del testo in datetime! facecolor e’ il colore dello sfondo di un’immagine Metodi di FIGURE: fig.tight_layout() oppure, plt.tight_layout() serve per evitare sovrapposizioni per esempio i numeri degli assi trasbordino fig_3.savefig(&#39;ultimoPlot.png&#39;) salvare a file una figura! Metodi degli Assi plt.xticks(np.linspace(0,5,5), (&#39;Tom&#39;, &#39;Dick&#39;, &#39;Harry&#39;, &#39;Sally&#39;, &#39;Sue&#39;)) tics (o ticks) sull’asse x. Per non avere ticks: plt.xticks([]) (non ho messo nulla nella lista = non ci sono ticks) axes_3.set_xlim([0,3]) definisce i limiti sull’asse x (set xlim[1:100]) axes_4.set_xlabel(&#39;temp&#39;) label degli assi axes_3.grid(False, color=&#39;r&#39;, dashes=(0,2,1,2)) mette una griglia sullo sfondo, occhio che color e’ il colore della griglia non dello sfondo. plt.grid(False) e plt.grid(b=None) tolgono la griglia axes_3.set_facecolor(&#39;w&#39;) colore dello sfondo (bianco in questo caso) axes_4.set_title(&#39;da Pandas: IceCream&#39;) titolo axes_1.legend(loc =0 ) # Loc=0 e’ la migliore location scelta da lui` Tipi di disegno (possono essere chiamati come metodi degli assi o funzioni plt): axes_4.plot(x_2, y_2) disegno standard in cui ci sono i punti e posso unirli, cambiarli ecc. plt.bar(x_2, y_2, width=1.5); barchart (come istogramma ma sulle x possono essere categorici) plt.stem(x_2, y_2, &#39;-.&#39;) impulsi, interessante si puo’ indicare il tipo di linea plt.hist(arr3ok, bins= 7, density=True, stacked =False); istogrammi (raggruppa i valori sull’asse delle x in bins) plt.pie() piechart TORTE (gurada sotto perche’ servono un po’ di dettagli) axes_13.scatter(dr_arr, test_arr, s=cc_arr_sm, c=color_arr, alpha=0.2 ) scatterplot valori sull’asse delle x, y, dimensione punti, colori dei punti, trasparenza) axes_9.scatter3D(x_3,y_3,z_3, c=z_3, cmap=&#39;Blues&#39;); scatterplot 3D axes_9.contour3D(x_4,y_4,z_4, 20, cmap=&#39;Blues&#39;); 3D contorno, curve di livello, isoipse axes_9.plot_wireframe(x_4,y_4,z_4, cmap=&#39;Blues&#39;); wireframe e’ il grafico 3D standard di gnuplot, collega tutti i punti axes_9.plot_surface(x_4,y_4,z_4, rstride=1, cstride=1, cmap=&#39;Blues&#39;, edgecolor=&#39;r&#39;); 3D, collega i punti e colora le tegole Consiglio: in un Jupyter notebook usa shift-tab su una funzione per vederne la sua descrizione (prima devi cliccare sulla cella e poi avere il cursore sulla funzione stessa). Consiglio questo articolo contiene trucchi su jupyter notebook e alternative a Matplotlib. import numpy as np import pandas as pd import matplotlib.pyplot as plt %matplotlib inline #%matplotlib notebook %reload_ext autoreload %autoreload 2 Functional Plot Cominciamo con un’immagine semplice in cui c’e’ il titolo: plt.title(&#39;ciao&#39;) ci sono i nomi degli asssi: plt.xlabel(&#39;Days&#39;) c’e’ un grafico: plt.plot(x_1, y_1) Quando faccio un disegno, voglio che tutte le coordinate x siano in un contenitore (lo stesso vale per le coordinate y). Questi “contenitori” devono contenere lo stesso numero di oggetti, altrimenti per un punto avrei solo la coordinata x o solo la y… quindi mi manca il punto! x_1 = np.linspace(0,5,10) # genera un Numpy array con 10 float equispaziati tra 0 e 5 y_1 = x_1 **2 # genera un Numpy array che e&#39; il quadrato del primo plt.plot(x_1, y_1); plt.title(&#39;ciao&#39;); plt.xlabel(&#39;Days&#39;); plt.ylabel(&#39;Days squared&#39;); #plt.show() # se non siamo in jupyter notebook Domanda: posso passare delle liste ad un plt.plot()? Risposta: si’ certo! posso anche graficare delle liste che contengano delle stringhe. Se il contenitore di stringhe e’ una lista, allora esiste un ordine per le stringhe e questo ordine verra’ usato nella visualizzazione. Per un set invece non esiste un ordine e si ha un errore TypeError: unhashable type: ‘set’ l1= [1,2,3,4] l2= [3,4,5,6] l3= [&#39;a&#39;,&#39;b&#39;,&#39;e&#39;,&#39;d&#39;] d1 = {&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;} plt.plot(l1,l3); #plt.plot(l1,d1) # non funge! plt.subplot() molti grafici in modo veloce Qui vediamo come mettere piu’ di un grafico vicino all’altro. Nel dettaglio usando subplot potremo costuire una griglia, in ogni casella della griglia verra’ messo un grafico. Il comando plt.subplot(1,2,1) fa questo tipo di lavoro. il primo argomento e’ il numero di righe della griglia (in questo caso c’e’ solo una riga) il secondo argomento e’ il numero di colonne della griglia . il terzo argomento e’ l’indice del grafico. L’indice ci dice in quale casella della griglia stiamo mettendo il subplot. L’ordine seguito e’ lo stesso che si ha quando si legge: da SINISTRA a DESTRA da SOPRA a SOTTO. Vediamo un esempio: # nota che se anche il terzo argomento e&#39; 2 il grafico appare al primo posto, perche&#39; # non ce ne sono 2! E&#39; un po&#39; come se cadesse a sinistra se ci sono dei buchi? plt.subplot(1,2,2) # questo ci dice che abbiamo una riga e 2 colonne plt.plot(x_1,y_1, &#39;r&#39;); # r = red plt.subplot(1,2,1) # questo ci dice che abbiamo una riga e 2 colonne plt.plot(x_1,y_1, &#39;r&#39;) # r = red plt.subplot(1,2,2) # se metto 1 mi sovrappone con il primo ma mi dice che c&#39;e&#39; qualcosa di strano plt.plot(x_1,y_1, &#39;b&#39;) [&lt;matplotlib.lines.Line2D at 0x2de659e5c40&gt;] plt.subplot(2,2,1) # plt.plot(x_1,y_1, &#39;r&#39;) # plt.subplot(2,2,2) # plt.plot(x_1, y_1-y_1**2, &#39;b&#39;) plt.subplot(2,2,4) plt.plot(x_1, -y_1, &#39;g&#39;); plt.tight_layout() # evita sovrapposizione dei numeri dei grafici! Figure e axes Una figure e’ un oggetto su cui poi si mette il grafico (lo vedo come la tela bianca su cui fare il disegno) contiene tutti i ‘plot elements’ puo’ contenere molti axes (assi), che in pratica sono gli assi che definiscono il disegno vero e proprio, in quanto i punti sono riferiti agli assi. posso definire la sua larghezza e lunghezza in inch (inch=2.54 cm), probabilmente posso cambiare scala: figsize=(5,4) posso anche definire la risoluzione in dpi ATTENTO se definisci il numero di dpi, quando lo visualizzi come un png, questo definisce la dimensione della figura a video! quindi sembra che figsize non funzioni! fig_1 = plt.figure(figsize=(5,4), dpi =100); &lt;Figure size 500x400 with 0 Axes&gt; Axes L’oggetto axes (come indica il nome) identifica la posizione, la forma, e tutte le caratteristiche degli ASSI di un grafico. Se non facciamo esplicitamente un grafico, ci saranno solo le due fracce perpendicolari (gli assi) con dentro nulla. Possiamo i plot (grafici) sono dei metodi degli assi! La logica e’ quindi che siano un oggetto in funzione di dove sono gli assi (e ha senso, quando uno fa un grafico su un foglio, prima disegna gli assi, e poi puo’ definire la posizione dei punti che compongono il grafico. In questo senso quindi il plot e’ stato definito come un metodo di un axes. Nota che posso mettere piu’ di un axes su una singola figure. Anche questo e’ intuitivo, posso mettere 2 grafici sullo stesso foglio, poi i punti di un grafico saranno riferiti ad un paio di assi e quelli del secondo ad un altro paio di assi. Gli assi definiscono il sistema di riferimento “inerziale” che determina la posizione dei punti! Gli assi vengono costruiti su una figure tramite questo metodo: axes_1 = fig_1.add_axes([0.1,0.1,0.9,0.9]) Significa che axes_1 sara’ un rettangolo il cui: punto in basso a sx ha coordinate 0.1, 0.1 (rispetto a fig_1). Ovvero, la figure e’ un rettangolo, anche gli axes sono un rettangolo, il cui punto in basso a sinistra si trova nelle coordinate che sono il 10% delle x e il 10% delle y del punto in basso a sx della figure. punto in alto a dx ha coordinate 0.9,0.9 (rispetto a fig_1) In questo modo ho un grafico che e’ piu’ piccolo del “canvas” definito da fig_1. (nel video) non e’ chiaro come ha fatto l’esponente 2 sulla x. Io devo usare i comandi Latex Attenzione, io avevo messo il comando fig_1 = plt.figure(figsize=(5,4), dpi =100) in una cella diversa da dove facevo il axes.plot. Per questo non vedevo nulla!! Bisogna creare la figura nella stessa cella di Jupyter! Quindi ricapitolando: creo un oggetto figura ( me lo immagino come un foglio bianco di una certa dimensione) creo un oggetto axes che e’ ottenuto da un metodo della figura ( e’ il grafico vero e proprio, definito dagli assi sopra, sotto e destra e sinistra. Al suo interno posso poi mettere dei disegni tramite il metodo plot) tramite metodi di axes aggiungo delle caratteristiche come le label tra i metodi di un axes c’e’ plot (e altri tipi di grafico che potrei fare direttamente con plt). Chiamando un metodo che disegna da un axes, il grafico viene messo su questo axes. posso aggiungere piu’ di un grafico sullo stesso axes, basta chiamare piu’ volte un metodo che disegna sull’axes. nota che si deve fare un axes.plot per ognuno dei disegni che voglio compaiano nella figura! fig_1 = plt.figure(figsize=(5,4), dpi =100) # istanzio una FIGURA chiamata &#39;fig_1&#39; axes_1 = fig_1.add_axes([0.1,0.1,0.9,0.9]) # istanzio un AXES (axes_1), della figura &#39;fig_1&#39; axes_1.set_xlabel(&#39;Days new&#39;) # LABEL degli assi axes_1.set_ylabel(&#39;Days squared new&#39;) # LABEL degli assi axes_1.set_title(&#39;Ciao new&#39;) # TITOLO degli assi axes_1.plot(x_1, y_1, label = &#39;x/x$^2$&#39;) # GRAFICO 1 (all&#39;interno di axes_1) axes_1.plot(y_1, x_1, label = &#39;x^2/x&#39;) # GRAFICO 2 (all&#39;interno di axes_1) axes_1.legend(loc =0 ) # Loc=0 e&#39; la migliore location scelta da lui # 1=alt dx; 2=alto sx; 3=basso sx, 4 basso dx # oppure si fornisce una tupla di x e y dall&#39;angolo in basso a sinistra tu = (0.3, 0.4) # (tupla) questi valori sono in frazione rispetto alla grandezza totale, vedi sotto axes_1.legend(loc=tu ); # posizione della legenda Molte curve: versione veloce se devo fare un grafico veloce, basta che passo le x e y di tutti i grafici in ordine al plot, in questo modo verranno visualizzati tutti! Se non metto color=&#39;black&#39; di default le due curve avranno colori diversi plt.plot(x_1, y_1, x_1, y_1/3); # disegna le 2 funzioni Axes innestati Voglio ora inserire piu’ di un axes nella stessa figura. In pratica aggiungo un axes all’esempio precedente. Per fare questo devo creare un altro axes, proprio perche’ in questo caso i dati si riferiscono ad assi diverse che devono essere definite. Ricapitolando: nell’esempio sopra ci sono una curva blu e una arancione, sono comunque riferite allo stesso axes. Questi axes vanno da 0 a 25 (circa). se voglio inserire una figura nuova, i punti di questa figura saranno riferiti a un nuovo sistema di assi, ho quindi bisogno di inserire questi nuovi assi, creando un nuovo oggetto axes (con un nome diverso) dovro’ quindi indicare dove si collocano questi nuovi assi rspetto alla figure dovro’ anche indicare la loro grandezza, anche in questo caso rispetto alla figure Testo nella figura per inserire un testo nel disegno si usa il metodo text di axes. Le coordinate sono riferite all’axes e partono dal basso a sinistra. Nota che nel disegno sotto ho 2 axes, e il messaggio e’ riferito ad axes_2. Questo e’ ovvio perche’ e’ chiamato come un metodo di questo axes Nota inoltre che axes_2.text(0,40,&#39;message&#39;) fa uscire dal disegno, in quanto per il disegno l’asse delle y arriva solo fino a circa 25! nell’esempio di qui sotto: il primo axis contiene due curve il secondo axis contiene una curva fig_1 = plt.figure(figsize=(5,4), dpi =100) # FIGURA 1 assi_1 = fig_1.add_axes([0.1,0.1,0.9,0.9]) # ASSI_1 assi_1.set_xlabel(&#39;Days new&#39;) assi_1.set_ylabel(&#39;Days squared new&#39;) assi_1.set_title(&#39;Ciao new&#39;) assi_1.plot(x_1, y_1, label = &#39;x/x$^2$&#39;) # GRAFICO 1 (degli &quot;ASSI_1&quot;) assi_1.plot(y_1, x_1, label = &#39;x^2/x&#39;) # GRAFICO 2 (degli &quot;ASSI_1&quot;) assi_1.legend(loc =0 ) # Loc=0 e&#39; la migliore location scelta da lui ######## costruisco i secondi assi ##################### assi_2 = fig_1.add_axes([0.45, 0.45,0.4,0.3]) # ASSE 2 assi_2.set_xlabel(&#39;Days new&#39;) assi_2.set_ylabel(&#39;Days squared new&#39;) assi_2.set_title(&#39;Ciao dentro&#39;) assi_2.plot(x_1, y_1, &#39;r&#39;) # GRAFICO 2 # GRAFICO 1 (degli &quot;ASSI_2&quot;) #assi_2.text(0,40, &#39;Message&#39;) # testo assi_2.text(0,40, &#39;Message&#39;) # testo Text(0, 40, &#39;Message&#39;) subplots() Una griglia di grafici OCCHIO: plt.subplots()$\neq$plt.subplot() (il primo termina in s) Il singolo comando subplots in pratica costruisce 2 oggetti: una figure una array di assi (ma un array di numpy puo’ contenere degli oggetti strani? non erano solo numeri? no! basta che in tutti gli oggetti siano dello stesso tipo: omogeneita’ degli array). devo quindi descrivere/inizializzare ognuno dei possibili axes dell’array, altrimenti ho solo gli assi senza nessun disegno dentro. In pratica e’ una specie di scorciatoia per ordinare facilmente degli axis in una figure in modo che siano esattamente alle posizioni della griglia che viene definita con il comando, per esempio indicando il numero di colonne e di righe. Altrimenti avrei potuto istanziare una figura, e istanziare tanti axes stando attento a metterli nel posto giusto all’interno della figura. Attenzione se voglio mettere degli axes aggiuntivi (oltre all’array di axes iniziale), posso farlo, occhio pero’ che si riferiranno tutti alla figure per quanto riguarda la posizione e non avranno un particolare ordinamento o forma. Dovro’ essere io a stare attento a metterli nel posto corretto e con la forma corretta! il comando plt.tight_layout() aiuta a non fare sovrapporre le label. Attento che devi usare il nome della figura corretto fig_2 Attento: non usare un nome gia’ usato per un altro axes, come axes_2 Attento: la dimensione del subplot e’ riferita al figsize, non all’axes di cui e’ subplot. Per questo trasborda! Attento: se costruisci un nuovo axes viene messo sopra l’axis genitore, e per questo lo (puo’) coprire. Di default un axes non e’ trasparente! fig_2 , axes_2 = plt.subplots(figsize=(8,4), nrows=1, ncols= 3) plt.tight_layout() # evita la sovrapposizione delle label axes_2[1].set_title(&#39;Plot 2&#39;) axes_2[1].set_xlabel(&#39;x&#39;) axes_2[1].set_ylabel(&#39;x quadro&#39;) axes_2[1].plot(x_1, y_1) # Nuovo AXES che non fa parte dell&#39;array creato con subplots axes_3 = fig_2.add_axes([0.45, 0.45,0.4,0.4]) axes_3.set_xlabel(&#39;Days new&#39;) axes_3.set_ylabel(&#39;Days squared new&#39;) axes_3.set_title(&#39;Ciao straripante&#39;) axes_3.plot(x_1, y_1, &#39;r&#39;) # GRAFICO 2 axes = fig_2.add_axes ([0.085,0.15,0.2,0.7]) axes.plot(x_1,y_1, &#39;co&#39;) axes.set_title(&#39;Dentro&#39;) Text(0.5, 1.0, &#39;Dentro&#39;) f , a = plt.subplots(figsize=(8,4), nrows=1, ncols= 3) plt.tight_layout() ############ Axes Centrale ############### a[1].set_title(&#39;Centrale&#39;) a[1].set_xlabel(&#39;x&#39;) a[1].set_ylabel(&#39;x quadro&#39;) a[1].plot(x_1, y_1) ############ Axes Ciao Dentro ############ a1 = f.add_axes([0.45, 0.45,0.4,0.4]) a1.set_xlabel(&#39;Days now&#39;) a1.set_ylabel(&#39;Days squared new&#39;) a1.set_title(&#39;Tra centro e sinistra&#39;) a1.plot(x_1, y_1, &#39;r&#39;) # GRAFICO 2 della figura centrale ############ Axes Sinistro ############### a[0].set_title(&#39;Sinistra&#39;) a[0].set_xlabel(&#39;x&#39;) a[0].set_ylabel(&#39;x quadro&#39;) a[0].plot(x_1, -y_1,&#39;g&#39;) ############ Axes Piccolo sinistra ###### a0 = f.add_axes([0.1, 0.25,0.2,0.2]) a0.set_xlabel(&#39;Days old&#39;) a0.set_ylabel(&#39;Days squared new&#39;) a0.set_title(&#39;Piccolo Sinistra&#39;) a0.plot(x_1, y_1, &#39;r&#39;) # GRAFICO 2 della figura centrale [&lt;matplotlib.lines.Line2D at 0x2de66e3a190&gt;] Colori e Apparenza I colori di default sono: r = red c = cyan m = magenta y = yellow k = black w = white Inoltre color=”0.75” crea un 75% gray (e’ una percentuale di black) si possono usare i colori con hexcodes color=”#eeefff” si possono usare i colori tipo color=”burlywood” che si trovano a https://en.wikipedia.org/wiki/Web_colors lw come gnuplot, ma devo mettere l’uguale, p.es. lw=2 ls ‘-.’ si trovano qui: https://matplotlib.org/3.1.0/gallery/lines_bars_and_markers/linestyles.html marker sono i punti: https://matplotlib.org/3.3.3/api/markers_api.html markersize = grandezza del punto markerfacecolor = colore di riempimento del punto makeredgecolor = colore del bordo del punto fig_3 = plt.figure(figsize=(6,4)) axes_3 = fig_3.add_axes([0,0,1,1]) axes_3.plot(x_1, y_1, color=&#39;navy&#39;, alpha=0.75, lw=2, ls =&#39;-.&#39;, marker = &#39;o&#39;, markersize=7, markerfacecolor =&#39;y&#39;, markeredgecolor=&#39;k&#39;, markeredgewidth=2) [&lt;matplotlib.lines.Line2D at 0x2de66eaa970&gt;] Grandezza degli assi e background I comandi per gestire gli assi assomigliano a quelli di gnuplot, ma solo un po’ piu’ “verbose”, in cui si deve scrivere di piu’. Possimo anche mettere una griglia e il background color. axes_3.set_xlim([0,3]) limiti asse x axes_3.grid(True, color=&#39;0.6&#39;, dashes=(5,2,1,2)) caratteristiche della griglia (NON dello sfondo!), dashes mette delle linee tratteggiate attraverso il disegno. Quindi qui sono le righe che partono da un tic e arrivano dall’altra parte del disegno axes_3.set_facecolor(&#39;#FAEBD7&#39;) colore di sfondo fig_3 = plt.figure(figsize=(3,4) ) axes_3 = fig_3.add_axes([0,0,1,1]) axes_3.plot(x_1, y_1, color=&#39;navy&#39;, alpha=0.75, lw=2, ls =&#39;-.&#39;, marker = &#39;o&#39;, markersize=7, markerfacecolor =&#39;y&#39;, markeredgecolor=&#39;k&#39;, markeredgewidth=2) axes_3.set_xlim([0,3]) axes_3.set_ylim([0,25]) #axes_3.grid(True, color=&#39;0.6&#39;, dashes=(5,2,1,2)) # mettiamo una griglia non lasciamo vuoto axes_3.grid(False, color=&#39;r&#39;, dashes=(0,2,1,2)) #axes_3.set_facecolor(&#39;#FAEBD7&#39;) axes_3.set_facecolor(&#39;w&#39;) Salvare una figura a file strano quando lavoravo con Seaborn sembrave che il save dovesse avvenire nella stessa cella dove si faceva il disegno. Basta mettere il nome dell’estensione e lui salva correttamente nel formato corrispondente fig_3.savefig(&#39;ultimoPlot.png&#39;) Pandas Qui usiamo l’ICE CREAM data table (che diventera’ un DataFrame). Ho copiato il dataframe del video. Assegno dei nomi alle colonne del csv, mentre leggo il file: ics_df = pd.read_csv(&#39;icecream.csv&#39;, names=[&#39;temps&#39;, &#39;sales&#39;]) . Nota che io ho usato i nomi sales e temps (temperatures). Lui li aveva con la prima lettera in maiuscolo. Temp e’ in Farenheit, e sales e’ in unita’ di gelato. Se non usassi il parametro names=... lui prenderebbe la prima riga e la trasformerebbe nei nomi delle colonne (e i valori della prima riga non sarebbero accessibili)! Osservazione: il metodo dei DataFrame sort_values(by=&#39;temps&#39;) lavora inplace, quindi modifica il df! ics_df = pd.read_csv(&#39;icecream.csv&#39;, names=[&#39;temps&#39;, &#39;sales&#39;]) ics_df.head() temps sales 0 37 292 1 40 228 2 49 324 3 61 376 4 72 440 Attento sort_values() lavora inplace ics_df = ics_df.sort_values(by=&#39;temps&#39;) # LAVORA INPLACE A questo punto lui fa delle cose che sembrano non necessarie. Prende e converte il DataFrame in un array di Numpy. Poi prende e scrive le x e le y da questo array di numpy. In effetti ho notato in una sezione sotto che alle volte e’ davvero meglio avere dei numpy array invece che i dataframe, in particolare per evitare dei valori strani sull’asse delle x. # con numpy array ############### # np_arr = ics_df.values # prende solo i valori, rimuove le etichette # x_2 = np_arr[:,0] # seleziono colonna 0 # y_2 = np_arr[:,1] # seleziono colonna 1 ################################### # Alternativa: x_2 = ics_df.temps # non sono array di np, ma serie di Pandas vanno bene lo stesso y_2 = ics_df.sales # ricorda puoi usare l nome di una colonna per selezionare tutta le colonna come se fosse un attributo #x_2 = np.array(ics_df.temps) # NON serve... ora, ma in alcuni casi si&#39; #y_2 = np.array(ics_df.sales) # NON serve... ora, ma in alcuni casi si&#39; ok ma fino a qui, dove ha usto il fatto che sia Pandas? fig_4 = plt.figure(figsize=(6,4)) axes_4 = fig_4.add_axes([0,0,1,1]) # prendo tutto lo spazio, dall&#39;angolo in basso a sx a quello in alto a dx axes_4.set_title(&#39;da Pandas: IceCream&#39;) axes_4.set_xlabel(&#39;temp&#39;) axes_4.set_ylabel(&#39;sales&#39;) axes_4.plot(x_2, y_2, marker=&#39;+&#39;); # ho messo sui punti le crocette come in Gnuplot Annotare la figura Se voglio mettere delle annotazioni nel grafico, come per esempio delle frecce, devo usare un metodo degli axes chiamato annotate. Vediamo nel dettaglio il comando: axes_4.annotate(&#39;Good Month&#39;, xy=(83, 536), xytext=(60,520), arrowprops= dict(facecolor=&#39;black&#39;, shrink=0.0, width=0.5)) &#39;Good Month&#39; e’ il testo che viene inserito xy=(83,536) e’ il punto di arrivo della freccia xytext=(60,520) e’ il punto di partenza del testo orizzontale All’interno di arrowprops si hanno vari parametri (si deve passare un dizionario con tutti gli argomenti) facecolor= ‘black’ shrink=0.5 indica quanto piu’ corta deve essere la freccia, rispetto alla lunghezza massima che va dalla fine del testo al punto di arrivo della freccia. width=0.5 possiamo anche allargare la larghezza fig_4 = plt.figure(figsize=(6,4)) axes_4 = fig_4.add_axes([0,0,1,1]) # prendo tutto lo spazio, dall&#39;angolo in basso a sx a quello in alto a dx axes_4.set_title(&#39;da Pandas: IceCream&#39;) axes_4.set_xlabel(&#39;temp&#39;) axes_4.set_ylabel(&#39;sales&#39;) axes_4.plot(x_2, y_2) axes_4.annotate(&#39;Good Month&#39;, xy=(83, 536), xytext=(60,520), arrowprops= dict(facecolor=&#39;black&#39;, shrink=0.0, width=0.5)) Text(60, 520, &#39;Good Month&#39;) bar() Barchart sotto il grafico bar() e’ un metodo di plt Se voglio fare aggiungere anche le barchart sotto il grafico, basta disegnare ANCHE loro! Attento ho fatto 2 plot: il primo e’ dato da axes_4.plot(x_2, y_2) ed e’ passato come un metodo degli assi il secondo e’ un grafico veloce ed e’ una funzione di matplotlib: plt.bar(x_2, y_2, width=1.5); fig_4 = plt.figure(figsize=(6,4)) axes_4 = fig_4.add_axes([0,0,1,1]) # prendo tutto lo spazio, dall&#39;angolo in basso a sx a quello in alto a dx axes_4.set_title(&#39;da Pandas: IceCream&#39;) axes_4.set_xlabel(&#39;temp&#39;) axes_4.set_ylabel(&#39;sales&#39;) axes_4.plot(x_2, y_2) axes_4.annotate(&#39;Good Month&#39;, xy=(83, 536), xytext=(60,520), arrowprops= dict(facecolor=&#39;black&#39;, shrink=0.0, width=0.5)) plt.bar(x_2, y_2, width=1.5); Impulsi stem() e proprieta’ setp() In gnuplot mettevo with impulses quando volevo che il grafico avesse delle linee verticali che partono dall’asse x e raggiungono ogni punto. Il comando descritto qui sopra bar() non e’ l’ideale per ottenere questo risultato in quanto la larghezza dell’impulso puo’ creare problemi, meglio usare la funzione: plt.stem() mentre posso decidere di colorare l’asse sotto tramite la funzione set property: plt.setp() Questa funzione puo’ essere usata per vari oggetti! fig_4 = plt.figure(figsize=(6,4)) axes_4 = fig_4.add_axes([0,0,1,1]) # prendo tutto lo spazio, dall&#39;angolo in basso a sx a quello in alto a dx axes_4.set_title(&#39;da Pandas: IceCream&#39;) axes_4.set_xlabel(&#39;temp&#39;) axes_4.set_ylabel(&#39;sales&#39;) axes_4.plot(x_2, y_2) axes_4.annotate(&#39;Good Month&#39;, xy=(83, 536), xytext=(60,520), arrowprops= dict(facecolor=&#39;black&#39;, shrink=0.0, width=0.5)) markerline, stemlines, baseline = plt.stem(x_2, y_2, &#39;-.&#39;) plt.setp(baseline, &#39;color&#39;, &#39;r&#39;, &#39;linewidth&#39;, 2) [None, None] TeX - regular expressions possiamo usare Latex per scriver formule matematiche usando per esempio $\frac{1}{2}$ IMPORTANTE nota che nel tutorial ha usato: r&#39;$\alpha \beta \gamma$&#39; non ha semplicemente messo ‘’ perche’ cosi’ prende le regular expression, come il dollaro e lo slash. Ovvero la scrittura r’ciao $\frac{2}{3}’ crea una stringa che pero’ ha delle regular expression che vengono valutate ed eseguite. basta poi ricordare i comandi di Latex il metodo .text degli ‘axes’ mette ha all’inizio le coordinate (separate da una virgola), poi una virgola con il testo da inserire. fig_5 = plt.figure(figsize=(5,4), dpi=100) axes_5 = fig_5.add_axes([0.1, 0.1, 0.9, 0.9]) # costruisco un axes axes_5.text(0,23, r&#39;$\alpha~ \beta~ \gamma ~ \frac{1}{2} ~\Sigma$&#39;) # prima le coordinate del testo, poi il testo axes_5.plot(x_1, y_1) [&lt;matplotlib.lines.Line2D at 0x2de66ff15e0&gt;] Istogrammi plt.hist() Alcuni argomenti utili per gli istogrammi: stacked=True Simuliamo probabilita’ di lancio di 2 dadi. Ci sono 11 possibili valori per la somma: 1+1 =2 I 1+2 =3 II 1+3 =4 III 1+4 =5 IV 1+5 =6 V 1+6 =7 VI 2+6 =8 VII (nota che tutti gli altri valori di (2+qualcosa) danno dei risultati gia’ ottenuti) 3+6 =9 VIII 4+6 =10 IX 5+6 =11 X 6+6 =12 XI Come altri parametri: density=True mostra la frequenza di ogni bin (se e’ falso mostra il conteggio) stacked=True cosa fa? Attento: ricorda che il numero di bins puo’ portare a risultati MOLTO fuorvianti. Per esempio se scegliamo bins=7 otteniamo un oggetto bicefalo attorno al centro. Se invece scegliamo bins=11 otteniamo una campana! arr_1 = np.random.randint(1,7,5000) # genera 5000 numeri interi tra 1 e 6 arr_2 = np.random.randint(1,7,5000) # genera 5000 numeri interi tra 1 e 6 arr_3 =arr_1+arr_2 arr3ok = arr_3 plt.hist(arr3ok, bins= 7, density=True, stacked =False); plt.hist(arr_3, bins= 11, density=True, stacked =True); ax[0].hist() Axes e istogrammi Qui sotto provo a combinare axes e istogrammi. Ho supposto di poter usare il metodo hist() direttamente su un asse invece che dover usare un plt.hist, ovvero: axes.hist(...) Funge! fig , ax = plt.subplots(figsize=(8,4), nrows=1, ncols= 2) #plt.tight_layout() ax[0].hist( arr_3, bins= 11, density=True, stacked =True); ax[1].hist( arr_3, bins= 11, density=False, stacked =False); altri argomenti che si possono passare: Range deve essere una tupla con il range di cui si e’ interessati cumulative =True costruisce la CDF (cumulative distribution function) dati i valori. Attento non me lo prendeva (diceva qualcosa riguardo l’oggetto kernel). Non ho lanciato tutte le altre celle, ma solo quelle iniziali con gli header e quelle della cella Istogramma histtype= &#39;step&#39; genera un grafo con le linee (ma vuoto) color = &#39;orange&#39; colora di arancione… orientation = &#39;horizontal&#39; gira di 90 gradi l’istogramma posso combinare anche due istogrammi insieme come con gli altri plot. plt.hist(arr_3, bins= 11, density=True, stacked =True, cumulative=True, histtype=&#39;step&#39;, color=&#39;blue&#39;, orientation= &#39;horizontal&#39;); Bar charts Che differenza c’e’ tra un grafo a barre e un istogramma? de facto nell’istogramma si mettono le frazioni e le “barre” sono attaccate l’una all’altra. In un bar chart invece si hanno i numeri e le barre non sono attaccate l’una all’altra, questo perche’ sull’asse delle x spesso non si hanno dei valori numerici, ma categorici (come nell’esempio riportato sotto, dove l’ordine delle colonne e’ sostanzialmente arbitrario). Per un grafo a barre, si chiama la funzione seguente: plt.bar(spc, m_eng,width=larghezza, label=&#39;maschi&#39;, edgecolor =&#39;k&#39;) il primo argomento contiene la lista/tupla con i nomi che appaiono sull’asse delle x (dato che spesso lo usiamo per variabili categoriche dobbiamo indicare le label), oppure le posizioni delle barre (se ho le posizioni dovro’ poi aggiungere le label sull’asse) Attento se nella prima tupla ci sono dei nomi, allora le loro posizioni sono equispaziate automaticamente. Se io aggiungo un altro bar chart, questo secondo viene messo dopo quelle gia’ esistenti. Attento se invece nella prima tupla ci sono dei float (che quindi definisce la posizione delle barre), allora facendo un secondo plot, quest’ultimo segue le proprie posizioni. Attento pui mettere 2 bar chart, uno con variabili categoriche e uno con float. Le posizioni delle categoriche sono messe automaticamente in integer (che partono quindi da zero). Nell’esempio qui sotto, la barra di nuclear ha posizione sull’asse delle x uguale a 0, hydro e’ in posizione 1, … il secondo argomento contiene l’array che con le altezze della barchart yerr ??? serve per la barra che indica l’errore, ed e’ un array che deve contenere tanti oggetti quante sono le barre width larghezza della barra (altrimenti da’ errore? ) label non la vedo… scritta forse bisogna attivarla. Anche nel video non fungeva ## energia francese x = [&#39;nuclear&#39;, &#39;hydro&#39;, &#39;coal&#39;, &#39;gas&#39;, &#39;solar&#39;, &#39;wind&#39;, &#39;other&#39;] per_1 = [71,10,3,7,2,4,3] # percentuale variance = [8,3,1,3,1,2,1] # varianza per anno plt.bar(x, per_1, color=&#39;purple&#39;,yerr=variance, label=&#39;prova&#39;) &lt;BarContainer object of 7 artists&gt; ## energia francese x = [&#39;nuclear&#39;, &#39;hydro&#39;, &#39;coal&#39;, &#39;gas&#39;, &#39;solar&#39;, &#39;wind&#39;, &#39;other&#39;] per_1 = [71,10,3,7,2,4,3] # percentuale variance = [8,3,1,3,1,2,1] # varianza per anno plt.bar(x, per_1, color=&#39;purple&#39;,yerr=variance, label=&#39;prova&#39;) y = [el + &#39; &#39; for el in x] z = [&#39;test1&#39;, &#39;test2&#39;, &#39;test3&#39;] z2 = [1, 2, 10] per_2 = [34,43,21] plt.bar(z2, per_2, color=&#39;red&#39;, label=&#39;prova&#39;) &lt;BarContainer object of 3 artists&gt; y [&#39;nuclear &#39;, &#39;hydro &#39;, &#39;coal &#39;, &#39;gas &#39;, &#39;solar &#39;, &#39;wind &#39;, &#39;other &#39;] Bar Chart affiancate Qui sotto mettiamo due bar chart affiancate una da parte all’altra. In questo modo possiamo confrontare dati diversi. E’ fondamentale che la posizione dell’array che definisce l’asse delle x della seconda bar chart sia spostato rispetto all’asse delle x della prima bar chart di una quantita’ tale da non fare sovrapporre (a meno di volerlo). Per esempio di puo’ usare lo stesso array maggiorato della larghezza della barchart! m_eng = (76,85,86,88,93) # percentuale maschi ingegneri f_eng = (24,15,14,12,7) # femmine spc = np.arange(5) larghezza =0.45 plt.bar(spc , m_eng,width=larghezza, label=&#39;maschi&#39;, edgecolor =&#39;k&#39;) plt.bar(spc+larghezza, f_eng,width=larghezza, label=&#39;femmine&#39;, edgecolor =&#39;k&#39;) #plt.xticks(spc + larghezza/2, (&#39;Aero&#39;, &#39;Chem&#39;, &#39;Civil&#39;, &#39;Elect&#39;, &#39;Mec&#39;)) plt.xticks(spc , (&#39;Aero&#39;, &#39;Chem&#39;, &#39;Civil&#39;, &#39;Elect&#39;, &#39;Mec&#39;)) ; # altrimenti lo mette a meta&#39; strada del primo istogramma Bar Chart impilate (stacked) Qui mettiamo le barre una sopra l’altra. Diamo un’occhiata alla list comprehension che viene usata: ind = [x for x, _ in enumerate(t_type)] enumerate restituisce delle coppie: posizione, oggetto. Non ci serve l’oggetto ma solo la posizione, qunidi non spreco una variabile y, metto _ Prendi tutte le posizioni che ci sono nell’oggetto t_type questa volta la label e’ apparsa nella legenda. ATTENTO il parametro bottom dice cosa c’e’ sotto di questa barchart. In particolare possiamo indicare un array, o anche una somma di array come nell’esempio di cui sotto. Se mettiamo un array che viene disegnato nella barchart, allora stiamo in pratica impilando il nuovo barchart sopra quello dell’altro array ############# DATI ###################### t_type= [&#39;kind&#39;, &#39;elem&#39;, &#39;sec&#39;, &#39;special&#39;] print(type(t_type)) m_teach = np.array([2,20,44,14]) f_teach = np.array([98,80,56,86]) n_teach = np.array([12,14,13,15]) ind = [x for x,_ in enumerate(t_type)] # list comprehension. Vedi sopra per come si legge plt.bar(ind, n_teach, width=larghezza, label=&#39;nuovo&#39;, bottom=f_teach+m_teach) # posso metterne piu&#39; di uno sotto plt.bar(ind, m_teach, width=larghezza, label=&#39;maschi&#39;, bottom=f_teach) # posso metterne piu&#39; di uno sotto plt.bar(ind, f_teach, width=larghezza, label=&#39;femmine&#39;) plt.legend(loc=&#39;lower right&#39;); # non ideale.... #plt.legend(loc=0); # manco questo... &lt;class &#39;list&#39;&gt; Torte - Pie chart, plt.pie() Vediamo i diagrammi a torta. Per questi si usa il comando: wedges, texts, autotexts = plt.pie(poke_num, explode=explode, labels=types, colors=colors, autopct=&#39;%1.0f%%&#39;, shadow=True, startangle=140, textprops =dict(color=&#39;w&#39;)) Dal punto di vista sintattico la funzione pie() restituisce 3 oggetti: le wedges (gli spicchi o cunei del diagramma a torta). i texts gli autotext In questo caso abbiamo prima costruito la figure, poi gli axes ed infine abbiamo chiamato la funzione pie. E’ un po’ diverso dal solito quando si usava un metodo dell’axes. Nota che in un diagramma a torta, intuitivamente, i valori di larghezza (angolo) associati ad ogni fetta vengono convertiti in percentuali dell’angolo giro. Questo perche’ ci si aspetta che tutti i valori di un array riempiano tutto il cerchio. explode a questa keyword si deve passare un array di float con tanti ingressi quante sono le fette. Il valore di ogni ingresso dice di quanto viene “estratta” la fetta alla posizione corrispondente, vedi l’esempio sotto. nell’esempio sotto ci sono 2 array: types e pole_num, questi devono avere il medesimo numero di ingressi. labels=types e’ un parametro che indica le etichette associate ad ogni fetta autopct indica come vengono arrotondati i numeri associati alle larghezze, gli si deve passare come valore una stringa che indica un formato. shadow=true e’ il parametro che dice se mettiamo l’ombra colori ha usato un trucco notevole, ha fatto scrivere dei valori in formato RGB tramite il generatore di numeri casuali. Tre numeri indicano un colore, e lui indicando il range dei colori tra [0, 0.5] ha fatto si’ che vengono scuri. Ha scelto i colori scuri perche’ la scritta viene in bianco! Occhio, avevo fatto un errore di sintassi ma non semplice da osservare. Nell’array types che contiene dei nomi tra virgolette, in un caso, quando andavo a capo ho dimenticato di mettere una virgola tra un nome e l’altro e lui mi ha preso solo uno dei nomi bbox_to_anchor = (1,0,0.5,1) serve per spostare di 1 e 1/2 a destra della piechart (???) import random fig_6 = plt.figure(figsize=(8,5)) axes_6 = fig_6.add_axes([0.1,0.1,0.9,0.9]) #Vogliamo un diagramma a torte types = [&#39;water&#39;, &#39;normal&#39;, &#39;flying&#39;, &#39;grass&#39;, &#39;psychic&#39;,&#39;bug&#39;, &#39;fire&#39;, &#39;poison&#39;, &#39;ground&#39;,&#39;rock&#39;,&#39;fighting&#39;, &#39;dark&#39;, &#39;steel&#39;, &#39;electric&#39;,&#39;dragon&#39;,&#39;fairy&#39;,&#39;ghost&#39;,&#39;ice&#39;] poke_num =[133, 109, 101, 98, 85, 77, 68, 66, 65, 60, 57, 54, 53, 51, 50, 50, 46, 40] colors = [] for i in range(18): # per il testo bianco genero i coloi delle fette in modo che siano scuri rgb = (random.uniform(0,.5) , random.uniform(0,.5) , random.uniform(0,.5) ) colors.append(rgb) explode = [0] * 18 # ho creato una lista di 18 zeri (non mi ricordavo questo modo!) explode[0] = 0.2 # esplodi la prima fetta ma solo di 0.2 #print(len(types)); #print(len(poke_num)); wedges, texts, autotexts = plt.pie(poke_num, explode=explode, labels=types, colors=colors, autopct=&#39;%1.0f%%&#39;, shadow=True, startangle=140, textprops =dict(color=&#39;w&#39;)) plt.legend(wedges, types, loc=&#39;right&#39;, bbox_to_anchor = (1,0,0.5,1)); # sposto dalla piechart Serie Temporali Qui vediamo come fare un grafico con una serie temporale in cui i vari punti sono etichettati con un timestamp. Puo’ essere necessario togliere dei giorni particolari e risulta piu’ comodo sapere la data piuttosto che trovare il punto corrispondente della time series. Il database usato viene da Yahoo riguardo i dati di google, GOOG.csv. (non e’ esattamente come mostrato nel video ma si trova in fretta). Per trovarlo cerca con google “yahoo google stock”, seleziona le date e fai download (nota che la frequenza e’ giornaliera). All’inizio si carica il file con read_csv di Pandas, poi si trasforma la tabella in un array di numpy (sono tutti valori numerici). Lui usa un metodo dei DataFrame di Pandas che io non uso mai: tp_numpy(). Io invece faccio semplicemente np.array(). Ho provato a fare un giro piu’ semplice, cercando di plottare i dati direttamwente DAL DataFrame, di cui seleziono le colonne volute (ma avendo prima selezionato le righe, vedi sotto). Sfortunatamente sull’asse delle x vengono dei valori sballati come tics, il grafico e’ pero’ corretto. Questo e’ probabilmente il motivo per cui lui preferisce trasformare tutto in array di Numpy. Scrubbing data: per esempio vogliamo togliere alcune vacanze, ha controllato due date che sono vacanze e vuole escluderlo. Usa datetime. La funzione datetime.datetime(2020,5,25) crea una data in un oggetto specifico, che puo’ poi essere trasformato a seconda delle esigenze, p.es g/m/a o m/g/a ecc. Poi costruisce un array di date che vanno da una data iniziale ad una finale, tramite un metodo di pandas: pd.bdate_range, si puo’ passare il parametro frequency freq =&#39;C&#39; in questo caso, ma no so cosa sia il valore ‘C’! holidays e’ il nome di un altro parametro che appunto corrisponde alle vacanze e possiamo passare un array/tupla contentente dei dati in formato datetime che vengono riconosciuti. ATTENTO la mia versione non riconosce questo parametro. Ho riscritto tutto e ora funge. Problema: non so quando ha preso lui le date da Yahoo, io ho piu’ giorni. Problema2 se uso tutti questi giorni, i tics che vengono segnati sono troppi e sotto l’asse viene un guazzabuglio di linee. Devo modificare per ottenere le date corrette. import datetime goog_data = pd.read_csv(&#39;GOOG.csv&#39;) # IMPORTO il file GOOG.csv che ho salvato nella dir corrente goog_data_np = goog_data.to_numpy() # trasformo in np.array #goog_data_np =np.array(goog_data) # modo alternativo di trasformare goog_cp = goog_data_np[:,4] holidays = [datetime.datetime(2020,5,25) , datetime.datetime(2020,8,19) ] # creo una lista con due date che saranno vacanze date_arr = pd.bdate_range(start =&#39;5/20/2020&#39; , end =&#39;8/19/2020&#39; , freq =&#39;C&#39;, holidays = holidays) date_arr_np = date_arr.to_numpy() goog_data.head(3) Date Open High Low Close Adj Close Volume 0 2019-08-21 1193.150024 1199.000000 1187.430054 1191.250000 1191.250000 740700 1 2019-08-22 1194.069946 1198.011963 1178.579956 1189.530029 1189.530029 947500 2 2019-08-23 1181.989990 1194.079956 1147.750000 1151.290039 1151.290039 1687000 Selezionare righe secondo delle date Seguo questo esempio per selezionare le date: https://stackoverflow.com/questions/29370057/select-dataframe-rows-between-two-dates Creo una mask per selezionare le date che voglio e che devono seguire quelle indicate nel bdate_range. In pratica creo una maschera, ovvero un array di bool che poi posso passare a loc! In questo modo solo gli ingressi in cui la maschera e’ vera vengono selezionati. Problema I: devo paragonare delle date… in formati magari diversi Soluzione I uso pd.to_datetime() che e’ una goduriosa funzione di Pandas che converte una stringa in un oggetto di tipo datetime. Questo oggetto e’ una data ed e’ possibile paragonare due datetime per vedere chi viene prima o dopo! Questa funzione e’ particolarmente VANTAGGIOSA in quanto riconosce tanti tipi diversi di formato in cui possiamo scrivere una data e li converte i un unico oggetto! Alternativa usa parse_dates (vedi il Finance Module) Una volta ottenuto un modo per paragonare le date posso creare una lista con valori booleani in cui seleziono le date (basta un loop), chiamo questo oggetto maschera Problema II la maschera cosi’ creata non e’ un oggetto iterabile che si possa mettere nel metodo loc di pandas. Devo tasformarlo in un oggetto non iterabile Soluzione II basta costruire una funzione che prende come input qualcosa e quando lo sputa in output gli metto un tuple davanti! DUBBIO ehi ma nel codice non ho usato la tupla, anzi se dove faccio finanza metto la tupla mi da errore, sembra che una Series di pandas vada bene Attenzione pero’ la maschera cosi’ creata e’ un oggetto mutabile e questo non puo’ essere usato come ingresso della funzione loc (di PANDAS) perche’ questa necessita oggetti immutabili da cui puo’ estrarre una hashtable. link utili: loc: https://stackoverflow.com/questions/29370057/select-dataframe-rows-between-two-dates to_datetime: https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.to_datetime.html convertire lista in tupla: https://www.geeksforgeeks.org/python-convert-a-list-into-a-tuple/ # PROBLEMA I # qui sotto prendo la colonna Date del dataFrame # poi converto i valori ivi contenuti in un oggetto di tipo datetime con to_datetime # a questo punto li paragono ai valori entro cui voglio che siano le date, sempre # sfruttando la funzione di pandas pd.to_datetime mask = ( ( pd.to_datetime(goog_data[&#39;Date&#39;]) &gt;= pd.to_datetime(&#39;5/20/2020&#39;)) &amp; ( pd.to_datetime(goog_data[&#39;Date&#39;]) &lt;= pd.to_datetime(&#39;8/19/2020&#39;)) ) # PROBLEMA II # l&#39;oggetto mask non e&#39; di tipo immutabile e quindi non puo&#39; essere usato come iteratore # devo trasformarlo in unoggetto immutabile def convert(list): return tuple(list) mask_t= convert(mask) #print(type(mask_t) , &#39;tipo maschera&#39;) # controllo #print(len(goog_data.loc[mask])) # controllo che i due oggetti abbiano lo stesso numero di righe new = goog_data.loc[mask] # loc NON lavora inplace &lt;=================== new_np = new.to_numpy() goog_cp = new_np[:,4] # # PROBLEMA III # Costruisco un array con le date corrispondenti in modo che io possa poi disegnarle fig_7 = plt.figure(figsize=(8,5)) # creiamo la figura/canvas come al solito axes_7 = fig_7.add_axes([0.1,0.1, 0.9, 0.9]) # il grafico non copre tutta la figura, lasciamo un po&#39; di padding plt.plot(date_arr_np, goog_cp); #plt.plot(new.Date, new.Close) # questo fa vedere sbagliato i tics sotto Tabelle Questo non e’ cosi’ interessante, la cosa che trovo piu’ utile e’ come girare le date sull’asse delle x. Copio il pezzo di notebook scritto da Banas qui sotto: # Format column data to 2 decimals goog_data[&#39;Open&#39;] = pd.Series([round(val, 2) for val in goog_data[&#39;Open&#39;]], index = goog_data.index) goog_data[&#39;High&#39;] = pd.Series([round(val, 2) for val in goog_data[&#39;High&#39;]], index = goog_data.index) goog_data[&#39;Low&#39;] = pd.Series([round(val, 2) for val in goog_data[&#39;Low&#39;]], index = goog_data.index) goog_data[&#39;Close&#39;] = pd.Series([round(val, 2) for val in goog_data[&#39;Close&#39;]], index = goog_data.index) goog_data[&#39;Adj Close&#39;] = pd.Series([round(val, 2) for val in goog_data[&#39;Adj Close&#39;]], index = goog_data.index) # Get most recent last 5 days of stock data stk_data = goog_data[-5:] stk_data # Define headers col_head = (&#39;Date&#39;,&#39;Open&#39;,&#39;High&#39;,&#39;Low&#39;,&#39;Close&#39;,&#39;Adj Close&#39;,&#39;Volume&#39;) stk_data_np = stk_data.to_numpy() stk_data_np # Add padding around cells in table plt.figure(linewidth=2, tight_layout={&#39;pad&#39;:.5}, figsize=(5,3)) # Get rid of axes and plot box axes_8 = plt.gca() axes_8.get_xaxis().set_visible(False) axes_8.get_yaxis().set_visible(False) plt.box(on=None) # np.full returns an array filled with 0.1 # cm is a colormap object we are using to use a default blue color # matplotlib.org/3.1.0/tutorials/colors/colormaps.html ccolors = plt.cm.Blues(np.full(len(col_head), 0.2)) # Receives data, loc, list of column headers, column header color as array of colors # You can also add rowLabel, rowColours, rowLoc: Text alignment the_table = plt.table(cellText=stk_data_np, loc=&#39;center&#39;, colLabels=col_head, colColours=ccolors) # Set table font size the_table.set_fontsize(14) the_table.scale(3, 2.5) C:\ProgramData\Anaconda3\lib\site-packages\IPython\core\pylabtools.py:132: UserWarning: Tight layout not applied. The left and right margins cannot be made large enough to accommodate all axes decorations. fig.canvas.print_figure(bytes_io, **kw) ScatterPlot Qui ci sono dei dati relativi al Coronavirus. E’ importante che ci sia uniformita’ di grandezza per quanto riguarda gli array che vanno plottati: ci sono 26 nazioni ci sono 26 tassi di mortalita’ ci sono 26 valori di casi confermati giornalieri ci sono 26 dimensioni dei punti Nota che i questo caso non costruisco la figura e poi gli assi. Questo perche’ viene fatto automaticamente dal comando plt.scatter. Ci sono 2 vie per ottenere lo stesso grafico: costruisco la fig, e gli assi e uso scatter come metodo sull’asse creato uso plt.scatter e lui automaticamente crea gli assi! Argomenti dello scatterplot: prima si mettono i valori dell’asse delle x (e’ un np.array) poi l’array per i valori dell’asse delle y (anche questo un np.array lungo quanto quello sopra) s per size (dei punti): NON e’ come gnuplot che accettava le abbreviazioni, qui il parametro si chiama SOLO s! c per color (dei punti) alpha e’ in pratica il livello di trasparenza, in questo caso e’ fondamentale in quanto alcuni punti andranno a sovrapporsi # Numpy array con i nomi delle nazioni cnt_arr = np.array([&#39;Australia&#39;,&#39;Brazil&#39;,&#39;Canada&#39;,&#39;Chile&#39;,&#39;France&#39;,&#39;Germany&#39;,&#39;Greece&#39;, &#39;Iceland&#39;,&#39;India&#39;,&#39;Iran&#39;,&#39;Italy&#39;,&#39;Mexico&#39;,&#39;New Zealand&#39;,&#39;Nigeria&#39;, &#39;Norway&#39;,&#39;Pakistan&#39;,&#39;Peru&#39;,&#39;Russia&#39;,&#39;Saudi Arabia&#39;,&#39;Singapore&#39;, &#39;South Africa&#39;,&#39;Spain&#39;,&#39;Sweden&#39;,&#39;Turkey&#39;,&#39;UK&#39;,&#39;US&#39;]) # Tasso mortalita per 100k casi Coronavirus dr_arr = np.array([1.8,53,24.5,56.5,45.4,11.2,2.2, 2.8,4,24.6,58.6,46.3,.5,.5, 4.9,2.9,83.3,11,10.4,.5, 21.5,61.6,56.9,7.3,62.4,52.9]) # Numero giornaliero di casi confermati (Tests) test_arr = np.array([110,7197,600,1862,1636,1103,35, 10,295,1658,1226,2490,8,243, 48,1395,1101,4447,1443,280, 2830,1602,447,1205,1546,24988]) # Dimensione del punto dei casi confermati cc_arr = np.array([24236,3456652,125408,390037,256534,229706,7684, 2035,2836925,350279,255278,537031,1654,50488, 10162,290445,549321,935066,302686,56031, 596060,370867,85411,253108,323008,5529824]) cc_arr_sm = cc_arr/1000 # rimpicciolisce a dimensione dei punti (?) color_arr= np.random.rand(26) # Se faccio questi sotto vengono aggiunti ad una figura aggiuntiva, non al mio scatterplot # questo perche&#39; ho provato ad usare la strada per cui prima faccio la figura, aggiungo gli assi # e il disegno viene con un metodo! #plt.title(&#39;Mortalita per 100k vs. Casi confermati&#39;) #plt.xlabel(&#39;Mortalita per 100k&#39;) #plt.ylabel(&#39;Casi confermati&#39;) #plt.scatter(dr_arr, test_arr, s=cc_arr_sm, c=color_arr,alpha=0.5 ) #plt.figure(figsize=(8,5)) fig_13 = plt.figure(figsize=(8,5)) axes_13 = fig_13.add_axes([0.1,0.1,0.9,0.9]) axes_13.set_xlabel(&#39;Mortalita per 100k&#39;) axes_13.set_ylabel(&#39;Casi confermati&#39;) axes_13.set_title(&#39;Mortalita per 100k vs. Casi confermati&#39;) axes_13.scatter(dr_arr, # valori sull&#39;asse delle x test_arr, # valori sull&#39;asse delle y s=cc_arr_sm, # valori che indicano la dimensione dei punti c=color_arr, # colori di ogni punto alpha=0.2 ); # trasparenza 1 = no trasparenza, 0 = completamente trasparente 3D from mpl_toolkits import mplot3d abbiamo bisogno di importare questo modulo projection=&#39;3d&#39; quando si costruisce la figura si aggiunge questo parametro fig_9 = plt.figure(figsize=(8,5), dpi=100) dpi=100 stranamente sembra avere un effetto sulla dimensione della figura, mentre sembra non prendere il parametro figsize! Probabilmente questo e’ dovuto al fatto che con %matplotlib inline mi mette le figure come dei png, cambiando il numero di punti questo cambia la dimensione dell’immagine a schermo. Per esempio dpi=100 e’ circa un terzo della figura con dpi=300 scatter3D la funzione per uno scatterplot 3D c= z_3 se uso questo parametro per i colori, allora quelli piu’ in alto (asse z) avranno una sfumatura differente da quelli in basso Scatter3D from mpl_toolkits import mplot3d fig_9 = plt.figure(figsize=(6,5), dpi=100) axes_9 = fig_9.add_axes([0.1,0.1,0.9,0.9], projection=&#39;3d&#39;) # mette degli assi 3D z_3 = 40 *np.random.random(100) # random: sample dalla [0,1) uniforme x_3 = np.sin(z_3) * np.random.randn(100) # randn y_3 = np.cos(z_3) * np.random.randn(100) # randn: sample dalla N(0,1) #axes_9.scatter3D(x_3,y_3,z_3, cmap=&#39;Blues&#39;); axes_9.scatter3D(x_3,y_3,z_3, c=z_3, cmap=&#39;Blues&#39;); Contour3D In questo caso ho bisogno di una funzione z =z(x,y) questo perche’ lui deve poter sapere la altezza in ogni punto. per costruire una griglia rettangolare devo usare np.meshgrid: x_4, y_4 = np.meshgrid(x_4, y_4) occhio che se non metto questo comando mi dice che c’e’ un errore!? Il motivo e’ semplice. meshgrid prende in ingresso due array 1 dimensionali e restituisce due array 2 dimensionali. In pratica ha fatto un prodotto cartesizano per ognuno dei punti del primo array creando una coppia con quelli del secondo array (e viceversa per il secondo array). Questo perche’ contour3D si aspetta delle matrici per le x e le y e anche le z, in quanto per ogni x e y c’e’uno z. Per capire meglio fai fare print(x_4) prima e dopo meshgrid e vedi la differenza. Angolo di vista, per cambiare: axes_9.view_init(45, 55). questo sposta l’angolo di vista di 45 gradi e lo ruota di 55 il 4to parametro indica il numero di linee. In pratica quante fette parallele al piano xy che vengono visualizzate, se metto 80 sono tante, se metto 20 sono poche fig_9 = plt.figure(figsize=(6,5), dpi=100) axes_9 = fig_9.add_axes([0.1,0.1,0.9,0.9], projection=&#39;3d&#39;) def get_z (x,y): return np.sin(np.sqrt(x**2+y**2)) x_4 = np.linspace(-6,6,30) y_4 = np.linspace(-6,6,30) #print(x_4) x_4, y_4 = np.meshgrid(x_4, y_4) #print(x_4) z_4 = get_z(x_4, y_4) axes_9.set_xlabel(&#39;x&#39;) axes_9.set_ylabel(&#39;y&#39;) axes_9.set_zlabel(&#39;z&#39;) axes_9.view_init(35, 30) # angolo di visione, angolo di rotazione axes_9.contour3D(x_4,y_4,z_4, 20, cmap=&#39;Blues&#39;); WireFrame e surface In questo caso vengono connessi tutti i punti da un segmento. -plot_wireframe(x_4,y_4,z_4, cmap=&#39;Blues&#39;) in questo caso non devo passare il numero di tagli paralleli all’asse xy, quindi non ha il 4to parametro. edgecolor =&#39;none&#39; non colora i segmenti di collegamento (il wireframe) fig_9 = plt.figure(figsize=(6,5), dpi=100) axes_9 = fig_9.add_axes([0.1,0.1,0.9,0.9], projection=&#39;3d&#39;) axes_9.view_init(35, 30) # angolo di visione, angolo di rotazione #axes_9.plot_wireframe(x_4,y_4,z_4, cmap=&#39;Blues&#39;); axes_9.plot_surface(x_4,y_4,z_4, rstride=1, cstride=1, cmap=&#39;Blues&#39;, edgecolor=&#39;r&#39;); Finance Module per installare ho fatto: anaconda prompt pip install mpl_finance pip install –upgrade mplfinance # upgrade questo modulo fa vedere le candele giapponesi ecc. posso cambiare il nome dell’index: goog_df.index.name=&#39;Date&#39; a questo punto l’index non si chiama piu’ index ma Date! mi pare di capire che questo sia necessario perche’ la libreria prenda correttamente il dataframe. Candele giapponesi Attento se prendi tante date, non riesci a vedere le candele! devono essere poche per essere visibili. trendlines possiamo mettere automaticamente delle medie mobili con il parametro: -type=&#39;ohlc&#39;, mav=4 # che significa che mette Open High Low Close e la media mobile basata sui precedenti 4 punti,nota che possiamo tenere come type ‘candle’ (ma si vede meno bene) altri tipi di medie mobili. mav=(3,5,7) e’ bene usare dispari, quindi fa vedere 3 medie mobili basate sui 3, 5 e 7 gg precedenti il parametro volume=True va vedere i volumi giornalieri mostrare non-tading days: show_nontrading=True parse_dates parse_dates=true vuol dire che non prende le date come delle semplici stringhe ma le legge come date, infatti ora sono in formato Timestamp import mplfinance as mpf goog_df = pd.read_csv(&#39;GOOG.csv&#39;, index_col = 0, parse_dates=True) #type(goog_df.index[0]) goog_df.index.name=&#39;Date&#39; #goog_df = pd.read_csv(&#39;GOOG.csv&#39;) goog_df.head(3) Open High Low Close Adj Close Volume Date 2019-08-21 1193.150024 1199.000000 1187.430054 1191.250000 1191.250000 740700 2019-08-22 1194.069946 1198.011963 1178.579956 1189.530029 1189.530029 947500 2019-08-23 1181.989990 1194.079956 1147.750000 1151.290039 1151.290039 1687000 mask = ( ( pd.to_datetime(goog_df.index) &gt;= pd.to_datetime(&#39;5/20/2020&#39;)) &amp; ( pd.to_datetime(goog_df.index) &lt;= pd.to_datetime(&#39;8/19/2020&#39;)) ) new = goog_df.loc[mask] # #mpf.plot(new, type=&#39;line&#39;) # normali linee #mpf.plot(new, type=&#39;candle&#39;) # candele giapponesi #mpf.plot(new, type=&#39;ohlc&#39;, mav=4) # open high low close + moving average mpf.plot(new, type=&#39;ohlc&#39;, mav=(3,5,7), volume=True, show_nontrading=True) # open high low close + moving average Heatmap ho un array 2 dimensionale e voglio mostrarlo con dei colori invece che dei numeri. symptoms sono i 4 tipi di malattia a cui si riferiscono i dati (dyspnea = short of breath) dates sono i giorni in cui sono state fatte le osservazioni (sono 9 giorni) symp_per sono il numero di pazienti per giorno per malattia e’ un array 4x9 Nota: pensavo che la heatmap di default mettesse delle righe bianche in mezzo alle caselle risultando molto poco chiara! in realta’ e’ una delle opzioni lasciate dal finance module!!!! (se faccio girare prima la casella sotto le righe bianche in mezzo non ci sono!) Per la heatmap si deve usare subplots() (non figure) Cosa fa il comando? prende la matrice che ha 0,3 righe, e 0,8 colonne. Per ognuna delle righe e delle colonne scrive un colore associato al numero dell’ingresso dell’array da disegnare. symptoms = [&quot;Coronavirus&quot;,&quot;Influenza&quot;,&quot;Pneumonia&quot;,&quot;Dyspnea&quot;] dates = [&quot;Jun28&quot;,&quot;Jul05&quot;,&quot;Jul12&quot;,&quot;Jul19&quot;,&quot;Jul26&quot;,&quot;Aug02&quot;,&quot;Aug09&quot;,&quot;Aug16&quot;,&quot;Aug21&quot;] symp_per = np.array([[5.2, 5.5, 5.7, 5.6, 5.3, 5.1, 5.0, 4.9, 5.3], [3.5, 4.0, 4.3, 3.9, 3.5, 3.2, 2.7, 2.2, 2.0], [1.8, 2.2, 2.3, 2.2, 2.1, 1.9, 1.7, 1.4, 1.3], [1.0, 1.1, 1.1, 1.0, 0.9, 0.8, 0.8, 0.8, 0.7]]) fig_10 , axes_10 = plt.subplots() im= axes_10.imshow(symp_per, cmap=&#39;Wistia&#39;) tics non chiaro perche’ all’inizio metta un np.arange, dato che abbiamo gia’ un array con dates e symptoms: ok: axes_10.set_xtics(np.arange(len(dates)) qui definisce la distanza (posizione) che devono avere i tics sulla mappa. axes_10.set_xticlabels(dates) questo definisce cosa ci deve essere nei ticks occhio che ticks ha la k occhio i ticks vanno assegnati DOPO avere definito la figura e l’axes giro i ticks di 45 gradi! plt.setp(axes_10.get_xticklabels(), rotation=45, ha=&#39;right&#39;, rotation_mode=&#39;anchor&#39;) (non chiaro l’anchor cosa faccia) fig_10 , axes_10 = plt.subplots() im= axes_10.imshow(symp_per, cmap=&#39;Wistia&#39;) axes_10.set_xticks(np.arange(len(dates))) # posizione tics sull&#39;asse x axes_10.set_yticks(np.arange(len(symptoms))) # posizione tics sull&#39;asse y axes_10.set_xticklabels(dates) # cosa viene mostrato ad ogni tic dell&#39;asse x axes_10.set_yticklabels(symptoms) # cosa viene mostrato ad ogni tic dell&#39;asse x plt.setp(axes_10.get_xticklabels(), rotation=45, ha=&#39;right&#39;); Numeri nelle caselle metto qui anche i numeri dentro le caselle. Nota che usa un costrutto che non ho mai usato prima, chiama un metodo dell’axes dentro una funzione di matplotlib. -plt.setp(axes_10.get_xticklabels(), rotation=45, ha=&#39;right&#39;); chiama fig_10 , axes_10 = plt.subplots() im= axes_10.imshow(symp_per, cmap=&#39;Wistia&#39;) axes_10.set_xticks(np.arange(len(dates))) # posizione tics sull&#39;asse x axes_10.set_yticks(np.arange(len(symptoms))) # posizione tics sull&#39;asse y axes_10.set_xticklabels(dates) # cosa viene mostrato ad ogni tic dell&#39;asse x axes_10.set_yticklabels(symptoms) # cosa viene mostrato ad ogni tic dell&#39;asse x plt.setp(axes_10.get_xticklabels(), rotation=45, ha=&#39;right&#39;); for i in range(len(symptoms)): for j in range(len(dates)): text = axes_10.text(j,i, symp_per[i,j], ha=&#39;center&#39;, va=&#39;center&#39;, color=&#39;k&#39;, fontweight=&#39;bold&#39;) Riempire le aree tra curve ci sono ottimi esempi al sito di matplotlib: https://matplotlib.org/3.1.1/gallery/lines_bars_and_markers/fill_between_demo.html il metodo degli assi fill_between() permette di riempire quello che c’e’ tra una curva e l’altra. x = np.arange(0.0, 2, 0.01) # le x y1 = np.sin(2 * np.pi * x) # y1 = la funzione seno y2 = 1.2 * np.sin(4 * np.pi * x) # y2 = funzione seno piu&#39; larga e con maggiore frequenza fig, (ax1, ax2, ax3) = plt.subplots(3, 1, sharex=True) ax1.fill_between(x, 0, y1) # riempie tra 0 e y1 ax1.set_ylabel(&#39;TRA y1 e 0&#39;) ax2.fill_between(x, y1, 1) # riempie tra y1 e 1 (quello che c&#39;e&#39; sopra y1) ax2.set_ylabel(&#39;TRA y1 e 1&#39;) ax3.fill_between(x, y1, y2) # quello che c&#39;e&#39; TRA y1 e sotto y2 ax3.set_ylabel(&#39;TRA y1 e y2&#39;) ax3.set_xlabel(&#39;x&#39;) Text(0.5, 0, &#39;x&#39;) si possono mettere ulteriori condizioni per dare dei colori diversi tra le curve. In particolare si aggiungono dei parametri logici. fig, (ax, ax1) = plt.subplots(2, 1, sharex=True) # costruisce subplots ax.plot(x, y1, x, y2, color=&#39;black&#39;) # disegna le 2 funzioni ax.fill_between(x, y1, y2, where=y2 &gt;= y1, facecolor=&#39;green&#39;, interpolate=True) ax.fill_between(x, y1, y2, where=y2 &lt;= y1, facecolor=&#39;red&#39;, interpolate=True) ax.set_title(&#39;fill between where&#39;) # Test support for masked arrays. y2 = np.ma.masked_greater(y2, 1.0) ax1.plot(x, y1, x, y2, color=&#39;black&#39;) ax1.fill_between(x, y1, y2, where=y2 &gt;= y1, facecolor=&#39;green&#39;, interpolate=True) ax1.fill_between(x, y1, y2, where=y2 &lt;= y1, facecolor=&#39;red&#39;, interpolate=True) ax1.set_title(&#39;Now regions with y2&gt;1 are masked&#39;) Text(0.5, 1.0, &#39;Now regions with y2&gt;1 are masked&#39;) Ticks Al comando ticks possono essere passati degli argomenti per specificare: rotation = 45 ruota di 45 gradi se il primo ingresso e’ un np.array allora quelli sono i ticks (le posizioni) se il secondo ingresso e’ una tupla, allora alle varie posizioni dei ticks vengono messi i valori della tupla fontsize=24 viene passato come al solito puoi passare piu’ di un parametro basta che sia separato dalla virgola! plt.plot(x_1,y_1) #plt.xticks(np.linspace(0,5,100)) #plt.xticks(np.arange(15)) #plt.xticks(np.arange(5), (&#39;Tom&#39;, &#39;Dick&#39;, &#39;Harry&#39;, &#39;Sally&#39;, &#39;Sue&#39;)) #plt.grid(False, color=&#39;r&#39;, dashes=(0,2,1,2)) plt.grid(False) #plt.grid(b=None) degrees = 45 plt.xticks(rotation=degrees) # Rotazione dei ticks mioArray= np.array([1,2,3,4,8]) #plt.xticks(np.linspace(0,5,5), (&#39;Tom&#39;, &#39;Dick&#39;, &#39;Harry&#39;, &#39;Sally&#39;, &#39;Sue&#39;)) plt.grid(True) # presenza della grid plt.xticks(fontsize=24) # GRANDEZZA FONT plt.xticks(mioArray, (&#39;Gino&#39;, &#39;Pino&#39;, &#39;Mino&#39;, &#39;Tino&#39;, &#39;Asdrubale&#39;)); Animazioni Testo di riferimento: https://riptutorial.com/Download/matplotlib-it.pdf Lo ho scaricato ed e’ nella dir. Bisogna importare anche la parte del package che fa animazioni. Bisogna usare il metodo set_data() che assegna i valori delle x e y di un grafico %matplotlib notebook import matplotlib.animation as animation TWOPI = 2*np.pi fig, ax = plt.subplots() # costruiamo una figura e un array di assi t = np.arange(0.0, TWOPI, 0.001) # t =array di posizioni s = np.sin(t) # y = sin(t) l = plt.plot(t, s) # grafico ax = plt.axis([0,TWOPI,-1,1]) # assi redDot, = plt.plot([0], [np.sin(0)], &#39;ro&#39;) # l&#39;oggetto &quot;redDot&quot; disegna il punto rosso, all&#39;inizio e&#39; in zero def animate(i): # questa funzione modifica i parametri del punto rosso redDot.set_data(i, np.sin(i)) # quindi il resto del grafico resta invariato! return redDot, # create animation using the animate() function myAnimation = animation.FuncAnimation(fig, animate, frames=np.arange(0.0, TWOPI, 0.01), \ interval=1, blit=True, repeat=True) &lt;IPython.core.display.Javascript object&gt; Mio test di animazione vorrei fare estendere la funzione seno, in modo che ad ogni frame sia moltiplicata per una diversa ampiezza. Attenzione: ho provato a farlo girare molte volte e non andava. Ho resettato il kernel e ora sembra fungere. Mi viene il dubbio che il problema fosse connesso a qualche cella che avevo lasciato attiva. Curiosamente se metto i limiti degli assi il grafico non appare! Errore Ax e’ un array di assi! interval=1 rallenta l’esecuzione del programma frames sono tutti i vari prarametri che andranno a definire i frame possiamo ingrandire o diminuire la dimensione dei limiti: https://stackoverflow.com/questions/53423868/matplotlib-animation-how-to-dynamically-extend-x-limits TWOPI = 2*np.pi #fig, ax = plt.subplots() # costruiamo una figura e un array di assi fig = plt.figure() ax = fig.add_subplot(111, autoscale_on=False, xlim=(0, 6.29), ylim=(-2, 2)) #ax = plt.axis([0,TWOPI,-1,1]) # ATTENTO assi QUESTO BLOCCA set_xlim #ax.set_xlim([0,TWOPI]) # ERRORE ax non e&#39; un asse ma una tupla di assi! #ax.set_ylim([-1,1]) # ERRORE t = np.arange(0.0, TWOPI, 0.001) # t =array di posizioni s = np.sin(t) # y = sin(t) plt.grid(False) new = plt.plot(t, t) # bisettrice second = plt.plot(t,s/2) curva, = plt.plot(t, s) # grafico #ax = plt.axes(xlim=(0, 10), ylim=(-1, 1)) def animate(A): # questa funzione modifica i parametri del punto rosso curva.set_ydata(A *np.sin(t)) # quindi il resto del grafico resta invariato! #print(A*np.sin(t)) return curva, frames1 = np.arange(0.0,1.0,0.001) frames2 = np.arange(1.0,0.0,-0.001) frames = np.concatenate((frames1, frames2), axis=None) # create animation using the animate() function #myAnimation = animation.FuncAnimation(fig, animate, frames = np.arange(0.0, 1.0, 0.001), \ # interval=10, blit=True, repeat=True) myAnimation = animation.FuncAnimation(fig, animate, frames = frames, \ interval=1, blit=True, repeat=True) &lt;IPython.core.display.Javascript object&gt; Slider interattivo possiamo modificare la figura tramite uno slider interattivo! In questo caso non uso la funzione animate, perche’ la modifica viene fatta in base a cosa tocco sullo slider. from matplotlib.widgets import Slider TWOPI = 2*np.pi fig, ax = plt.subplots() A0 = .5 # valore iniziale ampiezza t = np.arange(0.0, TWOPI, 0.001) # x del grafico s = A0*np.sin(t) # y del grafico (iniziale) l, = plt.plot(t, s, lw=2) # grafico (da capire la virgola) ax = plt.axis([0,TWOPI,-1,1]) # assi (che non verranno toccate) ??? axamp = plt.axes([0.25, .03, 0.50, 0.02]) # non chiaro axIs e axEs # Slider samp = Slider(axamp, &#39;Amp&#39;, 0, 1, valinit=A0) # SLIDER interattivo, si chiama &quot;samp&quot; def update(val): # amp is the current value of the slider amp = samp.val # valore corrente dello slider # update curve l.set_ydata(amp*np.sin(t)) # fai update delle y della curva # redraw canvas while idle fig.canvas.draw_idle() samp.on_changed(update) # ridisegna la figura se muoviamo lo slider #plt.show() &lt;IPython.core.display.Javascript object&gt; 0 Foto Vediamo come mostrare una immagine. Si passa un array 2D e questo viene convertito automaticamente, assegnando ai valori un colore. Per esempio: immagine = np.array([ [1,0,0,0,1,0,0,0,1], [0,0,0,0,1,0,0,0,0], [0,0,0,0,1,0,0,0,0], [0,0,0,0,1,0,0,0,0], [0,0,0,0,1,0,0,0,0], [1,0,0,0,1,0,0,0,1]]) plt.imshow(immagine) &lt;matplotlib.image.AxesImage at 0x2de6a38e640&gt; Unpacking questo non e’ strettamente connesso con matplotlib…. numbers = [1, 2, 3, 4, 5, 6] first, *rest = numbers # multiple assignment print(rest) print(first) d = dict(a=5,b=2,c=4) [2, 3, 4, 5, 6] 1 enumerate() for o,_ in enumerate(d): print(o) # stampa l&#39;ordine degli oggetti 0 1 2 for _, o in enumerate(d): print(o) # stampa le chiavi del dizionario a b c for _, o in enumerate(d): print(d[o]) # stampa i valori del dizionario 5 2 4 for o in enumerate(d): print(o) # stampa le NUOVE coppie chiave-chiave vecchia costruite da enumerate() (0, &#39;a&#39;) (1, &#39;b&#39;) (2, &#39;c&#39;)" />
<meta property="og:description" content="Matplotlib Queste sono le mie (Paolo Avogadro) note basate sul video di Derek Banas riguardo a Matplotlib. Oltre agli esempi suggeriti aggiungo dei miei test e considerazioni. Qualunque errore e’ esclusivamente dovuto ad una mia erronea interpretazione dei comandi. Lo scopo di queste note non e’ di presentare esempi perfettamente funzionanti, ma serve a me come spunto per ricordare i comandi di Matplotlib, e il modello mentale che io ho sul pacchetto. La versione originale di queste note ha la forma di un Jupyter Notebook e quindi possono esserci dei riferimenti ai notebook all’interno del testo. Dopo avere imparato Matplotlib puo’ essere interessante impararare ad usare Seaborn. Cerco di ricostruire gli esempi presentati e fare delle piccole varianti per capire meglio. Queste note suppongono che ci sia una certa conoscenza di base di come fare i grafici al computer, per esempio partendo da Gnuplot. Notazione: cerco di usare l’evidenziatore per i comandi cerco di usare il grassetto per i termini principali Micro-riassunto: Ci sono 2 modi principali per fare un grafico: modo veloce: con le funzioni di plotting, per esempio: plt.plot(x_1, y_1) (dove x_1 e x_2 sono due oggetti contenenti lo stesso numero di variabili). Si possono inoltre aggiungere delle funzioni per controllare le label, il titolo ecc. modo esteso: prima si definisce una figure, per esempio: fig_1 = plt.figure(figsize=(5,4), dpi =100); pensa alla figure come un’immagine bianca. poi si costruisce uno (o piu’) axes (assi) con un metodo delle figure: axes_1 = fig_1.add_axes([0.1,0.1,0.9,0.9]) (dove specifichiamo la posizione degli assi all’interno della figura). Gli assi determineranno la posizione del grafico. Per esempio se hai un solo quadrante per il tuo grafico puoi immaginare gli assi come un rettangolo (vuoto all’interno). A questo punto si fa partire un grafico, usando un metodo degli assi, per esempio: axes_1.plot(x_1,y_1); Nota che questi metodi sono in pratica le stesse funzioni del punto 1 (solo che vengono chiamati come metodi dell’asse). Nota se non sei in un jupyter notebook dovrai usare un plt.show() se sei su un notebook invece, serve un magic command (e’ una di quelle cose decorate con il percentuale), ci sono vari di questi comandi, tra cui: %matplotlib inline (questo fa apparire delle immagini png statiche nel notebook) %matplotlib notebook (si possono fare zoom delle immagini) %matplotlib tk (tkinter GUI) Una lista di termini utili: alpha=0.75 definisce la trasparenza lw=2 larghezza delle linee del grafico ls =&#39;-.&#39; line style, se e’ una linea continua, oppure trattino e punto, ecc… marker = &#39;o&#39; marker sono i punti di gnuplot. Cosa viene messo nei punti? in questo caso dei cerchietti =o) markersize=7 la grandezza dei punti markerfacecolor =&#39;y&#39; il colore dell’interno dei punti markeredgecolor=&#39;k&#39; il colore dei contorni dei punti markeredgewidth=2 la larghezza del contorno dei punti projection=&#39;3d&#39; argomento per quando si creano degli assi e devono avere un 3D goog_df = pd.read_csv(&#39;GOOG.csv&#39;, index_col = 0, parse_dates=True) trasforma del testo in datetime! facecolor e’ il colore dello sfondo di un’immagine Metodi di FIGURE: fig.tight_layout() oppure, plt.tight_layout() serve per evitare sovrapposizioni per esempio i numeri degli assi trasbordino fig_3.savefig(&#39;ultimoPlot.png&#39;) salvare a file una figura! Metodi degli Assi plt.xticks(np.linspace(0,5,5), (&#39;Tom&#39;, &#39;Dick&#39;, &#39;Harry&#39;, &#39;Sally&#39;, &#39;Sue&#39;)) tics (o ticks) sull’asse x. Per non avere ticks: plt.xticks([]) (non ho messo nulla nella lista = non ci sono ticks) axes_3.set_xlim([0,3]) definisce i limiti sull’asse x (set xlim[1:100]) axes_4.set_xlabel(&#39;temp&#39;) label degli assi axes_3.grid(False, color=&#39;r&#39;, dashes=(0,2,1,2)) mette una griglia sullo sfondo, occhio che color e’ il colore della griglia non dello sfondo. plt.grid(False) e plt.grid(b=None) tolgono la griglia axes_3.set_facecolor(&#39;w&#39;) colore dello sfondo (bianco in questo caso) axes_4.set_title(&#39;da Pandas: IceCream&#39;) titolo axes_1.legend(loc =0 ) # Loc=0 e’ la migliore location scelta da lui` Tipi di disegno (possono essere chiamati come metodi degli assi o funzioni plt): axes_4.plot(x_2, y_2) disegno standard in cui ci sono i punti e posso unirli, cambiarli ecc. plt.bar(x_2, y_2, width=1.5); barchart (come istogramma ma sulle x possono essere categorici) plt.stem(x_2, y_2, &#39;-.&#39;) impulsi, interessante si puo’ indicare il tipo di linea plt.hist(arr3ok, bins= 7, density=True, stacked =False); istogrammi (raggruppa i valori sull’asse delle x in bins) plt.pie() piechart TORTE (gurada sotto perche’ servono un po’ di dettagli) axes_13.scatter(dr_arr, test_arr, s=cc_arr_sm, c=color_arr, alpha=0.2 ) scatterplot valori sull’asse delle x, y, dimensione punti, colori dei punti, trasparenza) axes_9.scatter3D(x_3,y_3,z_3, c=z_3, cmap=&#39;Blues&#39;); scatterplot 3D axes_9.contour3D(x_4,y_4,z_4, 20, cmap=&#39;Blues&#39;); 3D contorno, curve di livello, isoipse axes_9.plot_wireframe(x_4,y_4,z_4, cmap=&#39;Blues&#39;); wireframe e’ il grafico 3D standard di gnuplot, collega tutti i punti axes_9.plot_surface(x_4,y_4,z_4, rstride=1, cstride=1, cmap=&#39;Blues&#39;, edgecolor=&#39;r&#39;); 3D, collega i punti e colora le tegole Consiglio: in un Jupyter notebook usa shift-tab su una funzione per vederne la sua descrizione (prima devi cliccare sulla cella e poi avere il cursore sulla funzione stessa). Consiglio questo articolo contiene trucchi su jupyter notebook e alternative a Matplotlib. import numpy as np import pandas as pd import matplotlib.pyplot as plt %matplotlib inline #%matplotlib notebook %reload_ext autoreload %autoreload 2 Functional Plot Cominciamo con un’immagine semplice in cui c’e’ il titolo: plt.title(&#39;ciao&#39;) ci sono i nomi degli asssi: plt.xlabel(&#39;Days&#39;) c’e’ un grafico: plt.plot(x_1, y_1) Quando faccio un disegno, voglio che tutte le coordinate x siano in un contenitore (lo stesso vale per le coordinate y). Questi “contenitori” devono contenere lo stesso numero di oggetti, altrimenti per un punto avrei solo la coordinata x o solo la y… quindi mi manca il punto! x_1 = np.linspace(0,5,10) # genera un Numpy array con 10 float equispaziati tra 0 e 5 y_1 = x_1 **2 # genera un Numpy array che e&#39; il quadrato del primo plt.plot(x_1, y_1); plt.title(&#39;ciao&#39;); plt.xlabel(&#39;Days&#39;); plt.ylabel(&#39;Days squared&#39;); #plt.show() # se non siamo in jupyter notebook Domanda: posso passare delle liste ad un plt.plot()? Risposta: si’ certo! posso anche graficare delle liste che contengano delle stringhe. Se il contenitore di stringhe e’ una lista, allora esiste un ordine per le stringhe e questo ordine verra’ usato nella visualizzazione. Per un set invece non esiste un ordine e si ha un errore TypeError: unhashable type: ‘set’ l1= [1,2,3,4] l2= [3,4,5,6] l3= [&#39;a&#39;,&#39;b&#39;,&#39;e&#39;,&#39;d&#39;] d1 = {&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;} plt.plot(l1,l3); #plt.plot(l1,d1) # non funge! plt.subplot() molti grafici in modo veloce Qui vediamo come mettere piu’ di un grafico vicino all’altro. Nel dettaglio usando subplot potremo costuire una griglia, in ogni casella della griglia verra’ messo un grafico. Il comando plt.subplot(1,2,1) fa questo tipo di lavoro. il primo argomento e’ il numero di righe della griglia (in questo caso c’e’ solo una riga) il secondo argomento e’ il numero di colonne della griglia . il terzo argomento e’ l’indice del grafico. L’indice ci dice in quale casella della griglia stiamo mettendo il subplot. L’ordine seguito e’ lo stesso che si ha quando si legge: da SINISTRA a DESTRA da SOPRA a SOTTO. Vediamo un esempio: # nota che se anche il terzo argomento e&#39; 2 il grafico appare al primo posto, perche&#39; # non ce ne sono 2! E&#39; un po&#39; come se cadesse a sinistra se ci sono dei buchi? plt.subplot(1,2,2) # questo ci dice che abbiamo una riga e 2 colonne plt.plot(x_1,y_1, &#39;r&#39;); # r = red plt.subplot(1,2,1) # questo ci dice che abbiamo una riga e 2 colonne plt.plot(x_1,y_1, &#39;r&#39;) # r = red plt.subplot(1,2,2) # se metto 1 mi sovrappone con il primo ma mi dice che c&#39;e&#39; qualcosa di strano plt.plot(x_1,y_1, &#39;b&#39;) [&lt;matplotlib.lines.Line2D at 0x2de659e5c40&gt;] plt.subplot(2,2,1) # plt.plot(x_1,y_1, &#39;r&#39;) # plt.subplot(2,2,2) # plt.plot(x_1, y_1-y_1**2, &#39;b&#39;) plt.subplot(2,2,4) plt.plot(x_1, -y_1, &#39;g&#39;); plt.tight_layout() # evita sovrapposizione dei numeri dei grafici! Figure e axes Una figure e’ un oggetto su cui poi si mette il grafico (lo vedo come la tela bianca su cui fare il disegno) contiene tutti i ‘plot elements’ puo’ contenere molti axes (assi), che in pratica sono gli assi che definiscono il disegno vero e proprio, in quanto i punti sono riferiti agli assi. posso definire la sua larghezza e lunghezza in inch (inch=2.54 cm), probabilmente posso cambiare scala: figsize=(5,4) posso anche definire la risoluzione in dpi ATTENTO se definisci il numero di dpi, quando lo visualizzi come un png, questo definisce la dimensione della figura a video! quindi sembra che figsize non funzioni! fig_1 = plt.figure(figsize=(5,4), dpi =100); &lt;Figure size 500x400 with 0 Axes&gt; Axes L’oggetto axes (come indica il nome) identifica la posizione, la forma, e tutte le caratteristiche degli ASSI di un grafico. Se non facciamo esplicitamente un grafico, ci saranno solo le due fracce perpendicolari (gli assi) con dentro nulla. Possiamo i plot (grafici) sono dei metodi degli assi! La logica e’ quindi che siano un oggetto in funzione di dove sono gli assi (e ha senso, quando uno fa un grafico su un foglio, prima disegna gli assi, e poi puo’ definire la posizione dei punti che compongono il grafico. In questo senso quindi il plot e’ stato definito come un metodo di un axes. Nota che posso mettere piu’ di un axes su una singola figure. Anche questo e’ intuitivo, posso mettere 2 grafici sullo stesso foglio, poi i punti di un grafico saranno riferiti ad un paio di assi e quelli del secondo ad un altro paio di assi. Gli assi definiscono il sistema di riferimento “inerziale” che determina la posizione dei punti! Gli assi vengono costruiti su una figure tramite questo metodo: axes_1 = fig_1.add_axes([0.1,0.1,0.9,0.9]) Significa che axes_1 sara’ un rettangolo il cui: punto in basso a sx ha coordinate 0.1, 0.1 (rispetto a fig_1). Ovvero, la figure e’ un rettangolo, anche gli axes sono un rettangolo, il cui punto in basso a sinistra si trova nelle coordinate che sono il 10% delle x e il 10% delle y del punto in basso a sx della figure. punto in alto a dx ha coordinate 0.9,0.9 (rispetto a fig_1) In questo modo ho un grafico che e’ piu’ piccolo del “canvas” definito da fig_1. (nel video) non e’ chiaro come ha fatto l’esponente 2 sulla x. Io devo usare i comandi Latex Attenzione, io avevo messo il comando fig_1 = plt.figure(figsize=(5,4), dpi =100) in una cella diversa da dove facevo il axes.plot. Per questo non vedevo nulla!! Bisogna creare la figura nella stessa cella di Jupyter! Quindi ricapitolando: creo un oggetto figura ( me lo immagino come un foglio bianco di una certa dimensione) creo un oggetto axes che e’ ottenuto da un metodo della figura ( e’ il grafico vero e proprio, definito dagli assi sopra, sotto e destra e sinistra. Al suo interno posso poi mettere dei disegni tramite il metodo plot) tramite metodi di axes aggiungo delle caratteristiche come le label tra i metodi di un axes c’e’ plot (e altri tipi di grafico che potrei fare direttamente con plt). Chiamando un metodo che disegna da un axes, il grafico viene messo su questo axes. posso aggiungere piu’ di un grafico sullo stesso axes, basta chiamare piu’ volte un metodo che disegna sull’axes. nota che si deve fare un axes.plot per ognuno dei disegni che voglio compaiano nella figura! fig_1 = plt.figure(figsize=(5,4), dpi =100) # istanzio una FIGURA chiamata &#39;fig_1&#39; axes_1 = fig_1.add_axes([0.1,0.1,0.9,0.9]) # istanzio un AXES (axes_1), della figura &#39;fig_1&#39; axes_1.set_xlabel(&#39;Days new&#39;) # LABEL degli assi axes_1.set_ylabel(&#39;Days squared new&#39;) # LABEL degli assi axes_1.set_title(&#39;Ciao new&#39;) # TITOLO degli assi axes_1.plot(x_1, y_1, label = &#39;x/x$^2$&#39;) # GRAFICO 1 (all&#39;interno di axes_1) axes_1.plot(y_1, x_1, label = &#39;x^2/x&#39;) # GRAFICO 2 (all&#39;interno di axes_1) axes_1.legend(loc =0 ) # Loc=0 e&#39; la migliore location scelta da lui # 1=alt dx; 2=alto sx; 3=basso sx, 4 basso dx # oppure si fornisce una tupla di x e y dall&#39;angolo in basso a sinistra tu = (0.3, 0.4) # (tupla) questi valori sono in frazione rispetto alla grandezza totale, vedi sotto axes_1.legend(loc=tu ); # posizione della legenda Molte curve: versione veloce se devo fare un grafico veloce, basta che passo le x e y di tutti i grafici in ordine al plot, in questo modo verranno visualizzati tutti! Se non metto color=&#39;black&#39; di default le due curve avranno colori diversi plt.plot(x_1, y_1, x_1, y_1/3); # disegna le 2 funzioni Axes innestati Voglio ora inserire piu’ di un axes nella stessa figura. In pratica aggiungo un axes all’esempio precedente. Per fare questo devo creare un altro axes, proprio perche’ in questo caso i dati si riferiscono ad assi diverse che devono essere definite. Ricapitolando: nell’esempio sopra ci sono una curva blu e una arancione, sono comunque riferite allo stesso axes. Questi axes vanno da 0 a 25 (circa). se voglio inserire una figura nuova, i punti di questa figura saranno riferiti a un nuovo sistema di assi, ho quindi bisogno di inserire questi nuovi assi, creando un nuovo oggetto axes (con un nome diverso) dovro’ quindi indicare dove si collocano questi nuovi assi rspetto alla figure dovro’ anche indicare la loro grandezza, anche in questo caso rispetto alla figure Testo nella figura per inserire un testo nel disegno si usa il metodo text di axes. Le coordinate sono riferite all’axes e partono dal basso a sinistra. Nota che nel disegno sotto ho 2 axes, e il messaggio e’ riferito ad axes_2. Questo e’ ovvio perche’ e’ chiamato come un metodo di questo axes Nota inoltre che axes_2.text(0,40,&#39;message&#39;) fa uscire dal disegno, in quanto per il disegno l’asse delle y arriva solo fino a circa 25! nell’esempio di qui sotto: il primo axis contiene due curve il secondo axis contiene una curva fig_1 = plt.figure(figsize=(5,4), dpi =100) # FIGURA 1 assi_1 = fig_1.add_axes([0.1,0.1,0.9,0.9]) # ASSI_1 assi_1.set_xlabel(&#39;Days new&#39;) assi_1.set_ylabel(&#39;Days squared new&#39;) assi_1.set_title(&#39;Ciao new&#39;) assi_1.plot(x_1, y_1, label = &#39;x/x$^2$&#39;) # GRAFICO 1 (degli &quot;ASSI_1&quot;) assi_1.plot(y_1, x_1, label = &#39;x^2/x&#39;) # GRAFICO 2 (degli &quot;ASSI_1&quot;) assi_1.legend(loc =0 ) # Loc=0 e&#39; la migliore location scelta da lui ######## costruisco i secondi assi ##################### assi_2 = fig_1.add_axes([0.45, 0.45,0.4,0.3]) # ASSE 2 assi_2.set_xlabel(&#39;Days new&#39;) assi_2.set_ylabel(&#39;Days squared new&#39;) assi_2.set_title(&#39;Ciao dentro&#39;) assi_2.plot(x_1, y_1, &#39;r&#39;) # GRAFICO 2 # GRAFICO 1 (degli &quot;ASSI_2&quot;) #assi_2.text(0,40, &#39;Message&#39;) # testo assi_2.text(0,40, &#39;Message&#39;) # testo Text(0, 40, &#39;Message&#39;) subplots() Una griglia di grafici OCCHIO: plt.subplots()$\neq$plt.subplot() (il primo termina in s) Il singolo comando subplots in pratica costruisce 2 oggetti: una figure una array di assi (ma un array di numpy puo’ contenere degli oggetti strani? non erano solo numeri? no! basta che in tutti gli oggetti siano dello stesso tipo: omogeneita’ degli array). devo quindi descrivere/inizializzare ognuno dei possibili axes dell’array, altrimenti ho solo gli assi senza nessun disegno dentro. In pratica e’ una specie di scorciatoia per ordinare facilmente degli axis in una figure in modo che siano esattamente alle posizioni della griglia che viene definita con il comando, per esempio indicando il numero di colonne e di righe. Altrimenti avrei potuto istanziare una figura, e istanziare tanti axes stando attento a metterli nel posto giusto all’interno della figura. Attenzione se voglio mettere degli axes aggiuntivi (oltre all’array di axes iniziale), posso farlo, occhio pero’ che si riferiranno tutti alla figure per quanto riguarda la posizione e non avranno un particolare ordinamento o forma. Dovro’ essere io a stare attento a metterli nel posto corretto e con la forma corretta! il comando plt.tight_layout() aiuta a non fare sovrapporre le label. Attento che devi usare il nome della figura corretto fig_2 Attento: non usare un nome gia’ usato per un altro axes, come axes_2 Attento: la dimensione del subplot e’ riferita al figsize, non all’axes di cui e’ subplot. Per questo trasborda! Attento: se costruisci un nuovo axes viene messo sopra l’axis genitore, e per questo lo (puo’) coprire. Di default un axes non e’ trasparente! fig_2 , axes_2 = plt.subplots(figsize=(8,4), nrows=1, ncols= 3) plt.tight_layout() # evita la sovrapposizione delle label axes_2[1].set_title(&#39;Plot 2&#39;) axes_2[1].set_xlabel(&#39;x&#39;) axes_2[1].set_ylabel(&#39;x quadro&#39;) axes_2[1].plot(x_1, y_1) # Nuovo AXES che non fa parte dell&#39;array creato con subplots axes_3 = fig_2.add_axes([0.45, 0.45,0.4,0.4]) axes_3.set_xlabel(&#39;Days new&#39;) axes_3.set_ylabel(&#39;Days squared new&#39;) axes_3.set_title(&#39;Ciao straripante&#39;) axes_3.plot(x_1, y_1, &#39;r&#39;) # GRAFICO 2 axes = fig_2.add_axes ([0.085,0.15,0.2,0.7]) axes.plot(x_1,y_1, &#39;co&#39;) axes.set_title(&#39;Dentro&#39;) Text(0.5, 1.0, &#39;Dentro&#39;) f , a = plt.subplots(figsize=(8,4), nrows=1, ncols= 3) plt.tight_layout() ############ Axes Centrale ############### a[1].set_title(&#39;Centrale&#39;) a[1].set_xlabel(&#39;x&#39;) a[1].set_ylabel(&#39;x quadro&#39;) a[1].plot(x_1, y_1) ############ Axes Ciao Dentro ############ a1 = f.add_axes([0.45, 0.45,0.4,0.4]) a1.set_xlabel(&#39;Days now&#39;) a1.set_ylabel(&#39;Days squared new&#39;) a1.set_title(&#39;Tra centro e sinistra&#39;) a1.plot(x_1, y_1, &#39;r&#39;) # GRAFICO 2 della figura centrale ############ Axes Sinistro ############### a[0].set_title(&#39;Sinistra&#39;) a[0].set_xlabel(&#39;x&#39;) a[0].set_ylabel(&#39;x quadro&#39;) a[0].plot(x_1, -y_1,&#39;g&#39;) ############ Axes Piccolo sinistra ###### a0 = f.add_axes([0.1, 0.25,0.2,0.2]) a0.set_xlabel(&#39;Days old&#39;) a0.set_ylabel(&#39;Days squared new&#39;) a0.set_title(&#39;Piccolo Sinistra&#39;) a0.plot(x_1, y_1, &#39;r&#39;) # GRAFICO 2 della figura centrale [&lt;matplotlib.lines.Line2D at 0x2de66e3a190&gt;] Colori e Apparenza I colori di default sono: r = red c = cyan m = magenta y = yellow k = black w = white Inoltre color=”0.75” crea un 75% gray (e’ una percentuale di black) si possono usare i colori con hexcodes color=”#eeefff” si possono usare i colori tipo color=”burlywood” che si trovano a https://en.wikipedia.org/wiki/Web_colors lw come gnuplot, ma devo mettere l’uguale, p.es. lw=2 ls ‘-.’ si trovano qui: https://matplotlib.org/3.1.0/gallery/lines_bars_and_markers/linestyles.html marker sono i punti: https://matplotlib.org/3.3.3/api/markers_api.html markersize = grandezza del punto markerfacecolor = colore di riempimento del punto makeredgecolor = colore del bordo del punto fig_3 = plt.figure(figsize=(6,4)) axes_3 = fig_3.add_axes([0,0,1,1]) axes_3.plot(x_1, y_1, color=&#39;navy&#39;, alpha=0.75, lw=2, ls =&#39;-.&#39;, marker = &#39;o&#39;, markersize=7, markerfacecolor =&#39;y&#39;, markeredgecolor=&#39;k&#39;, markeredgewidth=2) [&lt;matplotlib.lines.Line2D at 0x2de66eaa970&gt;] Grandezza degli assi e background I comandi per gestire gli assi assomigliano a quelli di gnuplot, ma solo un po’ piu’ “verbose”, in cui si deve scrivere di piu’. Possimo anche mettere una griglia e il background color. axes_3.set_xlim([0,3]) limiti asse x axes_3.grid(True, color=&#39;0.6&#39;, dashes=(5,2,1,2)) caratteristiche della griglia (NON dello sfondo!), dashes mette delle linee tratteggiate attraverso il disegno. Quindi qui sono le righe che partono da un tic e arrivano dall’altra parte del disegno axes_3.set_facecolor(&#39;#FAEBD7&#39;) colore di sfondo fig_3 = plt.figure(figsize=(3,4) ) axes_3 = fig_3.add_axes([0,0,1,1]) axes_3.plot(x_1, y_1, color=&#39;navy&#39;, alpha=0.75, lw=2, ls =&#39;-.&#39;, marker = &#39;o&#39;, markersize=7, markerfacecolor =&#39;y&#39;, markeredgecolor=&#39;k&#39;, markeredgewidth=2) axes_3.set_xlim([0,3]) axes_3.set_ylim([0,25]) #axes_3.grid(True, color=&#39;0.6&#39;, dashes=(5,2,1,2)) # mettiamo una griglia non lasciamo vuoto axes_3.grid(False, color=&#39;r&#39;, dashes=(0,2,1,2)) #axes_3.set_facecolor(&#39;#FAEBD7&#39;) axes_3.set_facecolor(&#39;w&#39;) Salvare una figura a file strano quando lavoravo con Seaborn sembrave che il save dovesse avvenire nella stessa cella dove si faceva il disegno. Basta mettere il nome dell’estensione e lui salva correttamente nel formato corrispondente fig_3.savefig(&#39;ultimoPlot.png&#39;) Pandas Qui usiamo l’ICE CREAM data table (che diventera’ un DataFrame). Ho copiato il dataframe del video. Assegno dei nomi alle colonne del csv, mentre leggo il file: ics_df = pd.read_csv(&#39;icecream.csv&#39;, names=[&#39;temps&#39;, &#39;sales&#39;]) . Nota che io ho usato i nomi sales e temps (temperatures). Lui li aveva con la prima lettera in maiuscolo. Temp e’ in Farenheit, e sales e’ in unita’ di gelato. Se non usassi il parametro names=... lui prenderebbe la prima riga e la trasformerebbe nei nomi delle colonne (e i valori della prima riga non sarebbero accessibili)! Osservazione: il metodo dei DataFrame sort_values(by=&#39;temps&#39;) lavora inplace, quindi modifica il df! ics_df = pd.read_csv(&#39;icecream.csv&#39;, names=[&#39;temps&#39;, &#39;sales&#39;]) ics_df.head() temps sales 0 37 292 1 40 228 2 49 324 3 61 376 4 72 440 Attento sort_values() lavora inplace ics_df = ics_df.sort_values(by=&#39;temps&#39;) # LAVORA INPLACE A questo punto lui fa delle cose che sembrano non necessarie. Prende e converte il DataFrame in un array di Numpy. Poi prende e scrive le x e le y da questo array di numpy. In effetti ho notato in una sezione sotto che alle volte e’ davvero meglio avere dei numpy array invece che i dataframe, in particolare per evitare dei valori strani sull’asse delle x. # con numpy array ############### # np_arr = ics_df.values # prende solo i valori, rimuove le etichette # x_2 = np_arr[:,0] # seleziono colonna 0 # y_2 = np_arr[:,1] # seleziono colonna 1 ################################### # Alternativa: x_2 = ics_df.temps # non sono array di np, ma serie di Pandas vanno bene lo stesso y_2 = ics_df.sales # ricorda puoi usare l nome di una colonna per selezionare tutta le colonna come se fosse un attributo #x_2 = np.array(ics_df.temps) # NON serve... ora, ma in alcuni casi si&#39; #y_2 = np.array(ics_df.sales) # NON serve... ora, ma in alcuni casi si&#39; ok ma fino a qui, dove ha usto il fatto che sia Pandas? fig_4 = plt.figure(figsize=(6,4)) axes_4 = fig_4.add_axes([0,0,1,1]) # prendo tutto lo spazio, dall&#39;angolo in basso a sx a quello in alto a dx axes_4.set_title(&#39;da Pandas: IceCream&#39;) axes_4.set_xlabel(&#39;temp&#39;) axes_4.set_ylabel(&#39;sales&#39;) axes_4.plot(x_2, y_2, marker=&#39;+&#39;); # ho messo sui punti le crocette come in Gnuplot Annotare la figura Se voglio mettere delle annotazioni nel grafico, come per esempio delle frecce, devo usare un metodo degli axes chiamato annotate. Vediamo nel dettaglio il comando: axes_4.annotate(&#39;Good Month&#39;, xy=(83, 536), xytext=(60,520), arrowprops= dict(facecolor=&#39;black&#39;, shrink=0.0, width=0.5)) &#39;Good Month&#39; e’ il testo che viene inserito xy=(83,536) e’ il punto di arrivo della freccia xytext=(60,520) e’ il punto di partenza del testo orizzontale All’interno di arrowprops si hanno vari parametri (si deve passare un dizionario con tutti gli argomenti) facecolor= ‘black’ shrink=0.5 indica quanto piu’ corta deve essere la freccia, rispetto alla lunghezza massima che va dalla fine del testo al punto di arrivo della freccia. width=0.5 possiamo anche allargare la larghezza fig_4 = plt.figure(figsize=(6,4)) axes_4 = fig_4.add_axes([0,0,1,1]) # prendo tutto lo spazio, dall&#39;angolo in basso a sx a quello in alto a dx axes_4.set_title(&#39;da Pandas: IceCream&#39;) axes_4.set_xlabel(&#39;temp&#39;) axes_4.set_ylabel(&#39;sales&#39;) axes_4.plot(x_2, y_2) axes_4.annotate(&#39;Good Month&#39;, xy=(83, 536), xytext=(60,520), arrowprops= dict(facecolor=&#39;black&#39;, shrink=0.0, width=0.5)) Text(60, 520, &#39;Good Month&#39;) bar() Barchart sotto il grafico bar() e’ un metodo di plt Se voglio fare aggiungere anche le barchart sotto il grafico, basta disegnare ANCHE loro! Attento ho fatto 2 plot: il primo e’ dato da axes_4.plot(x_2, y_2) ed e’ passato come un metodo degli assi il secondo e’ un grafico veloce ed e’ una funzione di matplotlib: plt.bar(x_2, y_2, width=1.5); fig_4 = plt.figure(figsize=(6,4)) axes_4 = fig_4.add_axes([0,0,1,1]) # prendo tutto lo spazio, dall&#39;angolo in basso a sx a quello in alto a dx axes_4.set_title(&#39;da Pandas: IceCream&#39;) axes_4.set_xlabel(&#39;temp&#39;) axes_4.set_ylabel(&#39;sales&#39;) axes_4.plot(x_2, y_2) axes_4.annotate(&#39;Good Month&#39;, xy=(83, 536), xytext=(60,520), arrowprops= dict(facecolor=&#39;black&#39;, shrink=0.0, width=0.5)) plt.bar(x_2, y_2, width=1.5); Impulsi stem() e proprieta’ setp() In gnuplot mettevo with impulses quando volevo che il grafico avesse delle linee verticali che partono dall’asse x e raggiungono ogni punto. Il comando descritto qui sopra bar() non e’ l’ideale per ottenere questo risultato in quanto la larghezza dell’impulso puo’ creare problemi, meglio usare la funzione: plt.stem() mentre posso decidere di colorare l’asse sotto tramite la funzione set property: plt.setp() Questa funzione puo’ essere usata per vari oggetti! fig_4 = plt.figure(figsize=(6,4)) axes_4 = fig_4.add_axes([0,0,1,1]) # prendo tutto lo spazio, dall&#39;angolo in basso a sx a quello in alto a dx axes_4.set_title(&#39;da Pandas: IceCream&#39;) axes_4.set_xlabel(&#39;temp&#39;) axes_4.set_ylabel(&#39;sales&#39;) axes_4.plot(x_2, y_2) axes_4.annotate(&#39;Good Month&#39;, xy=(83, 536), xytext=(60,520), arrowprops= dict(facecolor=&#39;black&#39;, shrink=0.0, width=0.5)) markerline, stemlines, baseline = plt.stem(x_2, y_2, &#39;-.&#39;) plt.setp(baseline, &#39;color&#39;, &#39;r&#39;, &#39;linewidth&#39;, 2) [None, None] TeX - regular expressions possiamo usare Latex per scriver formule matematiche usando per esempio $\frac{1}{2}$ IMPORTANTE nota che nel tutorial ha usato: r&#39;$\alpha \beta \gamma$&#39; non ha semplicemente messo ‘’ perche’ cosi’ prende le regular expression, come il dollaro e lo slash. Ovvero la scrittura r’ciao $\frac{2}{3}’ crea una stringa che pero’ ha delle regular expression che vengono valutate ed eseguite. basta poi ricordare i comandi di Latex il metodo .text degli ‘axes’ mette ha all’inizio le coordinate (separate da una virgola), poi una virgola con il testo da inserire. fig_5 = plt.figure(figsize=(5,4), dpi=100) axes_5 = fig_5.add_axes([0.1, 0.1, 0.9, 0.9]) # costruisco un axes axes_5.text(0,23, r&#39;$\alpha~ \beta~ \gamma ~ \frac{1}{2} ~\Sigma$&#39;) # prima le coordinate del testo, poi il testo axes_5.plot(x_1, y_1) [&lt;matplotlib.lines.Line2D at 0x2de66ff15e0&gt;] Istogrammi plt.hist() Alcuni argomenti utili per gli istogrammi: stacked=True Simuliamo probabilita’ di lancio di 2 dadi. Ci sono 11 possibili valori per la somma: 1+1 =2 I 1+2 =3 II 1+3 =4 III 1+4 =5 IV 1+5 =6 V 1+6 =7 VI 2+6 =8 VII (nota che tutti gli altri valori di (2+qualcosa) danno dei risultati gia’ ottenuti) 3+6 =9 VIII 4+6 =10 IX 5+6 =11 X 6+6 =12 XI Come altri parametri: density=True mostra la frequenza di ogni bin (se e’ falso mostra il conteggio) stacked=True cosa fa? Attento: ricorda che il numero di bins puo’ portare a risultati MOLTO fuorvianti. Per esempio se scegliamo bins=7 otteniamo un oggetto bicefalo attorno al centro. Se invece scegliamo bins=11 otteniamo una campana! arr_1 = np.random.randint(1,7,5000) # genera 5000 numeri interi tra 1 e 6 arr_2 = np.random.randint(1,7,5000) # genera 5000 numeri interi tra 1 e 6 arr_3 =arr_1+arr_2 arr3ok = arr_3 plt.hist(arr3ok, bins= 7, density=True, stacked =False); plt.hist(arr_3, bins= 11, density=True, stacked =True); ax[0].hist() Axes e istogrammi Qui sotto provo a combinare axes e istogrammi. Ho supposto di poter usare il metodo hist() direttamente su un asse invece che dover usare un plt.hist, ovvero: axes.hist(...) Funge! fig , ax = plt.subplots(figsize=(8,4), nrows=1, ncols= 2) #plt.tight_layout() ax[0].hist( arr_3, bins= 11, density=True, stacked =True); ax[1].hist( arr_3, bins= 11, density=False, stacked =False); altri argomenti che si possono passare: Range deve essere una tupla con il range di cui si e’ interessati cumulative =True costruisce la CDF (cumulative distribution function) dati i valori. Attento non me lo prendeva (diceva qualcosa riguardo l’oggetto kernel). Non ho lanciato tutte le altre celle, ma solo quelle iniziali con gli header e quelle della cella Istogramma histtype= &#39;step&#39; genera un grafo con le linee (ma vuoto) color = &#39;orange&#39; colora di arancione… orientation = &#39;horizontal&#39; gira di 90 gradi l’istogramma posso combinare anche due istogrammi insieme come con gli altri plot. plt.hist(arr_3, bins= 11, density=True, stacked =True, cumulative=True, histtype=&#39;step&#39;, color=&#39;blue&#39;, orientation= &#39;horizontal&#39;); Bar charts Che differenza c’e’ tra un grafo a barre e un istogramma? de facto nell’istogramma si mettono le frazioni e le “barre” sono attaccate l’una all’altra. In un bar chart invece si hanno i numeri e le barre non sono attaccate l’una all’altra, questo perche’ sull’asse delle x spesso non si hanno dei valori numerici, ma categorici (come nell’esempio riportato sotto, dove l’ordine delle colonne e’ sostanzialmente arbitrario). Per un grafo a barre, si chiama la funzione seguente: plt.bar(spc, m_eng,width=larghezza, label=&#39;maschi&#39;, edgecolor =&#39;k&#39;) il primo argomento contiene la lista/tupla con i nomi che appaiono sull’asse delle x (dato che spesso lo usiamo per variabili categoriche dobbiamo indicare le label), oppure le posizioni delle barre (se ho le posizioni dovro’ poi aggiungere le label sull’asse) Attento se nella prima tupla ci sono dei nomi, allora le loro posizioni sono equispaziate automaticamente. Se io aggiungo un altro bar chart, questo secondo viene messo dopo quelle gia’ esistenti. Attento se invece nella prima tupla ci sono dei float (che quindi definisce la posizione delle barre), allora facendo un secondo plot, quest’ultimo segue le proprie posizioni. Attento pui mettere 2 bar chart, uno con variabili categoriche e uno con float. Le posizioni delle categoriche sono messe automaticamente in integer (che partono quindi da zero). Nell’esempio qui sotto, la barra di nuclear ha posizione sull’asse delle x uguale a 0, hydro e’ in posizione 1, … il secondo argomento contiene l’array che con le altezze della barchart yerr ??? serve per la barra che indica l’errore, ed e’ un array che deve contenere tanti oggetti quante sono le barre width larghezza della barra (altrimenti da’ errore? ) label non la vedo… scritta forse bisogna attivarla. Anche nel video non fungeva ## energia francese x = [&#39;nuclear&#39;, &#39;hydro&#39;, &#39;coal&#39;, &#39;gas&#39;, &#39;solar&#39;, &#39;wind&#39;, &#39;other&#39;] per_1 = [71,10,3,7,2,4,3] # percentuale variance = [8,3,1,3,1,2,1] # varianza per anno plt.bar(x, per_1, color=&#39;purple&#39;,yerr=variance, label=&#39;prova&#39;) &lt;BarContainer object of 7 artists&gt; ## energia francese x = [&#39;nuclear&#39;, &#39;hydro&#39;, &#39;coal&#39;, &#39;gas&#39;, &#39;solar&#39;, &#39;wind&#39;, &#39;other&#39;] per_1 = [71,10,3,7,2,4,3] # percentuale variance = [8,3,1,3,1,2,1] # varianza per anno plt.bar(x, per_1, color=&#39;purple&#39;,yerr=variance, label=&#39;prova&#39;) y = [el + &#39; &#39; for el in x] z = [&#39;test1&#39;, &#39;test2&#39;, &#39;test3&#39;] z2 = [1, 2, 10] per_2 = [34,43,21] plt.bar(z2, per_2, color=&#39;red&#39;, label=&#39;prova&#39;) &lt;BarContainer object of 3 artists&gt; y [&#39;nuclear &#39;, &#39;hydro &#39;, &#39;coal &#39;, &#39;gas &#39;, &#39;solar &#39;, &#39;wind &#39;, &#39;other &#39;] Bar Chart affiancate Qui sotto mettiamo due bar chart affiancate una da parte all’altra. In questo modo possiamo confrontare dati diversi. E’ fondamentale che la posizione dell’array che definisce l’asse delle x della seconda bar chart sia spostato rispetto all’asse delle x della prima bar chart di una quantita’ tale da non fare sovrapporre (a meno di volerlo). Per esempio di puo’ usare lo stesso array maggiorato della larghezza della barchart! m_eng = (76,85,86,88,93) # percentuale maschi ingegneri f_eng = (24,15,14,12,7) # femmine spc = np.arange(5) larghezza =0.45 plt.bar(spc , m_eng,width=larghezza, label=&#39;maschi&#39;, edgecolor =&#39;k&#39;) plt.bar(spc+larghezza, f_eng,width=larghezza, label=&#39;femmine&#39;, edgecolor =&#39;k&#39;) #plt.xticks(spc + larghezza/2, (&#39;Aero&#39;, &#39;Chem&#39;, &#39;Civil&#39;, &#39;Elect&#39;, &#39;Mec&#39;)) plt.xticks(spc , (&#39;Aero&#39;, &#39;Chem&#39;, &#39;Civil&#39;, &#39;Elect&#39;, &#39;Mec&#39;)) ; # altrimenti lo mette a meta&#39; strada del primo istogramma Bar Chart impilate (stacked) Qui mettiamo le barre una sopra l’altra. Diamo un’occhiata alla list comprehension che viene usata: ind = [x for x, _ in enumerate(t_type)] enumerate restituisce delle coppie: posizione, oggetto. Non ci serve l’oggetto ma solo la posizione, qunidi non spreco una variabile y, metto _ Prendi tutte le posizioni che ci sono nell’oggetto t_type questa volta la label e’ apparsa nella legenda. ATTENTO il parametro bottom dice cosa c’e’ sotto di questa barchart. In particolare possiamo indicare un array, o anche una somma di array come nell’esempio di cui sotto. Se mettiamo un array che viene disegnato nella barchart, allora stiamo in pratica impilando il nuovo barchart sopra quello dell’altro array ############# DATI ###################### t_type= [&#39;kind&#39;, &#39;elem&#39;, &#39;sec&#39;, &#39;special&#39;] print(type(t_type)) m_teach = np.array([2,20,44,14]) f_teach = np.array([98,80,56,86]) n_teach = np.array([12,14,13,15]) ind = [x for x,_ in enumerate(t_type)] # list comprehension. Vedi sopra per come si legge plt.bar(ind, n_teach, width=larghezza, label=&#39;nuovo&#39;, bottom=f_teach+m_teach) # posso metterne piu&#39; di uno sotto plt.bar(ind, m_teach, width=larghezza, label=&#39;maschi&#39;, bottom=f_teach) # posso metterne piu&#39; di uno sotto plt.bar(ind, f_teach, width=larghezza, label=&#39;femmine&#39;) plt.legend(loc=&#39;lower right&#39;); # non ideale.... #plt.legend(loc=0); # manco questo... &lt;class &#39;list&#39;&gt; Torte - Pie chart, plt.pie() Vediamo i diagrammi a torta. Per questi si usa il comando: wedges, texts, autotexts = plt.pie(poke_num, explode=explode, labels=types, colors=colors, autopct=&#39;%1.0f%%&#39;, shadow=True, startangle=140, textprops =dict(color=&#39;w&#39;)) Dal punto di vista sintattico la funzione pie() restituisce 3 oggetti: le wedges (gli spicchi o cunei del diagramma a torta). i texts gli autotext In questo caso abbiamo prima costruito la figure, poi gli axes ed infine abbiamo chiamato la funzione pie. E’ un po’ diverso dal solito quando si usava un metodo dell’axes. Nota che in un diagramma a torta, intuitivamente, i valori di larghezza (angolo) associati ad ogni fetta vengono convertiti in percentuali dell’angolo giro. Questo perche’ ci si aspetta che tutti i valori di un array riempiano tutto il cerchio. explode a questa keyword si deve passare un array di float con tanti ingressi quante sono le fette. Il valore di ogni ingresso dice di quanto viene “estratta” la fetta alla posizione corrispondente, vedi l’esempio sotto. nell’esempio sotto ci sono 2 array: types e pole_num, questi devono avere il medesimo numero di ingressi. labels=types e’ un parametro che indica le etichette associate ad ogni fetta autopct indica come vengono arrotondati i numeri associati alle larghezze, gli si deve passare come valore una stringa che indica un formato. shadow=true e’ il parametro che dice se mettiamo l’ombra colori ha usato un trucco notevole, ha fatto scrivere dei valori in formato RGB tramite il generatore di numeri casuali. Tre numeri indicano un colore, e lui indicando il range dei colori tra [0, 0.5] ha fatto si’ che vengono scuri. Ha scelto i colori scuri perche’ la scritta viene in bianco! Occhio, avevo fatto un errore di sintassi ma non semplice da osservare. Nell’array types che contiene dei nomi tra virgolette, in un caso, quando andavo a capo ho dimenticato di mettere una virgola tra un nome e l’altro e lui mi ha preso solo uno dei nomi bbox_to_anchor = (1,0,0.5,1) serve per spostare di 1 e 1/2 a destra della piechart (???) import random fig_6 = plt.figure(figsize=(8,5)) axes_6 = fig_6.add_axes([0.1,0.1,0.9,0.9]) #Vogliamo un diagramma a torte types = [&#39;water&#39;, &#39;normal&#39;, &#39;flying&#39;, &#39;grass&#39;, &#39;psychic&#39;,&#39;bug&#39;, &#39;fire&#39;, &#39;poison&#39;, &#39;ground&#39;,&#39;rock&#39;,&#39;fighting&#39;, &#39;dark&#39;, &#39;steel&#39;, &#39;electric&#39;,&#39;dragon&#39;,&#39;fairy&#39;,&#39;ghost&#39;,&#39;ice&#39;] poke_num =[133, 109, 101, 98, 85, 77, 68, 66, 65, 60, 57, 54, 53, 51, 50, 50, 46, 40] colors = [] for i in range(18): # per il testo bianco genero i coloi delle fette in modo che siano scuri rgb = (random.uniform(0,.5) , random.uniform(0,.5) , random.uniform(0,.5) ) colors.append(rgb) explode = [0] * 18 # ho creato una lista di 18 zeri (non mi ricordavo questo modo!) explode[0] = 0.2 # esplodi la prima fetta ma solo di 0.2 #print(len(types)); #print(len(poke_num)); wedges, texts, autotexts = plt.pie(poke_num, explode=explode, labels=types, colors=colors, autopct=&#39;%1.0f%%&#39;, shadow=True, startangle=140, textprops =dict(color=&#39;w&#39;)) plt.legend(wedges, types, loc=&#39;right&#39;, bbox_to_anchor = (1,0,0.5,1)); # sposto dalla piechart Serie Temporali Qui vediamo come fare un grafico con una serie temporale in cui i vari punti sono etichettati con un timestamp. Puo’ essere necessario togliere dei giorni particolari e risulta piu’ comodo sapere la data piuttosto che trovare il punto corrispondente della time series. Il database usato viene da Yahoo riguardo i dati di google, GOOG.csv. (non e’ esattamente come mostrato nel video ma si trova in fretta). Per trovarlo cerca con google “yahoo google stock”, seleziona le date e fai download (nota che la frequenza e’ giornaliera). All’inizio si carica il file con read_csv di Pandas, poi si trasforma la tabella in un array di numpy (sono tutti valori numerici). Lui usa un metodo dei DataFrame di Pandas che io non uso mai: tp_numpy(). Io invece faccio semplicemente np.array(). Ho provato a fare un giro piu’ semplice, cercando di plottare i dati direttamwente DAL DataFrame, di cui seleziono le colonne volute (ma avendo prima selezionato le righe, vedi sotto). Sfortunatamente sull’asse delle x vengono dei valori sballati come tics, il grafico e’ pero’ corretto. Questo e’ probabilmente il motivo per cui lui preferisce trasformare tutto in array di Numpy. Scrubbing data: per esempio vogliamo togliere alcune vacanze, ha controllato due date che sono vacanze e vuole escluderlo. Usa datetime. La funzione datetime.datetime(2020,5,25) crea una data in un oggetto specifico, che puo’ poi essere trasformato a seconda delle esigenze, p.es g/m/a o m/g/a ecc. Poi costruisce un array di date che vanno da una data iniziale ad una finale, tramite un metodo di pandas: pd.bdate_range, si puo’ passare il parametro frequency freq =&#39;C&#39; in questo caso, ma no so cosa sia il valore ‘C’! holidays e’ il nome di un altro parametro che appunto corrisponde alle vacanze e possiamo passare un array/tupla contentente dei dati in formato datetime che vengono riconosciuti. ATTENTO la mia versione non riconosce questo parametro. Ho riscritto tutto e ora funge. Problema: non so quando ha preso lui le date da Yahoo, io ho piu’ giorni. Problema2 se uso tutti questi giorni, i tics che vengono segnati sono troppi e sotto l’asse viene un guazzabuglio di linee. Devo modificare per ottenere le date corrette. import datetime goog_data = pd.read_csv(&#39;GOOG.csv&#39;) # IMPORTO il file GOOG.csv che ho salvato nella dir corrente goog_data_np = goog_data.to_numpy() # trasformo in np.array #goog_data_np =np.array(goog_data) # modo alternativo di trasformare goog_cp = goog_data_np[:,4] holidays = [datetime.datetime(2020,5,25) , datetime.datetime(2020,8,19) ] # creo una lista con due date che saranno vacanze date_arr = pd.bdate_range(start =&#39;5/20/2020&#39; , end =&#39;8/19/2020&#39; , freq =&#39;C&#39;, holidays = holidays) date_arr_np = date_arr.to_numpy() goog_data.head(3) Date Open High Low Close Adj Close Volume 0 2019-08-21 1193.150024 1199.000000 1187.430054 1191.250000 1191.250000 740700 1 2019-08-22 1194.069946 1198.011963 1178.579956 1189.530029 1189.530029 947500 2 2019-08-23 1181.989990 1194.079956 1147.750000 1151.290039 1151.290039 1687000 Selezionare righe secondo delle date Seguo questo esempio per selezionare le date: https://stackoverflow.com/questions/29370057/select-dataframe-rows-between-two-dates Creo una mask per selezionare le date che voglio e che devono seguire quelle indicate nel bdate_range. In pratica creo una maschera, ovvero un array di bool che poi posso passare a loc! In questo modo solo gli ingressi in cui la maschera e’ vera vengono selezionati. Problema I: devo paragonare delle date… in formati magari diversi Soluzione I uso pd.to_datetime() che e’ una goduriosa funzione di Pandas che converte una stringa in un oggetto di tipo datetime. Questo oggetto e’ una data ed e’ possibile paragonare due datetime per vedere chi viene prima o dopo! Questa funzione e’ particolarmente VANTAGGIOSA in quanto riconosce tanti tipi diversi di formato in cui possiamo scrivere una data e li converte i un unico oggetto! Alternativa usa parse_dates (vedi il Finance Module) Una volta ottenuto un modo per paragonare le date posso creare una lista con valori booleani in cui seleziono le date (basta un loop), chiamo questo oggetto maschera Problema II la maschera cosi’ creata non e’ un oggetto iterabile che si possa mettere nel metodo loc di pandas. Devo tasformarlo in un oggetto non iterabile Soluzione II basta costruire una funzione che prende come input qualcosa e quando lo sputa in output gli metto un tuple davanti! DUBBIO ehi ma nel codice non ho usato la tupla, anzi se dove faccio finanza metto la tupla mi da errore, sembra che una Series di pandas vada bene Attenzione pero’ la maschera cosi’ creata e’ un oggetto mutabile e questo non puo’ essere usato come ingresso della funzione loc (di PANDAS) perche’ questa necessita oggetti immutabili da cui puo’ estrarre una hashtable. link utili: loc: https://stackoverflow.com/questions/29370057/select-dataframe-rows-between-two-dates to_datetime: https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.to_datetime.html convertire lista in tupla: https://www.geeksforgeeks.org/python-convert-a-list-into-a-tuple/ # PROBLEMA I # qui sotto prendo la colonna Date del dataFrame # poi converto i valori ivi contenuti in un oggetto di tipo datetime con to_datetime # a questo punto li paragono ai valori entro cui voglio che siano le date, sempre # sfruttando la funzione di pandas pd.to_datetime mask = ( ( pd.to_datetime(goog_data[&#39;Date&#39;]) &gt;= pd.to_datetime(&#39;5/20/2020&#39;)) &amp; ( pd.to_datetime(goog_data[&#39;Date&#39;]) &lt;= pd.to_datetime(&#39;8/19/2020&#39;)) ) # PROBLEMA II # l&#39;oggetto mask non e&#39; di tipo immutabile e quindi non puo&#39; essere usato come iteratore # devo trasformarlo in unoggetto immutabile def convert(list): return tuple(list) mask_t= convert(mask) #print(type(mask_t) , &#39;tipo maschera&#39;) # controllo #print(len(goog_data.loc[mask])) # controllo che i due oggetti abbiano lo stesso numero di righe new = goog_data.loc[mask] # loc NON lavora inplace &lt;=================== new_np = new.to_numpy() goog_cp = new_np[:,4] # # PROBLEMA III # Costruisco un array con le date corrispondenti in modo che io possa poi disegnarle fig_7 = plt.figure(figsize=(8,5)) # creiamo la figura/canvas come al solito axes_7 = fig_7.add_axes([0.1,0.1, 0.9, 0.9]) # il grafico non copre tutta la figura, lasciamo un po&#39; di padding plt.plot(date_arr_np, goog_cp); #plt.plot(new.Date, new.Close) # questo fa vedere sbagliato i tics sotto Tabelle Questo non e’ cosi’ interessante, la cosa che trovo piu’ utile e’ come girare le date sull’asse delle x. Copio il pezzo di notebook scritto da Banas qui sotto: # Format column data to 2 decimals goog_data[&#39;Open&#39;] = pd.Series([round(val, 2) for val in goog_data[&#39;Open&#39;]], index = goog_data.index) goog_data[&#39;High&#39;] = pd.Series([round(val, 2) for val in goog_data[&#39;High&#39;]], index = goog_data.index) goog_data[&#39;Low&#39;] = pd.Series([round(val, 2) for val in goog_data[&#39;Low&#39;]], index = goog_data.index) goog_data[&#39;Close&#39;] = pd.Series([round(val, 2) for val in goog_data[&#39;Close&#39;]], index = goog_data.index) goog_data[&#39;Adj Close&#39;] = pd.Series([round(val, 2) for val in goog_data[&#39;Adj Close&#39;]], index = goog_data.index) # Get most recent last 5 days of stock data stk_data = goog_data[-5:] stk_data # Define headers col_head = (&#39;Date&#39;,&#39;Open&#39;,&#39;High&#39;,&#39;Low&#39;,&#39;Close&#39;,&#39;Adj Close&#39;,&#39;Volume&#39;) stk_data_np = stk_data.to_numpy() stk_data_np # Add padding around cells in table plt.figure(linewidth=2, tight_layout={&#39;pad&#39;:.5}, figsize=(5,3)) # Get rid of axes and plot box axes_8 = plt.gca() axes_8.get_xaxis().set_visible(False) axes_8.get_yaxis().set_visible(False) plt.box(on=None) # np.full returns an array filled with 0.1 # cm is a colormap object we are using to use a default blue color # matplotlib.org/3.1.0/tutorials/colors/colormaps.html ccolors = plt.cm.Blues(np.full(len(col_head), 0.2)) # Receives data, loc, list of column headers, column header color as array of colors # You can also add rowLabel, rowColours, rowLoc: Text alignment the_table = plt.table(cellText=stk_data_np, loc=&#39;center&#39;, colLabels=col_head, colColours=ccolors) # Set table font size the_table.set_fontsize(14) the_table.scale(3, 2.5) C:\ProgramData\Anaconda3\lib\site-packages\IPython\core\pylabtools.py:132: UserWarning: Tight layout not applied. The left and right margins cannot be made large enough to accommodate all axes decorations. fig.canvas.print_figure(bytes_io, **kw) ScatterPlot Qui ci sono dei dati relativi al Coronavirus. E’ importante che ci sia uniformita’ di grandezza per quanto riguarda gli array che vanno plottati: ci sono 26 nazioni ci sono 26 tassi di mortalita’ ci sono 26 valori di casi confermati giornalieri ci sono 26 dimensioni dei punti Nota che i questo caso non costruisco la figura e poi gli assi. Questo perche’ viene fatto automaticamente dal comando plt.scatter. Ci sono 2 vie per ottenere lo stesso grafico: costruisco la fig, e gli assi e uso scatter come metodo sull’asse creato uso plt.scatter e lui automaticamente crea gli assi! Argomenti dello scatterplot: prima si mettono i valori dell’asse delle x (e’ un np.array) poi l’array per i valori dell’asse delle y (anche questo un np.array lungo quanto quello sopra) s per size (dei punti): NON e’ come gnuplot che accettava le abbreviazioni, qui il parametro si chiama SOLO s! c per color (dei punti) alpha e’ in pratica il livello di trasparenza, in questo caso e’ fondamentale in quanto alcuni punti andranno a sovrapporsi # Numpy array con i nomi delle nazioni cnt_arr = np.array([&#39;Australia&#39;,&#39;Brazil&#39;,&#39;Canada&#39;,&#39;Chile&#39;,&#39;France&#39;,&#39;Germany&#39;,&#39;Greece&#39;, &#39;Iceland&#39;,&#39;India&#39;,&#39;Iran&#39;,&#39;Italy&#39;,&#39;Mexico&#39;,&#39;New Zealand&#39;,&#39;Nigeria&#39;, &#39;Norway&#39;,&#39;Pakistan&#39;,&#39;Peru&#39;,&#39;Russia&#39;,&#39;Saudi Arabia&#39;,&#39;Singapore&#39;, &#39;South Africa&#39;,&#39;Spain&#39;,&#39;Sweden&#39;,&#39;Turkey&#39;,&#39;UK&#39;,&#39;US&#39;]) # Tasso mortalita per 100k casi Coronavirus dr_arr = np.array([1.8,53,24.5,56.5,45.4,11.2,2.2, 2.8,4,24.6,58.6,46.3,.5,.5, 4.9,2.9,83.3,11,10.4,.5, 21.5,61.6,56.9,7.3,62.4,52.9]) # Numero giornaliero di casi confermati (Tests) test_arr = np.array([110,7197,600,1862,1636,1103,35, 10,295,1658,1226,2490,8,243, 48,1395,1101,4447,1443,280, 2830,1602,447,1205,1546,24988]) # Dimensione del punto dei casi confermati cc_arr = np.array([24236,3456652,125408,390037,256534,229706,7684, 2035,2836925,350279,255278,537031,1654,50488, 10162,290445,549321,935066,302686,56031, 596060,370867,85411,253108,323008,5529824]) cc_arr_sm = cc_arr/1000 # rimpicciolisce a dimensione dei punti (?) color_arr= np.random.rand(26) # Se faccio questi sotto vengono aggiunti ad una figura aggiuntiva, non al mio scatterplot # questo perche&#39; ho provato ad usare la strada per cui prima faccio la figura, aggiungo gli assi # e il disegno viene con un metodo! #plt.title(&#39;Mortalita per 100k vs. Casi confermati&#39;) #plt.xlabel(&#39;Mortalita per 100k&#39;) #plt.ylabel(&#39;Casi confermati&#39;) #plt.scatter(dr_arr, test_arr, s=cc_arr_sm, c=color_arr,alpha=0.5 ) #plt.figure(figsize=(8,5)) fig_13 = plt.figure(figsize=(8,5)) axes_13 = fig_13.add_axes([0.1,0.1,0.9,0.9]) axes_13.set_xlabel(&#39;Mortalita per 100k&#39;) axes_13.set_ylabel(&#39;Casi confermati&#39;) axes_13.set_title(&#39;Mortalita per 100k vs. Casi confermati&#39;) axes_13.scatter(dr_arr, # valori sull&#39;asse delle x test_arr, # valori sull&#39;asse delle y s=cc_arr_sm, # valori che indicano la dimensione dei punti c=color_arr, # colori di ogni punto alpha=0.2 ); # trasparenza 1 = no trasparenza, 0 = completamente trasparente 3D from mpl_toolkits import mplot3d abbiamo bisogno di importare questo modulo projection=&#39;3d&#39; quando si costruisce la figura si aggiunge questo parametro fig_9 = plt.figure(figsize=(8,5), dpi=100) dpi=100 stranamente sembra avere un effetto sulla dimensione della figura, mentre sembra non prendere il parametro figsize! Probabilmente questo e’ dovuto al fatto che con %matplotlib inline mi mette le figure come dei png, cambiando il numero di punti questo cambia la dimensione dell’immagine a schermo. Per esempio dpi=100 e’ circa un terzo della figura con dpi=300 scatter3D la funzione per uno scatterplot 3D c= z_3 se uso questo parametro per i colori, allora quelli piu’ in alto (asse z) avranno una sfumatura differente da quelli in basso Scatter3D from mpl_toolkits import mplot3d fig_9 = plt.figure(figsize=(6,5), dpi=100) axes_9 = fig_9.add_axes([0.1,0.1,0.9,0.9], projection=&#39;3d&#39;) # mette degli assi 3D z_3 = 40 *np.random.random(100) # random: sample dalla [0,1) uniforme x_3 = np.sin(z_3) * np.random.randn(100) # randn y_3 = np.cos(z_3) * np.random.randn(100) # randn: sample dalla N(0,1) #axes_9.scatter3D(x_3,y_3,z_3, cmap=&#39;Blues&#39;); axes_9.scatter3D(x_3,y_3,z_3, c=z_3, cmap=&#39;Blues&#39;); Contour3D In questo caso ho bisogno di una funzione z =z(x,y) questo perche’ lui deve poter sapere la altezza in ogni punto. per costruire una griglia rettangolare devo usare np.meshgrid: x_4, y_4 = np.meshgrid(x_4, y_4) occhio che se non metto questo comando mi dice che c’e’ un errore!? Il motivo e’ semplice. meshgrid prende in ingresso due array 1 dimensionali e restituisce due array 2 dimensionali. In pratica ha fatto un prodotto cartesizano per ognuno dei punti del primo array creando una coppia con quelli del secondo array (e viceversa per il secondo array). Questo perche’ contour3D si aspetta delle matrici per le x e le y e anche le z, in quanto per ogni x e y c’e’uno z. Per capire meglio fai fare print(x_4) prima e dopo meshgrid e vedi la differenza. Angolo di vista, per cambiare: axes_9.view_init(45, 55). questo sposta l’angolo di vista di 45 gradi e lo ruota di 55 il 4to parametro indica il numero di linee. In pratica quante fette parallele al piano xy che vengono visualizzate, se metto 80 sono tante, se metto 20 sono poche fig_9 = plt.figure(figsize=(6,5), dpi=100) axes_9 = fig_9.add_axes([0.1,0.1,0.9,0.9], projection=&#39;3d&#39;) def get_z (x,y): return np.sin(np.sqrt(x**2+y**2)) x_4 = np.linspace(-6,6,30) y_4 = np.linspace(-6,6,30) #print(x_4) x_4, y_4 = np.meshgrid(x_4, y_4) #print(x_4) z_4 = get_z(x_4, y_4) axes_9.set_xlabel(&#39;x&#39;) axes_9.set_ylabel(&#39;y&#39;) axes_9.set_zlabel(&#39;z&#39;) axes_9.view_init(35, 30) # angolo di visione, angolo di rotazione axes_9.contour3D(x_4,y_4,z_4, 20, cmap=&#39;Blues&#39;); WireFrame e surface In questo caso vengono connessi tutti i punti da un segmento. -plot_wireframe(x_4,y_4,z_4, cmap=&#39;Blues&#39;) in questo caso non devo passare il numero di tagli paralleli all’asse xy, quindi non ha il 4to parametro. edgecolor =&#39;none&#39; non colora i segmenti di collegamento (il wireframe) fig_9 = plt.figure(figsize=(6,5), dpi=100) axes_9 = fig_9.add_axes([0.1,0.1,0.9,0.9], projection=&#39;3d&#39;) axes_9.view_init(35, 30) # angolo di visione, angolo di rotazione #axes_9.plot_wireframe(x_4,y_4,z_4, cmap=&#39;Blues&#39;); axes_9.plot_surface(x_4,y_4,z_4, rstride=1, cstride=1, cmap=&#39;Blues&#39;, edgecolor=&#39;r&#39;); Finance Module per installare ho fatto: anaconda prompt pip install mpl_finance pip install –upgrade mplfinance # upgrade questo modulo fa vedere le candele giapponesi ecc. posso cambiare il nome dell’index: goog_df.index.name=&#39;Date&#39; a questo punto l’index non si chiama piu’ index ma Date! mi pare di capire che questo sia necessario perche’ la libreria prenda correttamente il dataframe. Candele giapponesi Attento se prendi tante date, non riesci a vedere le candele! devono essere poche per essere visibili. trendlines possiamo mettere automaticamente delle medie mobili con il parametro: -type=&#39;ohlc&#39;, mav=4 # che significa che mette Open High Low Close e la media mobile basata sui precedenti 4 punti,nota che possiamo tenere come type ‘candle’ (ma si vede meno bene) altri tipi di medie mobili. mav=(3,5,7) e’ bene usare dispari, quindi fa vedere 3 medie mobili basate sui 3, 5 e 7 gg precedenti il parametro volume=True va vedere i volumi giornalieri mostrare non-tading days: show_nontrading=True parse_dates parse_dates=true vuol dire che non prende le date come delle semplici stringhe ma le legge come date, infatti ora sono in formato Timestamp import mplfinance as mpf goog_df = pd.read_csv(&#39;GOOG.csv&#39;, index_col = 0, parse_dates=True) #type(goog_df.index[0]) goog_df.index.name=&#39;Date&#39; #goog_df = pd.read_csv(&#39;GOOG.csv&#39;) goog_df.head(3) Open High Low Close Adj Close Volume Date 2019-08-21 1193.150024 1199.000000 1187.430054 1191.250000 1191.250000 740700 2019-08-22 1194.069946 1198.011963 1178.579956 1189.530029 1189.530029 947500 2019-08-23 1181.989990 1194.079956 1147.750000 1151.290039 1151.290039 1687000 mask = ( ( pd.to_datetime(goog_df.index) &gt;= pd.to_datetime(&#39;5/20/2020&#39;)) &amp; ( pd.to_datetime(goog_df.index) &lt;= pd.to_datetime(&#39;8/19/2020&#39;)) ) new = goog_df.loc[mask] # #mpf.plot(new, type=&#39;line&#39;) # normali linee #mpf.plot(new, type=&#39;candle&#39;) # candele giapponesi #mpf.plot(new, type=&#39;ohlc&#39;, mav=4) # open high low close + moving average mpf.plot(new, type=&#39;ohlc&#39;, mav=(3,5,7), volume=True, show_nontrading=True) # open high low close + moving average Heatmap ho un array 2 dimensionale e voglio mostrarlo con dei colori invece che dei numeri. symptoms sono i 4 tipi di malattia a cui si riferiscono i dati (dyspnea = short of breath) dates sono i giorni in cui sono state fatte le osservazioni (sono 9 giorni) symp_per sono il numero di pazienti per giorno per malattia e’ un array 4x9 Nota: pensavo che la heatmap di default mettesse delle righe bianche in mezzo alle caselle risultando molto poco chiara! in realta’ e’ una delle opzioni lasciate dal finance module!!!! (se faccio girare prima la casella sotto le righe bianche in mezzo non ci sono!) Per la heatmap si deve usare subplots() (non figure) Cosa fa il comando? prende la matrice che ha 0,3 righe, e 0,8 colonne. Per ognuna delle righe e delle colonne scrive un colore associato al numero dell’ingresso dell’array da disegnare. symptoms = [&quot;Coronavirus&quot;,&quot;Influenza&quot;,&quot;Pneumonia&quot;,&quot;Dyspnea&quot;] dates = [&quot;Jun28&quot;,&quot;Jul05&quot;,&quot;Jul12&quot;,&quot;Jul19&quot;,&quot;Jul26&quot;,&quot;Aug02&quot;,&quot;Aug09&quot;,&quot;Aug16&quot;,&quot;Aug21&quot;] symp_per = np.array([[5.2, 5.5, 5.7, 5.6, 5.3, 5.1, 5.0, 4.9, 5.3], [3.5, 4.0, 4.3, 3.9, 3.5, 3.2, 2.7, 2.2, 2.0], [1.8, 2.2, 2.3, 2.2, 2.1, 1.9, 1.7, 1.4, 1.3], [1.0, 1.1, 1.1, 1.0, 0.9, 0.8, 0.8, 0.8, 0.7]]) fig_10 , axes_10 = plt.subplots() im= axes_10.imshow(symp_per, cmap=&#39;Wistia&#39;) tics non chiaro perche’ all’inizio metta un np.arange, dato che abbiamo gia’ un array con dates e symptoms: ok: axes_10.set_xtics(np.arange(len(dates)) qui definisce la distanza (posizione) che devono avere i tics sulla mappa. axes_10.set_xticlabels(dates) questo definisce cosa ci deve essere nei ticks occhio che ticks ha la k occhio i ticks vanno assegnati DOPO avere definito la figura e l’axes giro i ticks di 45 gradi! plt.setp(axes_10.get_xticklabels(), rotation=45, ha=&#39;right&#39;, rotation_mode=&#39;anchor&#39;) (non chiaro l’anchor cosa faccia) fig_10 , axes_10 = plt.subplots() im= axes_10.imshow(symp_per, cmap=&#39;Wistia&#39;) axes_10.set_xticks(np.arange(len(dates))) # posizione tics sull&#39;asse x axes_10.set_yticks(np.arange(len(symptoms))) # posizione tics sull&#39;asse y axes_10.set_xticklabels(dates) # cosa viene mostrato ad ogni tic dell&#39;asse x axes_10.set_yticklabels(symptoms) # cosa viene mostrato ad ogni tic dell&#39;asse x plt.setp(axes_10.get_xticklabels(), rotation=45, ha=&#39;right&#39;); Numeri nelle caselle metto qui anche i numeri dentro le caselle. Nota che usa un costrutto che non ho mai usato prima, chiama un metodo dell’axes dentro una funzione di matplotlib. -plt.setp(axes_10.get_xticklabels(), rotation=45, ha=&#39;right&#39;); chiama fig_10 , axes_10 = plt.subplots() im= axes_10.imshow(symp_per, cmap=&#39;Wistia&#39;) axes_10.set_xticks(np.arange(len(dates))) # posizione tics sull&#39;asse x axes_10.set_yticks(np.arange(len(symptoms))) # posizione tics sull&#39;asse y axes_10.set_xticklabels(dates) # cosa viene mostrato ad ogni tic dell&#39;asse x axes_10.set_yticklabels(symptoms) # cosa viene mostrato ad ogni tic dell&#39;asse x plt.setp(axes_10.get_xticklabels(), rotation=45, ha=&#39;right&#39;); for i in range(len(symptoms)): for j in range(len(dates)): text = axes_10.text(j,i, symp_per[i,j], ha=&#39;center&#39;, va=&#39;center&#39;, color=&#39;k&#39;, fontweight=&#39;bold&#39;) Riempire le aree tra curve ci sono ottimi esempi al sito di matplotlib: https://matplotlib.org/3.1.1/gallery/lines_bars_and_markers/fill_between_demo.html il metodo degli assi fill_between() permette di riempire quello che c’e’ tra una curva e l’altra. x = np.arange(0.0, 2, 0.01) # le x y1 = np.sin(2 * np.pi * x) # y1 = la funzione seno y2 = 1.2 * np.sin(4 * np.pi * x) # y2 = funzione seno piu&#39; larga e con maggiore frequenza fig, (ax1, ax2, ax3) = plt.subplots(3, 1, sharex=True) ax1.fill_between(x, 0, y1) # riempie tra 0 e y1 ax1.set_ylabel(&#39;TRA y1 e 0&#39;) ax2.fill_between(x, y1, 1) # riempie tra y1 e 1 (quello che c&#39;e&#39; sopra y1) ax2.set_ylabel(&#39;TRA y1 e 1&#39;) ax3.fill_between(x, y1, y2) # quello che c&#39;e&#39; TRA y1 e sotto y2 ax3.set_ylabel(&#39;TRA y1 e y2&#39;) ax3.set_xlabel(&#39;x&#39;) Text(0.5, 0, &#39;x&#39;) si possono mettere ulteriori condizioni per dare dei colori diversi tra le curve. In particolare si aggiungono dei parametri logici. fig, (ax, ax1) = plt.subplots(2, 1, sharex=True) # costruisce subplots ax.plot(x, y1, x, y2, color=&#39;black&#39;) # disegna le 2 funzioni ax.fill_between(x, y1, y2, where=y2 &gt;= y1, facecolor=&#39;green&#39;, interpolate=True) ax.fill_between(x, y1, y2, where=y2 &lt;= y1, facecolor=&#39;red&#39;, interpolate=True) ax.set_title(&#39;fill between where&#39;) # Test support for masked arrays. y2 = np.ma.masked_greater(y2, 1.0) ax1.plot(x, y1, x, y2, color=&#39;black&#39;) ax1.fill_between(x, y1, y2, where=y2 &gt;= y1, facecolor=&#39;green&#39;, interpolate=True) ax1.fill_between(x, y1, y2, where=y2 &lt;= y1, facecolor=&#39;red&#39;, interpolate=True) ax1.set_title(&#39;Now regions with y2&gt;1 are masked&#39;) Text(0.5, 1.0, &#39;Now regions with y2&gt;1 are masked&#39;) Ticks Al comando ticks possono essere passati degli argomenti per specificare: rotation = 45 ruota di 45 gradi se il primo ingresso e’ un np.array allora quelli sono i ticks (le posizioni) se il secondo ingresso e’ una tupla, allora alle varie posizioni dei ticks vengono messi i valori della tupla fontsize=24 viene passato come al solito puoi passare piu’ di un parametro basta che sia separato dalla virgola! plt.plot(x_1,y_1) #plt.xticks(np.linspace(0,5,100)) #plt.xticks(np.arange(15)) #plt.xticks(np.arange(5), (&#39;Tom&#39;, &#39;Dick&#39;, &#39;Harry&#39;, &#39;Sally&#39;, &#39;Sue&#39;)) #plt.grid(False, color=&#39;r&#39;, dashes=(0,2,1,2)) plt.grid(False) #plt.grid(b=None) degrees = 45 plt.xticks(rotation=degrees) # Rotazione dei ticks mioArray= np.array([1,2,3,4,8]) #plt.xticks(np.linspace(0,5,5), (&#39;Tom&#39;, &#39;Dick&#39;, &#39;Harry&#39;, &#39;Sally&#39;, &#39;Sue&#39;)) plt.grid(True) # presenza della grid plt.xticks(fontsize=24) # GRANDEZZA FONT plt.xticks(mioArray, (&#39;Gino&#39;, &#39;Pino&#39;, &#39;Mino&#39;, &#39;Tino&#39;, &#39;Asdrubale&#39;)); Animazioni Testo di riferimento: https://riptutorial.com/Download/matplotlib-it.pdf Lo ho scaricato ed e’ nella dir. Bisogna importare anche la parte del package che fa animazioni. Bisogna usare il metodo set_data() che assegna i valori delle x e y di un grafico %matplotlib notebook import matplotlib.animation as animation TWOPI = 2*np.pi fig, ax = plt.subplots() # costruiamo una figura e un array di assi t = np.arange(0.0, TWOPI, 0.001) # t =array di posizioni s = np.sin(t) # y = sin(t) l = plt.plot(t, s) # grafico ax = plt.axis([0,TWOPI,-1,1]) # assi redDot, = plt.plot([0], [np.sin(0)], &#39;ro&#39;) # l&#39;oggetto &quot;redDot&quot; disegna il punto rosso, all&#39;inizio e&#39; in zero def animate(i): # questa funzione modifica i parametri del punto rosso redDot.set_data(i, np.sin(i)) # quindi il resto del grafico resta invariato! return redDot, # create animation using the animate() function myAnimation = animation.FuncAnimation(fig, animate, frames=np.arange(0.0, TWOPI, 0.01), \ interval=1, blit=True, repeat=True) &lt;IPython.core.display.Javascript object&gt; Mio test di animazione vorrei fare estendere la funzione seno, in modo che ad ogni frame sia moltiplicata per una diversa ampiezza. Attenzione: ho provato a farlo girare molte volte e non andava. Ho resettato il kernel e ora sembra fungere. Mi viene il dubbio che il problema fosse connesso a qualche cella che avevo lasciato attiva. Curiosamente se metto i limiti degli assi il grafico non appare! Errore Ax e’ un array di assi! interval=1 rallenta l’esecuzione del programma frames sono tutti i vari prarametri che andranno a definire i frame possiamo ingrandire o diminuire la dimensione dei limiti: https://stackoverflow.com/questions/53423868/matplotlib-animation-how-to-dynamically-extend-x-limits TWOPI = 2*np.pi #fig, ax = plt.subplots() # costruiamo una figura e un array di assi fig = plt.figure() ax = fig.add_subplot(111, autoscale_on=False, xlim=(0, 6.29), ylim=(-2, 2)) #ax = plt.axis([0,TWOPI,-1,1]) # ATTENTO assi QUESTO BLOCCA set_xlim #ax.set_xlim([0,TWOPI]) # ERRORE ax non e&#39; un asse ma una tupla di assi! #ax.set_ylim([-1,1]) # ERRORE t = np.arange(0.0, TWOPI, 0.001) # t =array di posizioni s = np.sin(t) # y = sin(t) plt.grid(False) new = plt.plot(t, t) # bisettrice second = plt.plot(t,s/2) curva, = plt.plot(t, s) # grafico #ax = plt.axes(xlim=(0, 10), ylim=(-1, 1)) def animate(A): # questa funzione modifica i parametri del punto rosso curva.set_ydata(A *np.sin(t)) # quindi il resto del grafico resta invariato! #print(A*np.sin(t)) return curva, frames1 = np.arange(0.0,1.0,0.001) frames2 = np.arange(1.0,0.0,-0.001) frames = np.concatenate((frames1, frames2), axis=None) # create animation using the animate() function #myAnimation = animation.FuncAnimation(fig, animate, frames = np.arange(0.0, 1.0, 0.001), \ # interval=10, blit=True, repeat=True) myAnimation = animation.FuncAnimation(fig, animate, frames = frames, \ interval=1, blit=True, repeat=True) &lt;IPython.core.display.Javascript object&gt; Slider interattivo possiamo modificare la figura tramite uno slider interattivo! In questo caso non uso la funzione animate, perche’ la modifica viene fatta in base a cosa tocco sullo slider. from matplotlib.widgets import Slider TWOPI = 2*np.pi fig, ax = plt.subplots() A0 = .5 # valore iniziale ampiezza t = np.arange(0.0, TWOPI, 0.001) # x del grafico s = A0*np.sin(t) # y del grafico (iniziale) l, = plt.plot(t, s, lw=2) # grafico (da capire la virgola) ax = plt.axis([0,TWOPI,-1,1]) # assi (che non verranno toccate) ??? axamp = plt.axes([0.25, .03, 0.50, 0.02]) # non chiaro axIs e axEs # Slider samp = Slider(axamp, &#39;Amp&#39;, 0, 1, valinit=A0) # SLIDER interattivo, si chiama &quot;samp&quot; def update(val): # amp is the current value of the slider amp = samp.val # valore corrente dello slider # update curve l.set_ydata(amp*np.sin(t)) # fai update delle y della curva # redraw canvas while idle fig.canvas.draw_idle() samp.on_changed(update) # ridisegna la figura se muoviamo lo slider #plt.show() &lt;IPython.core.display.Javascript object&gt; 0 Foto Vediamo come mostrare una immagine. Si passa un array 2D e questo viene convertito automaticamente, assegnando ai valori un colore. Per esempio: immagine = np.array([ [1,0,0,0,1,0,0,0,1], [0,0,0,0,1,0,0,0,0], [0,0,0,0,1,0,0,0,0], [0,0,0,0,1,0,0,0,0], [0,0,0,0,1,0,0,0,0], [1,0,0,0,1,0,0,0,1]]) plt.imshow(immagine) &lt;matplotlib.image.AxesImage at 0x2de6a38e640&gt; Unpacking questo non e’ strettamente connesso con matplotlib…. numbers = [1, 2, 3, 4, 5, 6] first, *rest = numbers # multiple assignment print(rest) print(first) d = dict(a=5,b=2,c=4) [2, 3, 4, 5, 6] 1 enumerate() for o,_ in enumerate(d): print(o) # stampa l&#39;ordine degli oggetti 0 1 2 for _, o in enumerate(d): print(o) # stampa le chiavi del dizionario a b c for _, o in enumerate(d): print(d[o]) # stampa i valori del dizionario 5 2 4 for o in enumerate(d): print(o) # stampa le NUOVE coppie chiave-chiave vecchia costruite da enumerate() (0, &#39;a&#39;) (1, &#39;b&#39;) (2, &#39;c&#39;)" />
<link rel="canonical" href="http://localhost:4000/Matplotlib" />
<meta property="og:url" content="http://localhost:4000/Matplotlib" />
<meta property="og:site_name" content="4Phycs" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-11-07T01:00:00+01:00" />
<meta name="google-site-verification" content="" />
<script type="application/ld+json">
{"headline":"Matplotlib - appunti","dateModified":"2021-11-07T01:00:00+01:00","datePublished":"2021-11-07T01:00:00+01:00","description":"Matplotlib Queste sono le mie (Paolo Avogadro) note basate sul video di Derek Banas riguardo a Matplotlib. Oltre agli esempi suggeriti aggiungo dei miei test e considerazioni. Qualunque errore e’ esclusivamente dovuto ad una mia erronea interpretazione dei comandi. Lo scopo di queste note non e’ di presentare esempi perfettamente funzionanti, ma serve a me come spunto per ricordare i comandi di Matplotlib, e il modello mentale che io ho sul pacchetto. La versione originale di queste note ha la forma di un Jupyter Notebook e quindi possono esserci dei riferimenti ai notebook all’interno del testo. Dopo avere imparato Matplotlib puo’ essere interessante impararare ad usare Seaborn. Cerco di ricostruire gli esempi presentati e fare delle piccole varianti per capire meglio. Queste note suppongono che ci sia una certa conoscenza di base di come fare i grafici al computer, per esempio partendo da Gnuplot. Notazione: cerco di usare l’evidenziatore per i comandi cerco di usare il grassetto per i termini principali Micro-riassunto: Ci sono 2 modi principali per fare un grafico: modo veloce: con le funzioni di plotting, per esempio: plt.plot(x_1, y_1) (dove x_1 e x_2 sono due oggetti contenenti lo stesso numero di variabili). Si possono inoltre aggiungere delle funzioni per controllare le label, il titolo ecc. modo esteso: prima si definisce una figure, per esempio: fig_1 = plt.figure(figsize=(5,4), dpi =100); pensa alla figure come un’immagine bianca. poi si costruisce uno (o piu’) axes (assi) con un metodo delle figure: axes_1 = fig_1.add_axes([0.1,0.1,0.9,0.9]) (dove specifichiamo la posizione degli assi all’interno della figura). Gli assi determineranno la posizione del grafico. Per esempio se hai un solo quadrante per il tuo grafico puoi immaginare gli assi come un rettangolo (vuoto all’interno). A questo punto si fa partire un grafico, usando un metodo degli assi, per esempio: axes_1.plot(x_1,y_1); Nota che questi metodi sono in pratica le stesse funzioni del punto 1 (solo che vengono chiamati come metodi dell’asse). Nota se non sei in un jupyter notebook dovrai usare un plt.show() se sei su un notebook invece, serve un magic command (e’ una di quelle cose decorate con il percentuale), ci sono vari di questi comandi, tra cui: %matplotlib inline (questo fa apparire delle immagini png statiche nel notebook) %matplotlib notebook (si possono fare zoom delle immagini) %matplotlib tk (tkinter GUI) Una lista di termini utili: alpha=0.75 definisce la trasparenza lw=2 larghezza delle linee del grafico ls =&#39;-.&#39; line style, se e’ una linea continua, oppure trattino e punto, ecc… marker = &#39;o&#39; marker sono i punti di gnuplot. Cosa viene messo nei punti? in questo caso dei cerchietti =o) markersize=7 la grandezza dei punti markerfacecolor =&#39;y&#39; il colore dell’interno dei punti markeredgecolor=&#39;k&#39; il colore dei contorni dei punti markeredgewidth=2 la larghezza del contorno dei punti projection=&#39;3d&#39; argomento per quando si creano degli assi e devono avere un 3D goog_df = pd.read_csv(&#39;GOOG.csv&#39;, index_col = 0, parse_dates=True) trasforma del testo in datetime! facecolor e’ il colore dello sfondo di un’immagine Metodi di FIGURE: fig.tight_layout() oppure, plt.tight_layout() serve per evitare sovrapposizioni per esempio i numeri degli assi trasbordino fig_3.savefig(&#39;ultimoPlot.png&#39;) salvare a file una figura! Metodi degli Assi plt.xticks(np.linspace(0,5,5), (&#39;Tom&#39;, &#39;Dick&#39;, &#39;Harry&#39;, &#39;Sally&#39;, &#39;Sue&#39;)) tics (o ticks) sull’asse x. Per non avere ticks: plt.xticks([]) (non ho messo nulla nella lista = non ci sono ticks) axes_3.set_xlim([0,3]) definisce i limiti sull’asse x (set xlim[1:100]) axes_4.set_xlabel(&#39;temp&#39;) label degli assi axes_3.grid(False, color=&#39;r&#39;, dashes=(0,2,1,2)) mette una griglia sullo sfondo, occhio che color e’ il colore della griglia non dello sfondo. plt.grid(False) e plt.grid(b=None) tolgono la griglia axes_3.set_facecolor(&#39;w&#39;) colore dello sfondo (bianco in questo caso) axes_4.set_title(&#39;da Pandas: IceCream&#39;) titolo axes_1.legend(loc =0 ) # Loc=0 e’ la migliore location scelta da lui` Tipi di disegno (possono essere chiamati come metodi degli assi o funzioni plt): axes_4.plot(x_2, y_2) disegno standard in cui ci sono i punti e posso unirli, cambiarli ecc. plt.bar(x_2, y_2, width=1.5); barchart (come istogramma ma sulle x possono essere categorici) plt.stem(x_2, y_2, &#39;-.&#39;) impulsi, interessante si puo’ indicare il tipo di linea plt.hist(arr3ok, bins= 7, density=True, stacked =False); istogrammi (raggruppa i valori sull’asse delle x in bins) plt.pie() piechart TORTE (gurada sotto perche’ servono un po’ di dettagli) axes_13.scatter(dr_arr, test_arr, s=cc_arr_sm, c=color_arr, alpha=0.2 ) scatterplot valori sull’asse delle x, y, dimensione punti, colori dei punti, trasparenza) axes_9.scatter3D(x_3,y_3,z_3, c=z_3, cmap=&#39;Blues&#39;); scatterplot 3D axes_9.contour3D(x_4,y_4,z_4, 20, cmap=&#39;Blues&#39;); 3D contorno, curve di livello, isoipse axes_9.plot_wireframe(x_4,y_4,z_4, cmap=&#39;Blues&#39;); wireframe e’ il grafico 3D standard di gnuplot, collega tutti i punti axes_9.plot_surface(x_4,y_4,z_4, rstride=1, cstride=1, cmap=&#39;Blues&#39;, edgecolor=&#39;r&#39;); 3D, collega i punti e colora le tegole Consiglio: in un Jupyter notebook usa shift-tab su una funzione per vederne la sua descrizione (prima devi cliccare sulla cella e poi avere il cursore sulla funzione stessa). Consiglio questo articolo contiene trucchi su jupyter notebook e alternative a Matplotlib. import numpy as np import pandas as pd import matplotlib.pyplot as plt %matplotlib inline #%matplotlib notebook %reload_ext autoreload %autoreload 2 Functional Plot Cominciamo con un’immagine semplice in cui c’e’ il titolo: plt.title(&#39;ciao&#39;) ci sono i nomi degli asssi: plt.xlabel(&#39;Days&#39;) c’e’ un grafico: plt.plot(x_1, y_1) Quando faccio un disegno, voglio che tutte le coordinate x siano in un contenitore (lo stesso vale per le coordinate y). Questi “contenitori” devono contenere lo stesso numero di oggetti, altrimenti per un punto avrei solo la coordinata x o solo la y… quindi mi manca il punto! x_1 = np.linspace(0,5,10) # genera un Numpy array con 10 float equispaziati tra 0 e 5 y_1 = x_1 **2 # genera un Numpy array che e&#39; il quadrato del primo plt.plot(x_1, y_1); plt.title(&#39;ciao&#39;); plt.xlabel(&#39;Days&#39;); plt.ylabel(&#39;Days squared&#39;); #plt.show() # se non siamo in jupyter notebook Domanda: posso passare delle liste ad un plt.plot()? Risposta: si’ certo! posso anche graficare delle liste che contengano delle stringhe. Se il contenitore di stringhe e’ una lista, allora esiste un ordine per le stringhe e questo ordine verra’ usato nella visualizzazione. Per un set invece non esiste un ordine e si ha un errore TypeError: unhashable type: ‘set’ l1= [1,2,3,4] l2= [3,4,5,6] l3= [&#39;a&#39;,&#39;b&#39;,&#39;e&#39;,&#39;d&#39;] d1 = {&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;} plt.plot(l1,l3); #plt.plot(l1,d1) # non funge! plt.subplot() molti grafici in modo veloce Qui vediamo come mettere piu’ di un grafico vicino all’altro. Nel dettaglio usando subplot potremo costuire una griglia, in ogni casella della griglia verra’ messo un grafico. Il comando plt.subplot(1,2,1) fa questo tipo di lavoro. il primo argomento e’ il numero di righe della griglia (in questo caso c’e’ solo una riga) il secondo argomento e’ il numero di colonne della griglia . il terzo argomento e’ l’indice del grafico. L’indice ci dice in quale casella della griglia stiamo mettendo il subplot. L’ordine seguito e’ lo stesso che si ha quando si legge: da SINISTRA a DESTRA da SOPRA a SOTTO. Vediamo un esempio: # nota che se anche il terzo argomento e&#39; 2 il grafico appare al primo posto, perche&#39; # non ce ne sono 2! E&#39; un po&#39; come se cadesse a sinistra se ci sono dei buchi? plt.subplot(1,2,2) # questo ci dice che abbiamo una riga e 2 colonne plt.plot(x_1,y_1, &#39;r&#39;); # r = red plt.subplot(1,2,1) # questo ci dice che abbiamo una riga e 2 colonne plt.plot(x_1,y_1, &#39;r&#39;) # r = red plt.subplot(1,2,2) # se metto 1 mi sovrappone con il primo ma mi dice che c&#39;e&#39; qualcosa di strano plt.plot(x_1,y_1, &#39;b&#39;) [&lt;matplotlib.lines.Line2D at 0x2de659e5c40&gt;] plt.subplot(2,2,1) # plt.plot(x_1,y_1, &#39;r&#39;) # plt.subplot(2,2,2) # plt.plot(x_1, y_1-y_1**2, &#39;b&#39;) plt.subplot(2,2,4) plt.plot(x_1, -y_1, &#39;g&#39;); plt.tight_layout() # evita sovrapposizione dei numeri dei grafici! Figure e axes Una figure e’ un oggetto su cui poi si mette il grafico (lo vedo come la tela bianca su cui fare il disegno) contiene tutti i ‘plot elements’ puo’ contenere molti axes (assi), che in pratica sono gli assi che definiscono il disegno vero e proprio, in quanto i punti sono riferiti agli assi. posso definire la sua larghezza e lunghezza in inch (inch=2.54 cm), probabilmente posso cambiare scala: figsize=(5,4) posso anche definire la risoluzione in dpi ATTENTO se definisci il numero di dpi, quando lo visualizzi come un png, questo definisce la dimensione della figura a video! quindi sembra che figsize non funzioni! fig_1 = plt.figure(figsize=(5,4), dpi =100); &lt;Figure size 500x400 with 0 Axes&gt; Axes L’oggetto axes (come indica il nome) identifica la posizione, la forma, e tutte le caratteristiche degli ASSI di un grafico. Se non facciamo esplicitamente un grafico, ci saranno solo le due fracce perpendicolari (gli assi) con dentro nulla. Possiamo i plot (grafici) sono dei metodi degli assi! La logica e’ quindi che siano un oggetto in funzione di dove sono gli assi (e ha senso, quando uno fa un grafico su un foglio, prima disegna gli assi, e poi puo’ definire la posizione dei punti che compongono il grafico. In questo senso quindi il plot e’ stato definito come un metodo di un axes. Nota che posso mettere piu’ di un axes su una singola figure. Anche questo e’ intuitivo, posso mettere 2 grafici sullo stesso foglio, poi i punti di un grafico saranno riferiti ad un paio di assi e quelli del secondo ad un altro paio di assi. Gli assi definiscono il sistema di riferimento “inerziale” che determina la posizione dei punti! Gli assi vengono costruiti su una figure tramite questo metodo: axes_1 = fig_1.add_axes([0.1,0.1,0.9,0.9]) Significa che axes_1 sara’ un rettangolo il cui: punto in basso a sx ha coordinate 0.1, 0.1 (rispetto a fig_1). Ovvero, la figure e’ un rettangolo, anche gli axes sono un rettangolo, il cui punto in basso a sinistra si trova nelle coordinate che sono il 10% delle x e il 10% delle y del punto in basso a sx della figure. punto in alto a dx ha coordinate 0.9,0.9 (rispetto a fig_1) In questo modo ho un grafico che e’ piu’ piccolo del “canvas” definito da fig_1. (nel video) non e’ chiaro come ha fatto l’esponente 2 sulla x. Io devo usare i comandi Latex Attenzione, io avevo messo il comando fig_1 = plt.figure(figsize=(5,4), dpi =100) in una cella diversa da dove facevo il axes.plot. Per questo non vedevo nulla!! Bisogna creare la figura nella stessa cella di Jupyter! Quindi ricapitolando: creo un oggetto figura ( me lo immagino come un foglio bianco di una certa dimensione) creo un oggetto axes che e’ ottenuto da un metodo della figura ( e’ il grafico vero e proprio, definito dagli assi sopra, sotto e destra e sinistra. Al suo interno posso poi mettere dei disegni tramite il metodo plot) tramite metodi di axes aggiungo delle caratteristiche come le label tra i metodi di un axes c’e’ plot (e altri tipi di grafico che potrei fare direttamente con plt). Chiamando un metodo che disegna da un axes, il grafico viene messo su questo axes. posso aggiungere piu’ di un grafico sullo stesso axes, basta chiamare piu’ volte un metodo che disegna sull’axes. nota che si deve fare un axes.plot per ognuno dei disegni che voglio compaiano nella figura! fig_1 = plt.figure(figsize=(5,4), dpi =100) # istanzio una FIGURA chiamata &#39;fig_1&#39; axes_1 = fig_1.add_axes([0.1,0.1,0.9,0.9]) # istanzio un AXES (axes_1), della figura &#39;fig_1&#39; axes_1.set_xlabel(&#39;Days new&#39;) # LABEL degli assi axes_1.set_ylabel(&#39;Days squared new&#39;) # LABEL degli assi axes_1.set_title(&#39;Ciao new&#39;) # TITOLO degli assi axes_1.plot(x_1, y_1, label = &#39;x/x$^2$&#39;) # GRAFICO 1 (all&#39;interno di axes_1) axes_1.plot(y_1, x_1, label = &#39;x^2/x&#39;) # GRAFICO 2 (all&#39;interno di axes_1) axes_1.legend(loc =0 ) # Loc=0 e&#39; la migliore location scelta da lui # 1=alt dx; 2=alto sx; 3=basso sx, 4 basso dx # oppure si fornisce una tupla di x e y dall&#39;angolo in basso a sinistra tu = (0.3, 0.4) # (tupla) questi valori sono in frazione rispetto alla grandezza totale, vedi sotto axes_1.legend(loc=tu ); # posizione della legenda Molte curve: versione veloce se devo fare un grafico veloce, basta che passo le x e y di tutti i grafici in ordine al plot, in questo modo verranno visualizzati tutti! Se non metto color=&#39;black&#39; di default le due curve avranno colori diversi plt.plot(x_1, y_1, x_1, y_1/3); # disegna le 2 funzioni Axes innestati Voglio ora inserire piu’ di un axes nella stessa figura. In pratica aggiungo un axes all’esempio precedente. Per fare questo devo creare un altro axes, proprio perche’ in questo caso i dati si riferiscono ad assi diverse che devono essere definite. Ricapitolando: nell’esempio sopra ci sono una curva blu e una arancione, sono comunque riferite allo stesso axes. Questi axes vanno da 0 a 25 (circa). se voglio inserire una figura nuova, i punti di questa figura saranno riferiti a un nuovo sistema di assi, ho quindi bisogno di inserire questi nuovi assi, creando un nuovo oggetto axes (con un nome diverso) dovro’ quindi indicare dove si collocano questi nuovi assi rspetto alla figure dovro’ anche indicare la loro grandezza, anche in questo caso rispetto alla figure Testo nella figura per inserire un testo nel disegno si usa il metodo text di axes. Le coordinate sono riferite all’axes e partono dal basso a sinistra. Nota che nel disegno sotto ho 2 axes, e il messaggio e’ riferito ad axes_2. Questo e’ ovvio perche’ e’ chiamato come un metodo di questo axes Nota inoltre che axes_2.text(0,40,&#39;message&#39;) fa uscire dal disegno, in quanto per il disegno l’asse delle y arriva solo fino a circa 25! nell’esempio di qui sotto: il primo axis contiene due curve il secondo axis contiene una curva fig_1 = plt.figure(figsize=(5,4), dpi =100) # FIGURA 1 assi_1 = fig_1.add_axes([0.1,0.1,0.9,0.9]) # ASSI_1 assi_1.set_xlabel(&#39;Days new&#39;) assi_1.set_ylabel(&#39;Days squared new&#39;) assi_1.set_title(&#39;Ciao new&#39;) assi_1.plot(x_1, y_1, label = &#39;x/x$^2$&#39;) # GRAFICO 1 (degli &quot;ASSI_1&quot;) assi_1.plot(y_1, x_1, label = &#39;x^2/x&#39;) # GRAFICO 2 (degli &quot;ASSI_1&quot;) assi_1.legend(loc =0 ) # Loc=0 e&#39; la migliore location scelta da lui ######## costruisco i secondi assi ##################### assi_2 = fig_1.add_axes([0.45, 0.45,0.4,0.3]) # ASSE 2 assi_2.set_xlabel(&#39;Days new&#39;) assi_2.set_ylabel(&#39;Days squared new&#39;) assi_2.set_title(&#39;Ciao dentro&#39;) assi_2.plot(x_1, y_1, &#39;r&#39;) # GRAFICO 2 # GRAFICO 1 (degli &quot;ASSI_2&quot;) #assi_2.text(0,40, &#39;Message&#39;) # testo assi_2.text(0,40, &#39;Message&#39;) # testo Text(0, 40, &#39;Message&#39;) subplots() Una griglia di grafici OCCHIO: plt.subplots()$\\neq$plt.subplot() (il primo termina in s) Il singolo comando subplots in pratica costruisce 2 oggetti: una figure una array di assi (ma un array di numpy puo’ contenere degli oggetti strani? non erano solo numeri? no! basta che in tutti gli oggetti siano dello stesso tipo: omogeneita’ degli array). devo quindi descrivere/inizializzare ognuno dei possibili axes dell’array, altrimenti ho solo gli assi senza nessun disegno dentro. In pratica e’ una specie di scorciatoia per ordinare facilmente degli axis in una figure in modo che siano esattamente alle posizioni della griglia che viene definita con il comando, per esempio indicando il numero di colonne e di righe. Altrimenti avrei potuto istanziare una figura, e istanziare tanti axes stando attento a metterli nel posto giusto all’interno della figura. Attenzione se voglio mettere degli axes aggiuntivi (oltre all’array di axes iniziale), posso farlo, occhio pero’ che si riferiranno tutti alla figure per quanto riguarda la posizione e non avranno un particolare ordinamento o forma. Dovro’ essere io a stare attento a metterli nel posto corretto e con la forma corretta! il comando plt.tight_layout() aiuta a non fare sovrapporre le label. Attento che devi usare il nome della figura corretto fig_2 Attento: non usare un nome gia’ usato per un altro axes, come axes_2 Attento: la dimensione del subplot e’ riferita al figsize, non all’axes di cui e’ subplot. Per questo trasborda! Attento: se costruisci un nuovo axes viene messo sopra l’axis genitore, e per questo lo (puo’) coprire. Di default un axes non e’ trasparente! fig_2 , axes_2 = plt.subplots(figsize=(8,4), nrows=1, ncols= 3) plt.tight_layout() # evita la sovrapposizione delle label axes_2[1].set_title(&#39;Plot 2&#39;) axes_2[1].set_xlabel(&#39;x&#39;) axes_2[1].set_ylabel(&#39;x quadro&#39;) axes_2[1].plot(x_1, y_1) # Nuovo AXES che non fa parte dell&#39;array creato con subplots axes_3 = fig_2.add_axes([0.45, 0.45,0.4,0.4]) axes_3.set_xlabel(&#39;Days new&#39;) axes_3.set_ylabel(&#39;Days squared new&#39;) axes_3.set_title(&#39;Ciao straripante&#39;) axes_3.plot(x_1, y_1, &#39;r&#39;) # GRAFICO 2 axes = fig_2.add_axes ([0.085,0.15,0.2,0.7]) axes.plot(x_1,y_1, &#39;co&#39;) axes.set_title(&#39;Dentro&#39;) Text(0.5, 1.0, &#39;Dentro&#39;) f , a = plt.subplots(figsize=(8,4), nrows=1, ncols= 3) plt.tight_layout() ############ Axes Centrale ############### a[1].set_title(&#39;Centrale&#39;) a[1].set_xlabel(&#39;x&#39;) a[1].set_ylabel(&#39;x quadro&#39;) a[1].plot(x_1, y_1) ############ Axes Ciao Dentro ############ a1 = f.add_axes([0.45, 0.45,0.4,0.4]) a1.set_xlabel(&#39;Days now&#39;) a1.set_ylabel(&#39;Days squared new&#39;) a1.set_title(&#39;Tra centro e sinistra&#39;) a1.plot(x_1, y_1, &#39;r&#39;) # GRAFICO 2 della figura centrale ############ Axes Sinistro ############### a[0].set_title(&#39;Sinistra&#39;) a[0].set_xlabel(&#39;x&#39;) a[0].set_ylabel(&#39;x quadro&#39;) a[0].plot(x_1, -y_1,&#39;g&#39;) ############ Axes Piccolo sinistra ###### a0 = f.add_axes([0.1, 0.25,0.2,0.2]) a0.set_xlabel(&#39;Days old&#39;) a0.set_ylabel(&#39;Days squared new&#39;) a0.set_title(&#39;Piccolo Sinistra&#39;) a0.plot(x_1, y_1, &#39;r&#39;) # GRAFICO 2 della figura centrale [&lt;matplotlib.lines.Line2D at 0x2de66e3a190&gt;] Colori e Apparenza I colori di default sono: r = red c = cyan m = magenta y = yellow k = black w = white Inoltre color=”0.75” crea un 75% gray (e’ una percentuale di black) si possono usare i colori con hexcodes color=”#eeefff” si possono usare i colori tipo color=”burlywood” che si trovano a https://en.wikipedia.org/wiki/Web_colors lw come gnuplot, ma devo mettere l’uguale, p.es. lw=2 ls ‘-.’ si trovano qui: https://matplotlib.org/3.1.0/gallery/lines_bars_and_markers/linestyles.html marker sono i punti: https://matplotlib.org/3.3.3/api/markers_api.html markersize = grandezza del punto markerfacecolor = colore di riempimento del punto makeredgecolor = colore del bordo del punto fig_3 = plt.figure(figsize=(6,4)) axes_3 = fig_3.add_axes([0,0,1,1]) axes_3.plot(x_1, y_1, color=&#39;navy&#39;, alpha=0.75, lw=2, ls =&#39;-.&#39;, marker = &#39;o&#39;, markersize=7, markerfacecolor =&#39;y&#39;, markeredgecolor=&#39;k&#39;, markeredgewidth=2) [&lt;matplotlib.lines.Line2D at 0x2de66eaa970&gt;] Grandezza degli assi e background I comandi per gestire gli assi assomigliano a quelli di gnuplot, ma solo un po’ piu’ “verbose”, in cui si deve scrivere di piu’. Possimo anche mettere una griglia e il background color. axes_3.set_xlim([0,3]) limiti asse x axes_3.grid(True, color=&#39;0.6&#39;, dashes=(5,2,1,2)) caratteristiche della griglia (NON dello sfondo!), dashes mette delle linee tratteggiate attraverso il disegno. Quindi qui sono le righe che partono da un tic e arrivano dall’altra parte del disegno axes_3.set_facecolor(&#39;#FAEBD7&#39;) colore di sfondo fig_3 = plt.figure(figsize=(3,4) ) axes_3 = fig_3.add_axes([0,0,1,1]) axes_3.plot(x_1, y_1, color=&#39;navy&#39;, alpha=0.75, lw=2, ls =&#39;-.&#39;, marker = &#39;o&#39;, markersize=7, markerfacecolor =&#39;y&#39;, markeredgecolor=&#39;k&#39;, markeredgewidth=2) axes_3.set_xlim([0,3]) axes_3.set_ylim([0,25]) #axes_3.grid(True, color=&#39;0.6&#39;, dashes=(5,2,1,2)) # mettiamo una griglia non lasciamo vuoto axes_3.grid(False, color=&#39;r&#39;, dashes=(0,2,1,2)) #axes_3.set_facecolor(&#39;#FAEBD7&#39;) axes_3.set_facecolor(&#39;w&#39;) Salvare una figura a file strano quando lavoravo con Seaborn sembrave che il save dovesse avvenire nella stessa cella dove si faceva il disegno. Basta mettere il nome dell’estensione e lui salva correttamente nel formato corrispondente fig_3.savefig(&#39;ultimoPlot.png&#39;) Pandas Qui usiamo l’ICE CREAM data table (che diventera’ un DataFrame). Ho copiato il dataframe del video. Assegno dei nomi alle colonne del csv, mentre leggo il file: ics_df = pd.read_csv(&#39;icecream.csv&#39;, names=[&#39;temps&#39;, &#39;sales&#39;]) . Nota che io ho usato i nomi sales e temps (temperatures). Lui li aveva con la prima lettera in maiuscolo. Temp e’ in Farenheit, e sales e’ in unita’ di gelato. Se non usassi il parametro names=... lui prenderebbe la prima riga e la trasformerebbe nei nomi delle colonne (e i valori della prima riga non sarebbero accessibili)! Osservazione: il metodo dei DataFrame sort_values(by=&#39;temps&#39;) lavora inplace, quindi modifica il df! ics_df = pd.read_csv(&#39;icecream.csv&#39;, names=[&#39;temps&#39;, &#39;sales&#39;]) ics_df.head() temps sales 0 37 292 1 40 228 2 49 324 3 61 376 4 72 440 Attento sort_values() lavora inplace ics_df = ics_df.sort_values(by=&#39;temps&#39;) # LAVORA INPLACE A questo punto lui fa delle cose che sembrano non necessarie. Prende e converte il DataFrame in un array di Numpy. Poi prende e scrive le x e le y da questo array di numpy. In effetti ho notato in una sezione sotto che alle volte e’ davvero meglio avere dei numpy array invece che i dataframe, in particolare per evitare dei valori strani sull’asse delle x. # con numpy array ############### # np_arr = ics_df.values # prende solo i valori, rimuove le etichette # x_2 = np_arr[:,0] # seleziono colonna 0 # y_2 = np_arr[:,1] # seleziono colonna 1 ################################### # Alternativa: x_2 = ics_df.temps # non sono array di np, ma serie di Pandas vanno bene lo stesso y_2 = ics_df.sales # ricorda puoi usare l nome di una colonna per selezionare tutta le colonna come se fosse un attributo #x_2 = np.array(ics_df.temps) # NON serve... ora, ma in alcuni casi si&#39; #y_2 = np.array(ics_df.sales) # NON serve... ora, ma in alcuni casi si&#39; ok ma fino a qui, dove ha usto il fatto che sia Pandas? fig_4 = plt.figure(figsize=(6,4)) axes_4 = fig_4.add_axes([0,0,1,1]) # prendo tutto lo spazio, dall&#39;angolo in basso a sx a quello in alto a dx axes_4.set_title(&#39;da Pandas: IceCream&#39;) axes_4.set_xlabel(&#39;temp&#39;) axes_4.set_ylabel(&#39;sales&#39;) axes_4.plot(x_2, y_2, marker=&#39;+&#39;); # ho messo sui punti le crocette come in Gnuplot Annotare la figura Se voglio mettere delle annotazioni nel grafico, come per esempio delle frecce, devo usare un metodo degli axes chiamato annotate. Vediamo nel dettaglio il comando: axes_4.annotate(&#39;Good Month&#39;, xy=(83, 536), xytext=(60,520), arrowprops= dict(facecolor=&#39;black&#39;, shrink=0.0, width=0.5)) &#39;Good Month&#39; e’ il testo che viene inserito xy=(83,536) e’ il punto di arrivo della freccia xytext=(60,520) e’ il punto di partenza del testo orizzontale All’interno di arrowprops si hanno vari parametri (si deve passare un dizionario con tutti gli argomenti) facecolor= ‘black’ shrink=0.5 indica quanto piu’ corta deve essere la freccia, rispetto alla lunghezza massima che va dalla fine del testo al punto di arrivo della freccia. width=0.5 possiamo anche allargare la larghezza fig_4 = plt.figure(figsize=(6,4)) axes_4 = fig_4.add_axes([0,0,1,1]) # prendo tutto lo spazio, dall&#39;angolo in basso a sx a quello in alto a dx axes_4.set_title(&#39;da Pandas: IceCream&#39;) axes_4.set_xlabel(&#39;temp&#39;) axes_4.set_ylabel(&#39;sales&#39;) axes_4.plot(x_2, y_2) axes_4.annotate(&#39;Good Month&#39;, xy=(83, 536), xytext=(60,520), arrowprops= dict(facecolor=&#39;black&#39;, shrink=0.0, width=0.5)) Text(60, 520, &#39;Good Month&#39;) bar() Barchart sotto il grafico bar() e’ un metodo di plt Se voglio fare aggiungere anche le barchart sotto il grafico, basta disegnare ANCHE loro! Attento ho fatto 2 plot: il primo e’ dato da axes_4.plot(x_2, y_2) ed e’ passato come un metodo degli assi il secondo e’ un grafico veloce ed e’ una funzione di matplotlib: plt.bar(x_2, y_2, width=1.5); fig_4 = plt.figure(figsize=(6,4)) axes_4 = fig_4.add_axes([0,0,1,1]) # prendo tutto lo spazio, dall&#39;angolo in basso a sx a quello in alto a dx axes_4.set_title(&#39;da Pandas: IceCream&#39;) axes_4.set_xlabel(&#39;temp&#39;) axes_4.set_ylabel(&#39;sales&#39;) axes_4.plot(x_2, y_2) axes_4.annotate(&#39;Good Month&#39;, xy=(83, 536), xytext=(60,520), arrowprops= dict(facecolor=&#39;black&#39;, shrink=0.0, width=0.5)) plt.bar(x_2, y_2, width=1.5); Impulsi stem() e proprieta’ setp() In gnuplot mettevo with impulses quando volevo che il grafico avesse delle linee verticali che partono dall’asse x e raggiungono ogni punto. Il comando descritto qui sopra bar() non e’ l’ideale per ottenere questo risultato in quanto la larghezza dell’impulso puo’ creare problemi, meglio usare la funzione: plt.stem() mentre posso decidere di colorare l’asse sotto tramite la funzione set property: plt.setp() Questa funzione puo’ essere usata per vari oggetti! fig_4 = plt.figure(figsize=(6,4)) axes_4 = fig_4.add_axes([0,0,1,1]) # prendo tutto lo spazio, dall&#39;angolo in basso a sx a quello in alto a dx axes_4.set_title(&#39;da Pandas: IceCream&#39;) axes_4.set_xlabel(&#39;temp&#39;) axes_4.set_ylabel(&#39;sales&#39;) axes_4.plot(x_2, y_2) axes_4.annotate(&#39;Good Month&#39;, xy=(83, 536), xytext=(60,520), arrowprops= dict(facecolor=&#39;black&#39;, shrink=0.0, width=0.5)) markerline, stemlines, baseline = plt.stem(x_2, y_2, &#39;-.&#39;) plt.setp(baseline, &#39;color&#39;, &#39;r&#39;, &#39;linewidth&#39;, 2) [None, None] TeX - regular expressions possiamo usare Latex per scriver formule matematiche usando per esempio $\\frac{1}{2}$ IMPORTANTE nota che nel tutorial ha usato: r&#39;$\\alpha \\beta \\gamma$&#39; non ha semplicemente messo ‘’ perche’ cosi’ prende le regular expression, come il dollaro e lo slash. Ovvero la scrittura r’ciao $\\frac{2}{3}’ crea una stringa che pero’ ha delle regular expression che vengono valutate ed eseguite. basta poi ricordare i comandi di Latex il metodo .text degli ‘axes’ mette ha all’inizio le coordinate (separate da una virgola), poi una virgola con il testo da inserire. fig_5 = plt.figure(figsize=(5,4), dpi=100) axes_5 = fig_5.add_axes([0.1, 0.1, 0.9, 0.9]) # costruisco un axes axes_5.text(0,23, r&#39;$\\alpha~ \\beta~ \\gamma ~ \\frac{1}{2} ~\\Sigma$&#39;) # prima le coordinate del testo, poi il testo axes_5.plot(x_1, y_1) [&lt;matplotlib.lines.Line2D at 0x2de66ff15e0&gt;] Istogrammi plt.hist() Alcuni argomenti utili per gli istogrammi: stacked=True Simuliamo probabilita’ di lancio di 2 dadi. Ci sono 11 possibili valori per la somma: 1+1 =2 I 1+2 =3 II 1+3 =4 III 1+4 =5 IV 1+5 =6 V 1+6 =7 VI 2+6 =8 VII (nota che tutti gli altri valori di (2+qualcosa) danno dei risultati gia’ ottenuti) 3+6 =9 VIII 4+6 =10 IX 5+6 =11 X 6+6 =12 XI Come altri parametri: density=True mostra la frequenza di ogni bin (se e’ falso mostra il conteggio) stacked=True cosa fa? Attento: ricorda che il numero di bins puo’ portare a risultati MOLTO fuorvianti. Per esempio se scegliamo bins=7 otteniamo un oggetto bicefalo attorno al centro. Se invece scegliamo bins=11 otteniamo una campana! arr_1 = np.random.randint(1,7,5000) # genera 5000 numeri interi tra 1 e 6 arr_2 = np.random.randint(1,7,5000) # genera 5000 numeri interi tra 1 e 6 arr_3 =arr_1+arr_2 arr3ok = arr_3 plt.hist(arr3ok, bins= 7, density=True, stacked =False); plt.hist(arr_3, bins= 11, density=True, stacked =True); ax[0].hist() Axes e istogrammi Qui sotto provo a combinare axes e istogrammi. Ho supposto di poter usare il metodo hist() direttamente su un asse invece che dover usare un plt.hist, ovvero: axes.hist(...) Funge! fig , ax = plt.subplots(figsize=(8,4), nrows=1, ncols= 2) #plt.tight_layout() ax[0].hist( arr_3, bins= 11, density=True, stacked =True); ax[1].hist( arr_3, bins= 11, density=False, stacked =False); altri argomenti che si possono passare: Range deve essere una tupla con il range di cui si e’ interessati cumulative =True costruisce la CDF (cumulative distribution function) dati i valori. Attento non me lo prendeva (diceva qualcosa riguardo l’oggetto kernel). Non ho lanciato tutte le altre celle, ma solo quelle iniziali con gli header e quelle della cella Istogramma histtype= &#39;step&#39; genera un grafo con le linee (ma vuoto) color = &#39;orange&#39; colora di arancione… orientation = &#39;horizontal&#39; gira di 90 gradi l’istogramma posso combinare anche due istogrammi insieme come con gli altri plot. plt.hist(arr_3, bins= 11, density=True, stacked =True, cumulative=True, histtype=&#39;step&#39;, color=&#39;blue&#39;, orientation= &#39;horizontal&#39;); Bar charts Che differenza c’e’ tra un grafo a barre e un istogramma? de facto nell’istogramma si mettono le frazioni e le “barre” sono attaccate l’una all’altra. In un bar chart invece si hanno i numeri e le barre non sono attaccate l’una all’altra, questo perche’ sull’asse delle x spesso non si hanno dei valori numerici, ma categorici (come nell’esempio riportato sotto, dove l’ordine delle colonne e’ sostanzialmente arbitrario). Per un grafo a barre, si chiama la funzione seguente: plt.bar(spc, m_eng,width=larghezza, label=&#39;maschi&#39;, edgecolor =&#39;k&#39;) il primo argomento contiene la lista/tupla con i nomi che appaiono sull’asse delle x (dato che spesso lo usiamo per variabili categoriche dobbiamo indicare le label), oppure le posizioni delle barre (se ho le posizioni dovro’ poi aggiungere le label sull’asse) Attento se nella prima tupla ci sono dei nomi, allora le loro posizioni sono equispaziate automaticamente. Se io aggiungo un altro bar chart, questo secondo viene messo dopo quelle gia’ esistenti. Attento se invece nella prima tupla ci sono dei float (che quindi definisce la posizione delle barre), allora facendo un secondo plot, quest’ultimo segue le proprie posizioni. Attento pui mettere 2 bar chart, uno con variabili categoriche e uno con float. Le posizioni delle categoriche sono messe automaticamente in integer (che partono quindi da zero). Nell’esempio qui sotto, la barra di nuclear ha posizione sull’asse delle x uguale a 0, hydro e’ in posizione 1, … il secondo argomento contiene l’array che con le altezze della barchart yerr ??? serve per la barra che indica l’errore, ed e’ un array che deve contenere tanti oggetti quante sono le barre width larghezza della barra (altrimenti da’ errore? ) label non la vedo… scritta forse bisogna attivarla. Anche nel video non fungeva ## energia francese x = [&#39;nuclear&#39;, &#39;hydro&#39;, &#39;coal&#39;, &#39;gas&#39;, &#39;solar&#39;, &#39;wind&#39;, &#39;other&#39;] per_1 = [71,10,3,7,2,4,3] # percentuale variance = [8,3,1,3,1,2,1] # varianza per anno plt.bar(x, per_1, color=&#39;purple&#39;,yerr=variance, label=&#39;prova&#39;) &lt;BarContainer object of 7 artists&gt; ## energia francese x = [&#39;nuclear&#39;, &#39;hydro&#39;, &#39;coal&#39;, &#39;gas&#39;, &#39;solar&#39;, &#39;wind&#39;, &#39;other&#39;] per_1 = [71,10,3,7,2,4,3] # percentuale variance = [8,3,1,3,1,2,1] # varianza per anno plt.bar(x, per_1, color=&#39;purple&#39;,yerr=variance, label=&#39;prova&#39;) y = [el + &#39; &#39; for el in x] z = [&#39;test1&#39;, &#39;test2&#39;, &#39;test3&#39;] z2 = [1, 2, 10] per_2 = [34,43,21] plt.bar(z2, per_2, color=&#39;red&#39;, label=&#39;prova&#39;) &lt;BarContainer object of 3 artists&gt; y [&#39;nuclear &#39;, &#39;hydro &#39;, &#39;coal &#39;, &#39;gas &#39;, &#39;solar &#39;, &#39;wind &#39;, &#39;other &#39;] Bar Chart affiancate Qui sotto mettiamo due bar chart affiancate una da parte all’altra. In questo modo possiamo confrontare dati diversi. E’ fondamentale che la posizione dell’array che definisce l’asse delle x della seconda bar chart sia spostato rispetto all’asse delle x della prima bar chart di una quantita’ tale da non fare sovrapporre (a meno di volerlo). Per esempio di puo’ usare lo stesso array maggiorato della larghezza della barchart! m_eng = (76,85,86,88,93) # percentuale maschi ingegneri f_eng = (24,15,14,12,7) # femmine spc = np.arange(5) larghezza =0.45 plt.bar(spc , m_eng,width=larghezza, label=&#39;maschi&#39;, edgecolor =&#39;k&#39;) plt.bar(spc+larghezza, f_eng,width=larghezza, label=&#39;femmine&#39;, edgecolor =&#39;k&#39;) #plt.xticks(spc + larghezza/2, (&#39;Aero&#39;, &#39;Chem&#39;, &#39;Civil&#39;, &#39;Elect&#39;, &#39;Mec&#39;)) plt.xticks(spc , (&#39;Aero&#39;, &#39;Chem&#39;, &#39;Civil&#39;, &#39;Elect&#39;, &#39;Mec&#39;)) ; # altrimenti lo mette a meta&#39; strada del primo istogramma Bar Chart impilate (stacked) Qui mettiamo le barre una sopra l’altra. Diamo un’occhiata alla list comprehension che viene usata: ind = [x for x, _ in enumerate(t_type)] enumerate restituisce delle coppie: posizione, oggetto. Non ci serve l’oggetto ma solo la posizione, qunidi non spreco una variabile y, metto _ Prendi tutte le posizioni che ci sono nell’oggetto t_type questa volta la label e’ apparsa nella legenda. ATTENTO il parametro bottom dice cosa c’e’ sotto di questa barchart. In particolare possiamo indicare un array, o anche una somma di array come nell’esempio di cui sotto. Se mettiamo un array che viene disegnato nella barchart, allora stiamo in pratica impilando il nuovo barchart sopra quello dell’altro array ############# DATI ###################### t_type= [&#39;kind&#39;, &#39;elem&#39;, &#39;sec&#39;, &#39;special&#39;] print(type(t_type)) m_teach = np.array([2,20,44,14]) f_teach = np.array([98,80,56,86]) n_teach = np.array([12,14,13,15]) ind = [x for x,_ in enumerate(t_type)] # list comprehension. Vedi sopra per come si legge plt.bar(ind, n_teach, width=larghezza, label=&#39;nuovo&#39;, bottom=f_teach+m_teach) # posso metterne piu&#39; di uno sotto plt.bar(ind, m_teach, width=larghezza, label=&#39;maschi&#39;, bottom=f_teach) # posso metterne piu&#39; di uno sotto plt.bar(ind, f_teach, width=larghezza, label=&#39;femmine&#39;) plt.legend(loc=&#39;lower right&#39;); # non ideale.... #plt.legend(loc=0); # manco questo... &lt;class &#39;list&#39;&gt; Torte - Pie chart, plt.pie() Vediamo i diagrammi a torta. Per questi si usa il comando: wedges, texts, autotexts = plt.pie(poke_num, explode=explode, labels=types, colors=colors, autopct=&#39;%1.0f%%&#39;, shadow=True, startangle=140, textprops =dict(color=&#39;w&#39;)) Dal punto di vista sintattico la funzione pie() restituisce 3 oggetti: le wedges (gli spicchi o cunei del diagramma a torta). i texts gli autotext In questo caso abbiamo prima costruito la figure, poi gli axes ed infine abbiamo chiamato la funzione pie. E’ un po’ diverso dal solito quando si usava un metodo dell’axes. Nota che in un diagramma a torta, intuitivamente, i valori di larghezza (angolo) associati ad ogni fetta vengono convertiti in percentuali dell’angolo giro. Questo perche’ ci si aspetta che tutti i valori di un array riempiano tutto il cerchio. explode a questa keyword si deve passare un array di float con tanti ingressi quante sono le fette. Il valore di ogni ingresso dice di quanto viene “estratta” la fetta alla posizione corrispondente, vedi l’esempio sotto. nell’esempio sotto ci sono 2 array: types e pole_num, questi devono avere il medesimo numero di ingressi. labels=types e’ un parametro che indica le etichette associate ad ogni fetta autopct indica come vengono arrotondati i numeri associati alle larghezze, gli si deve passare come valore una stringa che indica un formato. shadow=true e’ il parametro che dice se mettiamo l’ombra colori ha usato un trucco notevole, ha fatto scrivere dei valori in formato RGB tramite il generatore di numeri casuali. Tre numeri indicano un colore, e lui indicando il range dei colori tra [0, 0.5] ha fatto si’ che vengono scuri. Ha scelto i colori scuri perche’ la scritta viene in bianco! Occhio, avevo fatto un errore di sintassi ma non semplice da osservare. Nell’array types che contiene dei nomi tra virgolette, in un caso, quando andavo a capo ho dimenticato di mettere una virgola tra un nome e l’altro e lui mi ha preso solo uno dei nomi bbox_to_anchor = (1,0,0.5,1) serve per spostare di 1 e 1/2 a destra della piechart (???) import random fig_6 = plt.figure(figsize=(8,5)) axes_6 = fig_6.add_axes([0.1,0.1,0.9,0.9]) #Vogliamo un diagramma a torte types = [&#39;water&#39;, &#39;normal&#39;, &#39;flying&#39;, &#39;grass&#39;, &#39;psychic&#39;,&#39;bug&#39;, &#39;fire&#39;, &#39;poison&#39;, &#39;ground&#39;,&#39;rock&#39;,&#39;fighting&#39;, &#39;dark&#39;, &#39;steel&#39;, &#39;electric&#39;,&#39;dragon&#39;,&#39;fairy&#39;,&#39;ghost&#39;,&#39;ice&#39;] poke_num =[133, 109, 101, 98, 85, 77, 68, 66, 65, 60, 57, 54, 53, 51, 50, 50, 46, 40] colors = [] for i in range(18): # per il testo bianco genero i coloi delle fette in modo che siano scuri rgb = (random.uniform(0,.5) , random.uniform(0,.5) , random.uniform(0,.5) ) colors.append(rgb) explode = [0] * 18 # ho creato una lista di 18 zeri (non mi ricordavo questo modo!) explode[0] = 0.2 # esplodi la prima fetta ma solo di 0.2 #print(len(types)); #print(len(poke_num)); wedges, texts, autotexts = plt.pie(poke_num, explode=explode, labels=types, colors=colors, autopct=&#39;%1.0f%%&#39;, shadow=True, startangle=140, textprops =dict(color=&#39;w&#39;)) plt.legend(wedges, types, loc=&#39;right&#39;, bbox_to_anchor = (1,0,0.5,1)); # sposto dalla piechart Serie Temporali Qui vediamo come fare un grafico con una serie temporale in cui i vari punti sono etichettati con un timestamp. Puo’ essere necessario togliere dei giorni particolari e risulta piu’ comodo sapere la data piuttosto che trovare il punto corrispondente della time series. Il database usato viene da Yahoo riguardo i dati di google, GOOG.csv. (non e’ esattamente come mostrato nel video ma si trova in fretta). Per trovarlo cerca con google “yahoo google stock”, seleziona le date e fai download (nota che la frequenza e’ giornaliera). All’inizio si carica il file con read_csv di Pandas, poi si trasforma la tabella in un array di numpy (sono tutti valori numerici). Lui usa un metodo dei DataFrame di Pandas che io non uso mai: tp_numpy(). Io invece faccio semplicemente np.array(). Ho provato a fare un giro piu’ semplice, cercando di plottare i dati direttamwente DAL DataFrame, di cui seleziono le colonne volute (ma avendo prima selezionato le righe, vedi sotto). Sfortunatamente sull’asse delle x vengono dei valori sballati come tics, il grafico e’ pero’ corretto. Questo e’ probabilmente il motivo per cui lui preferisce trasformare tutto in array di Numpy. Scrubbing data: per esempio vogliamo togliere alcune vacanze, ha controllato due date che sono vacanze e vuole escluderlo. Usa datetime. La funzione datetime.datetime(2020,5,25) crea una data in un oggetto specifico, che puo’ poi essere trasformato a seconda delle esigenze, p.es g/m/a o m/g/a ecc. Poi costruisce un array di date che vanno da una data iniziale ad una finale, tramite un metodo di pandas: pd.bdate_range, si puo’ passare il parametro frequency freq =&#39;C&#39; in questo caso, ma no so cosa sia il valore ‘C’! holidays e’ il nome di un altro parametro che appunto corrisponde alle vacanze e possiamo passare un array/tupla contentente dei dati in formato datetime che vengono riconosciuti. ATTENTO la mia versione non riconosce questo parametro. Ho riscritto tutto e ora funge. Problema: non so quando ha preso lui le date da Yahoo, io ho piu’ giorni. Problema2 se uso tutti questi giorni, i tics che vengono segnati sono troppi e sotto l’asse viene un guazzabuglio di linee. Devo modificare per ottenere le date corrette. import datetime goog_data = pd.read_csv(&#39;GOOG.csv&#39;) # IMPORTO il file GOOG.csv che ho salvato nella dir corrente goog_data_np = goog_data.to_numpy() # trasformo in np.array #goog_data_np =np.array(goog_data) # modo alternativo di trasformare goog_cp = goog_data_np[:,4] holidays = [datetime.datetime(2020,5,25) , datetime.datetime(2020,8,19) ] # creo una lista con due date che saranno vacanze date_arr = pd.bdate_range(start =&#39;5/20/2020&#39; , end =&#39;8/19/2020&#39; , freq =&#39;C&#39;, holidays = holidays) date_arr_np = date_arr.to_numpy() goog_data.head(3) Date Open High Low Close Adj Close Volume 0 2019-08-21 1193.150024 1199.000000 1187.430054 1191.250000 1191.250000 740700 1 2019-08-22 1194.069946 1198.011963 1178.579956 1189.530029 1189.530029 947500 2 2019-08-23 1181.989990 1194.079956 1147.750000 1151.290039 1151.290039 1687000 Selezionare righe secondo delle date Seguo questo esempio per selezionare le date: https://stackoverflow.com/questions/29370057/select-dataframe-rows-between-two-dates Creo una mask per selezionare le date che voglio e che devono seguire quelle indicate nel bdate_range. In pratica creo una maschera, ovvero un array di bool che poi posso passare a loc! In questo modo solo gli ingressi in cui la maschera e’ vera vengono selezionati. Problema I: devo paragonare delle date… in formati magari diversi Soluzione I uso pd.to_datetime() che e’ una goduriosa funzione di Pandas che converte una stringa in un oggetto di tipo datetime. Questo oggetto e’ una data ed e’ possibile paragonare due datetime per vedere chi viene prima o dopo! Questa funzione e’ particolarmente VANTAGGIOSA in quanto riconosce tanti tipi diversi di formato in cui possiamo scrivere una data e li converte i un unico oggetto! Alternativa usa parse_dates (vedi il Finance Module) Una volta ottenuto un modo per paragonare le date posso creare una lista con valori booleani in cui seleziono le date (basta un loop), chiamo questo oggetto maschera Problema II la maschera cosi’ creata non e’ un oggetto iterabile che si possa mettere nel metodo loc di pandas. Devo tasformarlo in un oggetto non iterabile Soluzione II basta costruire una funzione che prende come input qualcosa e quando lo sputa in output gli metto un tuple davanti! DUBBIO ehi ma nel codice non ho usato la tupla, anzi se dove faccio finanza metto la tupla mi da errore, sembra che una Series di pandas vada bene Attenzione pero’ la maschera cosi’ creata e’ un oggetto mutabile e questo non puo’ essere usato come ingresso della funzione loc (di PANDAS) perche’ questa necessita oggetti immutabili da cui puo’ estrarre una hashtable. link utili: loc: https://stackoverflow.com/questions/29370057/select-dataframe-rows-between-two-dates to_datetime: https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.to_datetime.html convertire lista in tupla: https://www.geeksforgeeks.org/python-convert-a-list-into-a-tuple/ # PROBLEMA I # qui sotto prendo la colonna Date del dataFrame # poi converto i valori ivi contenuti in un oggetto di tipo datetime con to_datetime # a questo punto li paragono ai valori entro cui voglio che siano le date, sempre # sfruttando la funzione di pandas pd.to_datetime mask = ( ( pd.to_datetime(goog_data[&#39;Date&#39;]) &gt;= pd.to_datetime(&#39;5/20/2020&#39;)) &amp; ( pd.to_datetime(goog_data[&#39;Date&#39;]) &lt;= pd.to_datetime(&#39;8/19/2020&#39;)) ) # PROBLEMA II # l&#39;oggetto mask non e&#39; di tipo immutabile e quindi non puo&#39; essere usato come iteratore # devo trasformarlo in unoggetto immutabile def convert(list): return tuple(list) mask_t= convert(mask) #print(type(mask_t) , &#39;tipo maschera&#39;) # controllo #print(len(goog_data.loc[mask])) # controllo che i due oggetti abbiano lo stesso numero di righe new = goog_data.loc[mask] # loc NON lavora inplace &lt;=================== new_np = new.to_numpy() goog_cp = new_np[:,4] # # PROBLEMA III # Costruisco un array con le date corrispondenti in modo che io possa poi disegnarle fig_7 = plt.figure(figsize=(8,5)) # creiamo la figura/canvas come al solito axes_7 = fig_7.add_axes([0.1,0.1, 0.9, 0.9]) # il grafico non copre tutta la figura, lasciamo un po&#39; di padding plt.plot(date_arr_np, goog_cp); #plt.plot(new.Date, new.Close) # questo fa vedere sbagliato i tics sotto Tabelle Questo non e’ cosi’ interessante, la cosa che trovo piu’ utile e’ come girare le date sull’asse delle x. Copio il pezzo di notebook scritto da Banas qui sotto: # Format column data to 2 decimals goog_data[&#39;Open&#39;] = pd.Series([round(val, 2) for val in goog_data[&#39;Open&#39;]], index = goog_data.index) goog_data[&#39;High&#39;] = pd.Series([round(val, 2) for val in goog_data[&#39;High&#39;]], index = goog_data.index) goog_data[&#39;Low&#39;] = pd.Series([round(val, 2) for val in goog_data[&#39;Low&#39;]], index = goog_data.index) goog_data[&#39;Close&#39;] = pd.Series([round(val, 2) for val in goog_data[&#39;Close&#39;]], index = goog_data.index) goog_data[&#39;Adj Close&#39;] = pd.Series([round(val, 2) for val in goog_data[&#39;Adj Close&#39;]], index = goog_data.index) # Get most recent last 5 days of stock data stk_data = goog_data[-5:] stk_data # Define headers col_head = (&#39;Date&#39;,&#39;Open&#39;,&#39;High&#39;,&#39;Low&#39;,&#39;Close&#39;,&#39;Adj Close&#39;,&#39;Volume&#39;) stk_data_np = stk_data.to_numpy() stk_data_np # Add padding around cells in table plt.figure(linewidth=2, tight_layout={&#39;pad&#39;:.5}, figsize=(5,3)) # Get rid of axes and plot box axes_8 = plt.gca() axes_8.get_xaxis().set_visible(False) axes_8.get_yaxis().set_visible(False) plt.box(on=None) # np.full returns an array filled with 0.1 # cm is a colormap object we are using to use a default blue color # matplotlib.org/3.1.0/tutorials/colors/colormaps.html ccolors = plt.cm.Blues(np.full(len(col_head), 0.2)) # Receives data, loc, list of column headers, column header color as array of colors # You can also add rowLabel, rowColours, rowLoc: Text alignment the_table = plt.table(cellText=stk_data_np, loc=&#39;center&#39;, colLabels=col_head, colColours=ccolors) # Set table font size the_table.set_fontsize(14) the_table.scale(3, 2.5) C:\\ProgramData\\Anaconda3\\lib\\site-packages\\IPython\\core\\pylabtools.py:132: UserWarning: Tight layout not applied. The left and right margins cannot be made large enough to accommodate all axes decorations. fig.canvas.print_figure(bytes_io, **kw) ScatterPlot Qui ci sono dei dati relativi al Coronavirus. E’ importante che ci sia uniformita’ di grandezza per quanto riguarda gli array che vanno plottati: ci sono 26 nazioni ci sono 26 tassi di mortalita’ ci sono 26 valori di casi confermati giornalieri ci sono 26 dimensioni dei punti Nota che i questo caso non costruisco la figura e poi gli assi. Questo perche’ viene fatto automaticamente dal comando plt.scatter. Ci sono 2 vie per ottenere lo stesso grafico: costruisco la fig, e gli assi e uso scatter come metodo sull’asse creato uso plt.scatter e lui automaticamente crea gli assi! Argomenti dello scatterplot: prima si mettono i valori dell’asse delle x (e’ un np.array) poi l’array per i valori dell’asse delle y (anche questo un np.array lungo quanto quello sopra) s per size (dei punti): NON e’ come gnuplot che accettava le abbreviazioni, qui il parametro si chiama SOLO s! c per color (dei punti) alpha e’ in pratica il livello di trasparenza, in questo caso e’ fondamentale in quanto alcuni punti andranno a sovrapporsi # Numpy array con i nomi delle nazioni cnt_arr = np.array([&#39;Australia&#39;,&#39;Brazil&#39;,&#39;Canada&#39;,&#39;Chile&#39;,&#39;France&#39;,&#39;Germany&#39;,&#39;Greece&#39;, &#39;Iceland&#39;,&#39;India&#39;,&#39;Iran&#39;,&#39;Italy&#39;,&#39;Mexico&#39;,&#39;New Zealand&#39;,&#39;Nigeria&#39;, &#39;Norway&#39;,&#39;Pakistan&#39;,&#39;Peru&#39;,&#39;Russia&#39;,&#39;Saudi Arabia&#39;,&#39;Singapore&#39;, &#39;South Africa&#39;,&#39;Spain&#39;,&#39;Sweden&#39;,&#39;Turkey&#39;,&#39;UK&#39;,&#39;US&#39;]) # Tasso mortalita per 100k casi Coronavirus dr_arr = np.array([1.8,53,24.5,56.5,45.4,11.2,2.2, 2.8,4,24.6,58.6,46.3,.5,.5, 4.9,2.9,83.3,11,10.4,.5, 21.5,61.6,56.9,7.3,62.4,52.9]) # Numero giornaliero di casi confermati (Tests) test_arr = np.array([110,7197,600,1862,1636,1103,35, 10,295,1658,1226,2490,8,243, 48,1395,1101,4447,1443,280, 2830,1602,447,1205,1546,24988]) # Dimensione del punto dei casi confermati cc_arr = np.array([24236,3456652,125408,390037,256534,229706,7684, 2035,2836925,350279,255278,537031,1654,50488, 10162,290445,549321,935066,302686,56031, 596060,370867,85411,253108,323008,5529824]) cc_arr_sm = cc_arr/1000 # rimpicciolisce a dimensione dei punti (?) color_arr= np.random.rand(26) # Se faccio questi sotto vengono aggiunti ad una figura aggiuntiva, non al mio scatterplot # questo perche&#39; ho provato ad usare la strada per cui prima faccio la figura, aggiungo gli assi # e il disegno viene con un metodo! #plt.title(&#39;Mortalita per 100k vs. Casi confermati&#39;) #plt.xlabel(&#39;Mortalita per 100k&#39;) #plt.ylabel(&#39;Casi confermati&#39;) #plt.scatter(dr_arr, test_arr, s=cc_arr_sm, c=color_arr,alpha=0.5 ) #plt.figure(figsize=(8,5)) fig_13 = plt.figure(figsize=(8,5)) axes_13 = fig_13.add_axes([0.1,0.1,0.9,0.9]) axes_13.set_xlabel(&#39;Mortalita per 100k&#39;) axes_13.set_ylabel(&#39;Casi confermati&#39;) axes_13.set_title(&#39;Mortalita per 100k vs. Casi confermati&#39;) axes_13.scatter(dr_arr, # valori sull&#39;asse delle x test_arr, # valori sull&#39;asse delle y s=cc_arr_sm, # valori che indicano la dimensione dei punti c=color_arr, # colori di ogni punto alpha=0.2 ); # trasparenza 1 = no trasparenza, 0 = completamente trasparente 3D from mpl_toolkits import mplot3d abbiamo bisogno di importare questo modulo projection=&#39;3d&#39; quando si costruisce la figura si aggiunge questo parametro fig_9 = plt.figure(figsize=(8,5), dpi=100) dpi=100 stranamente sembra avere un effetto sulla dimensione della figura, mentre sembra non prendere il parametro figsize! Probabilmente questo e’ dovuto al fatto che con %matplotlib inline mi mette le figure come dei png, cambiando il numero di punti questo cambia la dimensione dell’immagine a schermo. Per esempio dpi=100 e’ circa un terzo della figura con dpi=300 scatter3D la funzione per uno scatterplot 3D c= z_3 se uso questo parametro per i colori, allora quelli piu’ in alto (asse z) avranno una sfumatura differente da quelli in basso Scatter3D from mpl_toolkits import mplot3d fig_9 = plt.figure(figsize=(6,5), dpi=100) axes_9 = fig_9.add_axes([0.1,0.1,0.9,0.9], projection=&#39;3d&#39;) # mette degli assi 3D z_3 = 40 *np.random.random(100) # random: sample dalla [0,1) uniforme x_3 = np.sin(z_3) * np.random.randn(100) # randn y_3 = np.cos(z_3) * np.random.randn(100) # randn: sample dalla N(0,1) #axes_9.scatter3D(x_3,y_3,z_3, cmap=&#39;Blues&#39;); axes_9.scatter3D(x_3,y_3,z_3, c=z_3, cmap=&#39;Blues&#39;); Contour3D In questo caso ho bisogno di una funzione z =z(x,y) questo perche’ lui deve poter sapere la altezza in ogni punto. per costruire una griglia rettangolare devo usare np.meshgrid: x_4, y_4 = np.meshgrid(x_4, y_4) occhio che se non metto questo comando mi dice che c’e’ un errore!? Il motivo e’ semplice. meshgrid prende in ingresso due array 1 dimensionali e restituisce due array 2 dimensionali. In pratica ha fatto un prodotto cartesizano per ognuno dei punti del primo array creando una coppia con quelli del secondo array (e viceversa per il secondo array). Questo perche’ contour3D si aspetta delle matrici per le x e le y e anche le z, in quanto per ogni x e y c’e’uno z. Per capire meglio fai fare print(x_4) prima e dopo meshgrid e vedi la differenza. Angolo di vista, per cambiare: axes_9.view_init(45, 55). questo sposta l’angolo di vista di 45 gradi e lo ruota di 55 il 4to parametro indica il numero di linee. In pratica quante fette parallele al piano xy che vengono visualizzate, se metto 80 sono tante, se metto 20 sono poche fig_9 = plt.figure(figsize=(6,5), dpi=100) axes_9 = fig_9.add_axes([0.1,0.1,0.9,0.9], projection=&#39;3d&#39;) def get_z (x,y): return np.sin(np.sqrt(x**2+y**2)) x_4 = np.linspace(-6,6,30) y_4 = np.linspace(-6,6,30) #print(x_4) x_4, y_4 = np.meshgrid(x_4, y_4) #print(x_4) z_4 = get_z(x_4, y_4) axes_9.set_xlabel(&#39;x&#39;) axes_9.set_ylabel(&#39;y&#39;) axes_9.set_zlabel(&#39;z&#39;) axes_9.view_init(35, 30) # angolo di visione, angolo di rotazione axes_9.contour3D(x_4,y_4,z_4, 20, cmap=&#39;Blues&#39;); WireFrame e surface In questo caso vengono connessi tutti i punti da un segmento. -plot_wireframe(x_4,y_4,z_4, cmap=&#39;Blues&#39;) in questo caso non devo passare il numero di tagli paralleli all’asse xy, quindi non ha il 4to parametro. edgecolor =&#39;none&#39; non colora i segmenti di collegamento (il wireframe) fig_9 = plt.figure(figsize=(6,5), dpi=100) axes_9 = fig_9.add_axes([0.1,0.1,0.9,0.9], projection=&#39;3d&#39;) axes_9.view_init(35, 30) # angolo di visione, angolo di rotazione #axes_9.plot_wireframe(x_4,y_4,z_4, cmap=&#39;Blues&#39;); axes_9.plot_surface(x_4,y_4,z_4, rstride=1, cstride=1, cmap=&#39;Blues&#39;, edgecolor=&#39;r&#39;); Finance Module per installare ho fatto: anaconda prompt pip install mpl_finance pip install –upgrade mplfinance # upgrade questo modulo fa vedere le candele giapponesi ecc. posso cambiare il nome dell’index: goog_df.index.name=&#39;Date&#39; a questo punto l’index non si chiama piu’ index ma Date! mi pare di capire che questo sia necessario perche’ la libreria prenda correttamente il dataframe. Candele giapponesi Attento se prendi tante date, non riesci a vedere le candele! devono essere poche per essere visibili. trendlines possiamo mettere automaticamente delle medie mobili con il parametro: -type=&#39;ohlc&#39;, mav=4 # che significa che mette Open High Low Close e la media mobile basata sui precedenti 4 punti,nota che possiamo tenere come type ‘candle’ (ma si vede meno bene) altri tipi di medie mobili. mav=(3,5,7) e’ bene usare dispari, quindi fa vedere 3 medie mobili basate sui 3, 5 e 7 gg precedenti il parametro volume=True va vedere i volumi giornalieri mostrare non-tading days: show_nontrading=True parse_dates parse_dates=true vuol dire che non prende le date come delle semplici stringhe ma le legge come date, infatti ora sono in formato Timestamp import mplfinance as mpf goog_df = pd.read_csv(&#39;GOOG.csv&#39;, index_col = 0, parse_dates=True) #type(goog_df.index[0]) goog_df.index.name=&#39;Date&#39; #goog_df = pd.read_csv(&#39;GOOG.csv&#39;) goog_df.head(3) Open High Low Close Adj Close Volume Date 2019-08-21 1193.150024 1199.000000 1187.430054 1191.250000 1191.250000 740700 2019-08-22 1194.069946 1198.011963 1178.579956 1189.530029 1189.530029 947500 2019-08-23 1181.989990 1194.079956 1147.750000 1151.290039 1151.290039 1687000 mask = ( ( pd.to_datetime(goog_df.index) &gt;= pd.to_datetime(&#39;5/20/2020&#39;)) &amp; ( pd.to_datetime(goog_df.index) &lt;= pd.to_datetime(&#39;8/19/2020&#39;)) ) new = goog_df.loc[mask] # #mpf.plot(new, type=&#39;line&#39;) # normali linee #mpf.plot(new, type=&#39;candle&#39;) # candele giapponesi #mpf.plot(new, type=&#39;ohlc&#39;, mav=4) # open high low close + moving average mpf.plot(new, type=&#39;ohlc&#39;, mav=(3,5,7), volume=True, show_nontrading=True) # open high low close + moving average Heatmap ho un array 2 dimensionale e voglio mostrarlo con dei colori invece che dei numeri. symptoms sono i 4 tipi di malattia a cui si riferiscono i dati (dyspnea = short of breath) dates sono i giorni in cui sono state fatte le osservazioni (sono 9 giorni) symp_per sono il numero di pazienti per giorno per malattia e’ un array 4x9 Nota: pensavo che la heatmap di default mettesse delle righe bianche in mezzo alle caselle risultando molto poco chiara! in realta’ e’ una delle opzioni lasciate dal finance module!!!! (se faccio girare prima la casella sotto le righe bianche in mezzo non ci sono!) Per la heatmap si deve usare subplots() (non figure) Cosa fa il comando? prende la matrice che ha 0,3 righe, e 0,8 colonne. Per ognuna delle righe e delle colonne scrive un colore associato al numero dell’ingresso dell’array da disegnare. symptoms = [&quot;Coronavirus&quot;,&quot;Influenza&quot;,&quot;Pneumonia&quot;,&quot;Dyspnea&quot;] dates = [&quot;Jun28&quot;,&quot;Jul05&quot;,&quot;Jul12&quot;,&quot;Jul19&quot;,&quot;Jul26&quot;,&quot;Aug02&quot;,&quot;Aug09&quot;,&quot;Aug16&quot;,&quot;Aug21&quot;] symp_per = np.array([[5.2, 5.5, 5.7, 5.6, 5.3, 5.1, 5.0, 4.9, 5.3], [3.5, 4.0, 4.3, 3.9, 3.5, 3.2, 2.7, 2.2, 2.0], [1.8, 2.2, 2.3, 2.2, 2.1, 1.9, 1.7, 1.4, 1.3], [1.0, 1.1, 1.1, 1.0, 0.9, 0.8, 0.8, 0.8, 0.7]]) fig_10 , axes_10 = plt.subplots() im= axes_10.imshow(symp_per, cmap=&#39;Wistia&#39;) tics non chiaro perche’ all’inizio metta un np.arange, dato che abbiamo gia’ un array con dates e symptoms: ok: axes_10.set_xtics(np.arange(len(dates)) qui definisce la distanza (posizione) che devono avere i tics sulla mappa. axes_10.set_xticlabels(dates) questo definisce cosa ci deve essere nei ticks occhio che ticks ha la k occhio i ticks vanno assegnati DOPO avere definito la figura e l’axes giro i ticks di 45 gradi! plt.setp(axes_10.get_xticklabels(), rotation=45, ha=&#39;right&#39;, rotation_mode=&#39;anchor&#39;) (non chiaro l’anchor cosa faccia) fig_10 , axes_10 = plt.subplots() im= axes_10.imshow(symp_per, cmap=&#39;Wistia&#39;) axes_10.set_xticks(np.arange(len(dates))) # posizione tics sull&#39;asse x axes_10.set_yticks(np.arange(len(symptoms))) # posizione tics sull&#39;asse y axes_10.set_xticklabels(dates) # cosa viene mostrato ad ogni tic dell&#39;asse x axes_10.set_yticklabels(symptoms) # cosa viene mostrato ad ogni tic dell&#39;asse x plt.setp(axes_10.get_xticklabels(), rotation=45, ha=&#39;right&#39;); Numeri nelle caselle metto qui anche i numeri dentro le caselle. Nota che usa un costrutto che non ho mai usato prima, chiama un metodo dell’axes dentro una funzione di matplotlib. -plt.setp(axes_10.get_xticklabels(), rotation=45, ha=&#39;right&#39;); chiama fig_10 , axes_10 = plt.subplots() im= axes_10.imshow(symp_per, cmap=&#39;Wistia&#39;) axes_10.set_xticks(np.arange(len(dates))) # posizione tics sull&#39;asse x axes_10.set_yticks(np.arange(len(symptoms))) # posizione tics sull&#39;asse y axes_10.set_xticklabels(dates) # cosa viene mostrato ad ogni tic dell&#39;asse x axes_10.set_yticklabels(symptoms) # cosa viene mostrato ad ogni tic dell&#39;asse x plt.setp(axes_10.get_xticklabels(), rotation=45, ha=&#39;right&#39;); for i in range(len(symptoms)): for j in range(len(dates)): text = axes_10.text(j,i, symp_per[i,j], ha=&#39;center&#39;, va=&#39;center&#39;, color=&#39;k&#39;, fontweight=&#39;bold&#39;) Riempire le aree tra curve ci sono ottimi esempi al sito di matplotlib: https://matplotlib.org/3.1.1/gallery/lines_bars_and_markers/fill_between_demo.html il metodo degli assi fill_between() permette di riempire quello che c’e’ tra una curva e l’altra. x = np.arange(0.0, 2, 0.01) # le x y1 = np.sin(2 * np.pi * x) # y1 = la funzione seno y2 = 1.2 * np.sin(4 * np.pi * x) # y2 = funzione seno piu&#39; larga e con maggiore frequenza fig, (ax1, ax2, ax3) = plt.subplots(3, 1, sharex=True) ax1.fill_between(x, 0, y1) # riempie tra 0 e y1 ax1.set_ylabel(&#39;TRA y1 e 0&#39;) ax2.fill_between(x, y1, 1) # riempie tra y1 e 1 (quello che c&#39;e&#39; sopra y1) ax2.set_ylabel(&#39;TRA y1 e 1&#39;) ax3.fill_between(x, y1, y2) # quello che c&#39;e&#39; TRA y1 e sotto y2 ax3.set_ylabel(&#39;TRA y1 e y2&#39;) ax3.set_xlabel(&#39;x&#39;) Text(0.5, 0, &#39;x&#39;) si possono mettere ulteriori condizioni per dare dei colori diversi tra le curve. In particolare si aggiungono dei parametri logici. fig, (ax, ax1) = plt.subplots(2, 1, sharex=True) # costruisce subplots ax.plot(x, y1, x, y2, color=&#39;black&#39;) # disegna le 2 funzioni ax.fill_between(x, y1, y2, where=y2 &gt;= y1, facecolor=&#39;green&#39;, interpolate=True) ax.fill_between(x, y1, y2, where=y2 &lt;= y1, facecolor=&#39;red&#39;, interpolate=True) ax.set_title(&#39;fill between where&#39;) # Test support for masked arrays. y2 = np.ma.masked_greater(y2, 1.0) ax1.plot(x, y1, x, y2, color=&#39;black&#39;) ax1.fill_between(x, y1, y2, where=y2 &gt;= y1, facecolor=&#39;green&#39;, interpolate=True) ax1.fill_between(x, y1, y2, where=y2 &lt;= y1, facecolor=&#39;red&#39;, interpolate=True) ax1.set_title(&#39;Now regions with y2&gt;1 are masked&#39;) Text(0.5, 1.0, &#39;Now regions with y2&gt;1 are masked&#39;) Ticks Al comando ticks possono essere passati degli argomenti per specificare: rotation = 45 ruota di 45 gradi se il primo ingresso e’ un np.array allora quelli sono i ticks (le posizioni) se il secondo ingresso e’ una tupla, allora alle varie posizioni dei ticks vengono messi i valori della tupla fontsize=24 viene passato come al solito puoi passare piu’ di un parametro basta che sia separato dalla virgola! plt.plot(x_1,y_1) #plt.xticks(np.linspace(0,5,100)) #plt.xticks(np.arange(15)) #plt.xticks(np.arange(5), (&#39;Tom&#39;, &#39;Dick&#39;, &#39;Harry&#39;, &#39;Sally&#39;, &#39;Sue&#39;)) #plt.grid(False, color=&#39;r&#39;, dashes=(0,2,1,2)) plt.grid(False) #plt.grid(b=None) degrees = 45 plt.xticks(rotation=degrees) # Rotazione dei ticks mioArray= np.array([1,2,3,4,8]) #plt.xticks(np.linspace(0,5,5), (&#39;Tom&#39;, &#39;Dick&#39;, &#39;Harry&#39;, &#39;Sally&#39;, &#39;Sue&#39;)) plt.grid(True) # presenza della grid plt.xticks(fontsize=24) # GRANDEZZA FONT plt.xticks(mioArray, (&#39;Gino&#39;, &#39;Pino&#39;, &#39;Mino&#39;, &#39;Tino&#39;, &#39;Asdrubale&#39;)); Animazioni Testo di riferimento: https://riptutorial.com/Download/matplotlib-it.pdf Lo ho scaricato ed e’ nella dir. Bisogna importare anche la parte del package che fa animazioni. Bisogna usare il metodo set_data() che assegna i valori delle x e y di un grafico %matplotlib notebook import matplotlib.animation as animation TWOPI = 2*np.pi fig, ax = plt.subplots() # costruiamo una figura e un array di assi t = np.arange(0.0, TWOPI, 0.001) # t =array di posizioni s = np.sin(t) # y = sin(t) l = plt.plot(t, s) # grafico ax = plt.axis([0,TWOPI,-1,1]) # assi redDot, = plt.plot([0], [np.sin(0)], &#39;ro&#39;) # l&#39;oggetto &quot;redDot&quot; disegna il punto rosso, all&#39;inizio e&#39; in zero def animate(i): # questa funzione modifica i parametri del punto rosso redDot.set_data(i, np.sin(i)) # quindi il resto del grafico resta invariato! return redDot, # create animation using the animate() function myAnimation = animation.FuncAnimation(fig, animate, frames=np.arange(0.0, TWOPI, 0.01), \\ interval=1, blit=True, repeat=True) &lt;IPython.core.display.Javascript object&gt; Mio test di animazione vorrei fare estendere la funzione seno, in modo che ad ogni frame sia moltiplicata per una diversa ampiezza. Attenzione: ho provato a farlo girare molte volte e non andava. Ho resettato il kernel e ora sembra fungere. Mi viene il dubbio che il problema fosse connesso a qualche cella che avevo lasciato attiva. Curiosamente se metto i limiti degli assi il grafico non appare! Errore Ax e’ un array di assi! interval=1 rallenta l’esecuzione del programma frames sono tutti i vari prarametri che andranno a definire i frame possiamo ingrandire o diminuire la dimensione dei limiti: https://stackoverflow.com/questions/53423868/matplotlib-animation-how-to-dynamically-extend-x-limits TWOPI = 2*np.pi #fig, ax = plt.subplots() # costruiamo una figura e un array di assi fig = plt.figure() ax = fig.add_subplot(111, autoscale_on=False, xlim=(0, 6.29), ylim=(-2, 2)) #ax = plt.axis([0,TWOPI,-1,1]) # ATTENTO assi QUESTO BLOCCA set_xlim #ax.set_xlim([0,TWOPI]) # ERRORE ax non e&#39; un asse ma una tupla di assi! #ax.set_ylim([-1,1]) # ERRORE t = np.arange(0.0, TWOPI, 0.001) # t =array di posizioni s = np.sin(t) # y = sin(t) plt.grid(False) new = plt.plot(t, t) # bisettrice second = plt.plot(t,s/2) curva, = plt.plot(t, s) # grafico #ax = plt.axes(xlim=(0, 10), ylim=(-1, 1)) def animate(A): # questa funzione modifica i parametri del punto rosso curva.set_ydata(A *np.sin(t)) # quindi il resto del grafico resta invariato! #print(A*np.sin(t)) return curva, frames1 = np.arange(0.0,1.0,0.001) frames2 = np.arange(1.0,0.0,-0.001) frames = np.concatenate((frames1, frames2), axis=None) # create animation using the animate() function #myAnimation = animation.FuncAnimation(fig, animate, frames = np.arange(0.0, 1.0, 0.001), \\ # interval=10, blit=True, repeat=True) myAnimation = animation.FuncAnimation(fig, animate, frames = frames, \\ interval=1, blit=True, repeat=True) &lt;IPython.core.display.Javascript object&gt; Slider interattivo possiamo modificare la figura tramite uno slider interattivo! In questo caso non uso la funzione animate, perche’ la modifica viene fatta in base a cosa tocco sullo slider. from matplotlib.widgets import Slider TWOPI = 2*np.pi fig, ax = plt.subplots() A0 = .5 # valore iniziale ampiezza t = np.arange(0.0, TWOPI, 0.001) # x del grafico s = A0*np.sin(t) # y del grafico (iniziale) l, = plt.plot(t, s, lw=2) # grafico (da capire la virgola) ax = plt.axis([0,TWOPI,-1,1]) # assi (che non verranno toccate) ??? axamp = plt.axes([0.25, .03, 0.50, 0.02]) # non chiaro axIs e axEs # Slider samp = Slider(axamp, &#39;Amp&#39;, 0, 1, valinit=A0) # SLIDER interattivo, si chiama &quot;samp&quot; def update(val): # amp is the current value of the slider amp = samp.val # valore corrente dello slider # update curve l.set_ydata(amp*np.sin(t)) # fai update delle y della curva # redraw canvas while idle fig.canvas.draw_idle() samp.on_changed(update) # ridisegna la figura se muoviamo lo slider #plt.show() &lt;IPython.core.display.Javascript object&gt; 0 Foto Vediamo come mostrare una immagine. Si passa un array 2D e questo viene convertito automaticamente, assegnando ai valori un colore. Per esempio: immagine = np.array([ [1,0,0,0,1,0,0,0,1], [0,0,0,0,1,0,0,0,0], [0,0,0,0,1,0,0,0,0], [0,0,0,0,1,0,0,0,0], [0,0,0,0,1,0,0,0,0], [1,0,0,0,1,0,0,0,1]]) plt.imshow(immagine) &lt;matplotlib.image.AxesImage at 0x2de6a38e640&gt; Unpacking questo non e’ strettamente connesso con matplotlib…. numbers = [1, 2, 3, 4, 5, 6] first, *rest = numbers # multiple assignment print(rest) print(first) d = dict(a=5,b=2,c=4) [2, 3, 4, 5, 6] 1 enumerate() for o,_ in enumerate(d): print(o) # stampa l&#39;ordine degli oggetti 0 1 2 for _, o in enumerate(d): print(o) # stampa le chiavi del dizionario a b c for _, o in enumerate(d): print(d[o]) # stampa i valori del dizionario 5 2 4 for o in enumerate(d): print(o) # stampa le NUOVE coppie chiave-chiave vecchia costruite da enumerate() (0, &#39;a&#39;) (1, &#39;b&#39;) (2, &#39;c&#39;)","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/Matplotlib"},"@type":"BlogPosting","url":"http://localhost:4000/Matplotlib","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body>
	<header>
  
    <nav class="top-nav light-blue darken-4">
  <div class="nav-wrapper">
    <div class="container">
      <a class="page-title font-title" href="/">4Phycs</a>
      <ul id="nav-mobile" class="right hide-on-med-and-down">
        <li><a href="/categories">Ita Eng</a></li>
        <li><a href="/tags">Tags</a></li>
        <li><a href="/me">Me</a></li>
        <li><a href="/about">About</a></li>
        <li><a href="/contact">Contact</a></li>
      </ul>
    </div>
  </div>
</nav>

<div class="container">
  <a href="#" data-activates="slide-out" class="button-collapse top-nav full hide-on-large-only">
    <i class="material-icons">menu</i>
  </a>
</div>
<div id="slide-out" class="side-nav fixed">
  <div>
    <div class="userView thi-userView">
      <div class="background"></div>
        <a href="/">
          <img style="display:inherit;" class="circle z-depth-2" src="/assets/res/user.png">
        </a>
      <span style="font-size: larger;" class="white-text name">Paolo Avogadro</span>
      <span class="white-text email"><a style="color: #bdbdbd;" href="http://"></a></span>
    </div>
  </div>
  <div style="padding: 10px;">
    <form action="/search" method="get">
      <input class="search-sidebar" type="search" name="q"  placeholder="search something?" autofocus>
      <input type="submit" value="Search" style="display: none;">
    </form>
  </div>
  <div id="toc-bar">
    <div class="toc-bar-title">
      In this post
    </div>
    <ol id="toc-sidebar">
  <li><a href="#matplotlib">Matplotlib</a></li>
  <li><a href="#functional-plot">Functional Plot</a></li>
  <li><a href="#pltsubplot-molti-grafici-in-modo-veloce">plt.subplot() molti grafici in modo veloce</a></li>
  <li><a href="#figure-e-axes">Figure e axes</a>
    <ol>
      <li><a href="#axes">Axes</a></li>
      <li><a href="#molte-curve-versione-veloce">Molte curve: versione veloce</a></li>
      <li><a href="#axes-innestati">Axes innestati</a></li>
    </ol>
  </li>
  <li><a href="#subplots-una-griglia-di-grafici">subplots() Una griglia di grafici</a></li>
  <li><a href="#colori-e-apparenza">Colori e Apparenza</a></li>
  <li><a href="#grandezza-degli-assi-e-background">Grandezza degli assi e background</a></li>
  <li><a href="#salvare-una-figura-a-file">Salvare una figura a file</a></li>
  <li><a href="#pandas">Pandas</a></li>
  <li><a href="#annotare-la-figura">Annotare la figura</a></li>
  <li><a href="#bar-barchart-sotto-il-grafico">bar() Barchart sotto il grafico</a>
    <ol>
      <li><a href="#impulsi-stem---e-proprieta-setp">Impulsi stem()   e proprieta’ setp()</a></li>
    </ol>
  </li>
  <li><a href="#tex---regular-expressions">TeX - regular expressions</a></li>
  <li><a href="#istogrammi-plthist">Istogrammi plt.hist()</a>
    <ol>
      <li><a href="#ax0hist-axes-e-istogrammi">ax[0].hist() Axes e istogrammi</a></li>
    </ol>
  </li>
  <li><a href="#bar-charts">Bar charts</a>
    <ol>
      <li><a href="#bar-chart-affiancate">Bar Chart affiancate</a></li>
      <li><a href="#bar-chart-impilate-stacked">Bar Chart impilate (stacked)</a></li>
    </ol>
  </li>
  <li><a href="#torte---pie-chart--pltpie">Torte - Pie chart,  plt.pie()</a></li>
  <li><a href="#serie-temporali">Serie Temporali</a>
    <ol>
      <li><a href="#selezionare-righe-secondo-delle-date">Selezionare righe secondo delle date</a></li>
    </ol>
  </li>
  <li><a href="#tabelle">Tabelle</a></li>
  <li><a href="#scatterplot">ScatterPlot</a></li>
  <li><a href="#3d">3D</a>
    <ol>
      <li><a href="#scatter3d">Scatter3D</a></li>
      <li><a href="#contour3d">Contour3D</a></li>
      <li><a href="#wireframe-e-surface">WireFrame e surface</a></li>
    </ol>
  </li>
  <li><a href="#finance-module">Finance Module</a>
    <ol>
      <li><a href="#candele-giapponesi">Candele giapponesi</a></li>
      <li><a href="#trendlines">trendlines</a></li>
      <li><a href="#parse_dates">parse_dates</a></li>
    </ol>
  </li>
  <li><a href="#heatmap">Heatmap</a>
    <ol>
      <li><a href="#tics">tics</a></li>
      <li><a href="#numeri-nelle-caselle">Numeri nelle caselle</a></li>
    </ol>
  </li>
  <li><a href="#riempire-le-aree-tra-curve">Riempire le aree tra curve</a></li>
  <li><a href="#ticks">Ticks</a></li>
  <li><a href="#animazioni">Animazioni</a>
    <ol>
      <li><a href="#mio-test-di-animazione">Mio test di animazione</a></li>
      <li><a href="#slider-interattivo">Slider interattivo</a></li>
    </ol>
  </li>
  <li><a href="#foto">Foto</a></li>
  <li><a href="#unpacking">Unpacking</a></li>
  <li><a href="#enumerate">enumerate()</a></li>
</ol>

  </div>
</div>
  
</header>
<main>
  <div class="container">
    <div id="post-info">
      <h3>Matplotlib - appunti</h3>
      <span>
        Posted on
        <span style="display: initial;" class="cat-class">07/11/2021</span>,
        in
        
          
          
            <a class="cat-class cat-commas" href="/categories#italiano">Italiano</a>.
          
        
        <span class="reading-time" title="Estimated read time">
  
  
  <font size="2"> Reading time: 86 mins </font>
  
</span>

      </span>
    </div>

    <div class="divider"></div>
    <div class="row thi-post">
      <div class="col s12">
        <h1 id="matplotlib">Matplotlib</h1>

<p>Queste sono le mie (Paolo Avogadro) note basate sul 
<strong><a href="https://www.youtube.com/watch?v=wB9C0Mz9gSo&amp;ab_channel=DerekBanas">video</a></strong> di Derek Banas riguardo a <strong><a href="https://matplotlib.org/">Matplotlib</a></strong>. Oltre agli esempi suggeriti aggiungo dei miei test e considerazioni.
Qualunque errore e’ esclusivamente dovuto ad una mia erronea interpretazione dei comandi. Lo scopo di queste note non e’ di
presentare esempi perfettamente funzionanti, ma serve a me come spunto per ricordare i comandi di Matplotlib, e il modello mentale che io ho sul pacchetto.
 La versione originale di queste note ha la forma di un Jupyter Notebook
e quindi possono esserci dei riferimenti ai notebook all’interno del testo.
Dopo avere imparato Matplotlib puo’ essere interessante impararare ad usare <strong><a href="/Seaborn">Seaborn</a></strong>.</p>

<p>Cerco di ricostruire gli esempi presentati e fare delle piccole varianti per capire meglio. Queste note suppongono che ci sia una certa conoscenza di base di come fare i grafici al computer, per esempio partendo da <strong>Gnuplot</strong>.</p>

<p>Notazione:</p>
<ul>
  <li>cerco di usare l’evidenziatore per i <code class="language-plaintext highlighter-rouge">comandi</code></li>
  <li>cerco di usare il <strong>grassetto</strong> per i termini principali</li>
</ul>

<p>Micro-riassunto:</p>

<p>Ci sono 2 modi principali per fare un grafico:</p>
<ol>
  <li>
    <p>modo veloce: con le funzioni di plotting, per esempio: <code class="language-plaintext highlighter-rouge">plt.plot(x_1, y_1)</code> (dove x_1 e x_2 sono due oggetti contenenti lo stesso numero di variabili). Si possono inoltre aggiungere delle funzioni per controllare le label, il titolo ecc.</p>
  </li>
  <li>
    <p>modo esteso:</p>
    <ul>
      <li>prima si definisce una <strong>figure</strong>, per esempio: <code class="language-plaintext highlighter-rouge">fig_1 = plt.figure(figsize=(5,4), dpi =100);</code> pensa alla figure come un’immagine bianca.</li>
      <li>poi si costruisce uno (o piu’) axes (assi) con un <strong>metodo</strong> delle <strong>figure</strong>: <code class="language-plaintext highlighter-rouge">axes_1 = fig_1.add_axes([0.1,0.1,0.9,0.9])</code> (dove specifichiamo la posizione degli assi all’interno della figura). Gli assi determineranno la posizione del grafico. Per esempio se hai un solo quadrante per il tuo grafico puoi immaginare gli assi come un rettangolo (vuoto all’interno).</li>
      <li>A questo punto si fa partire un grafico, usando un <strong>metodo</strong> degli <strong>assi</strong>, per esempio: <code class="language-plaintext highlighter-rouge">axes_1.plot(x_1,y_1);</code>  Nota che questi metodi sono in pratica le stesse funzioni del punto 1 (solo che vengono chiamati come metodi dell’asse).</li>
    </ul>
  </li>
</ol>

<p><strong>Nota</strong></p>
<ul>
  <li>se <strong>non</strong> sei in un <em>jupyter notebook</em> dovrai usare un <code class="language-plaintext highlighter-rouge">plt.show()</code></li>
  <li>se sei su un notebook invece, serve un <em>magic command</em> (e’ una di quelle cose decorate con il percentuale),  ci sono vari di questi comandi, tra cui:
    <ol>
      <li><code class="language-plaintext highlighter-rouge">%matplotlib inline</code>   (questo fa apparire delle immagini png statiche nel notebook)</li>
      <li><code class="language-plaintext highlighter-rouge">%matplotlib notebook</code> (si possono fare zoom delle immagini)</li>
      <li><code class="language-plaintext highlighter-rouge">%matplotlib tk</code>  (tkinter GUI)</li>
    </ol>
  </li>
</ul>

<p>Una lista di termini utili:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">alpha=0.75</code> definisce la <strong>trasparenza</strong></li>
  <li><code class="language-plaintext highlighter-rouge">lw=2</code>  larghezza delle <strong>linee</strong> del grafico</li>
  <li><code class="language-plaintext highlighter-rouge">ls ='-.'</code> <strong>line style</strong>, se e’ una linea continua, oppure trattino e punto, ecc…</li>
  <li><code class="language-plaintext highlighter-rouge">marker = 'o'</code> marker sono i <strong>punti</strong> di gnuplot. Cosa viene messo nei punti? in questo caso dei cerchietti =o)</li>
  <li><code class="language-plaintext highlighter-rouge">markersize=7</code> la <strong>grandezza</strong> dei punti</li>
  <li><code class="language-plaintext highlighter-rouge">markerfacecolor ='y'</code> il colore dell’interno dei punti</li>
  <li><code class="language-plaintext highlighter-rouge">markeredgecolor='k'</code> il colore dei contorni dei punti</li>
  <li><code class="language-plaintext highlighter-rouge">markeredgewidth=2</code> la larghezza del contorno dei punti</li>
  <li><code class="language-plaintext highlighter-rouge">projection='3d'</code> argomento per quando si creano degli <strong>assi</strong> e devono avere un <strong>3D</strong></li>
  <li><code class="language-plaintext highlighter-rouge">goog_df = pd.read_csv('GOOG.csv', index_col = 0, parse_dates=True)</code> trasforma del <strong>testo in datetime</strong>!</li>
  <li><code class="language-plaintext highlighter-rouge">facecolor</code> e’ il colore dello sfondo di un’immagine</li>
</ul>

<p>Metodi di FIGURE:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">fig.tight_layout()</code> oppure,  <code class="language-plaintext highlighter-rouge">plt.tight_layout()</code> serve per <strong>evitare sovrapposizioni</strong> per esempio i numeri degli assi trasbordino</li>
  <li><code class="language-plaintext highlighter-rouge">fig_3.savefig('ultimoPlot.png')</code> <strong>salvare a file</strong> una figura!</li>
</ul>

<p>Metodi degli Assi</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">plt.xticks(np.linspace(0,5,5), ('Tom', 'Dick', 'Harry', 'Sally', 'Sue'))</code>  <strong>tics</strong> (o <strong>ticks</strong>) sull’asse x. Per non avere ticks: <code class="language-plaintext highlighter-rouge">plt.xticks([])</code> (non ho messo nulla nella lista = <strong>non</strong> ci sono ticks)</li>
  <li><code class="language-plaintext highlighter-rouge">axes_3.set_xlim([0,3])</code>  definisce i <strong>limiti sull’asse x</strong> (set xlim[1:100])</li>
  <li><code class="language-plaintext highlighter-rouge">axes_4.set_xlabel('temp')</code>               <strong>label degli assi</strong></li>
  <li><code class="language-plaintext highlighter-rouge">axes_3.grid(False, color='r', dashes=(0,2,1,2))</code> mette una <strong>griglia sullo sfondo</strong>, occhio che <em>color</em> e’ il colore della griglia non dello sfondo. <code class="language-plaintext highlighter-rouge">plt.grid(False)</code> e <code class="language-plaintext highlighter-rouge">plt.grid(b=None)</code> tolgono la griglia</li>
  <li><code class="language-plaintext highlighter-rouge">axes_3.set_facecolor('w')</code> colore dello <strong>sfondo</strong> (bianco in questo caso)</li>
  <li><code class="language-plaintext highlighter-rouge">axes_4.set_title('da Pandas: IceCream')</code> <strong>titolo</strong></li>
  <li><code class="language-plaintext highlighter-rouge">axes_1.legend(loc =0 )</code>                      # Loc=0 e’ la migliore location scelta da lui`</li>
</ul>

<p>Tipi di disegno (possono essere chiamati come metodi degli assi o funzioni plt):</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">axes_4.plot(x_2, y_2)</code>  disegno <strong>standard</strong> in cui ci sono i punti e posso unirli, cambiarli ecc.</li>
  <li><code class="language-plaintext highlighter-rouge">plt.bar(x_2, y_2, width=1.5);</code> <strong>barchart</strong> (come istogramma ma sulle x possono essere categorici)</li>
  <li><code class="language-plaintext highlighter-rouge">plt.stem(x_2, y_2, '-.')</code> <strong>impulsi</strong>, interessante si puo’ indicare il tipo di linea</li>
  <li><code class="language-plaintext highlighter-rouge">plt.hist(arr3ok, bins= 7, density=True, stacked =False);</code> <strong>istogrammi</strong> (raggruppa i valori sull’asse delle x in bins)</li>
  <li><code class="language-plaintext highlighter-rouge">plt.pie()</code> piechart <strong>TORTE</strong> (gurada sotto perche’ servono un po’ di dettagli)</li>
  <li><code class="language-plaintext highlighter-rouge">axes_13.scatter(dr_arr, test_arr,  s=cc_arr_sm, c=color_arr, alpha=0.2 )</code> <strong>scatterplot</strong> valori sull’asse delle x, y, dimensione punti, colori dei punti, trasparenza)</li>
  <li><code class="language-plaintext highlighter-rouge">axes_9.scatter3D(x_3,y_3,z_3, c=z_3, cmap='Blues');</code> <strong>scatterplot 3D</strong></li>
  <li><code class="language-plaintext highlighter-rouge">axes_9.contour3D(x_4,y_4,z_4, 20, cmap='Blues');</code> <strong>3D</strong> contorno, curve di livello, <strong>isoipse</strong></li>
  <li><code class="language-plaintext highlighter-rouge">axes_9.plot_wireframe(x_4,y_4,z_4, cmap='Blues');</code> <strong>wireframe</strong> e’ il grafico <strong>3D</strong> standard di gnuplot, collega tutti i punti</li>
  <li><code class="language-plaintext highlighter-rouge">axes_9.plot_surface(x_4,y_4,z_4, rstride=1, cstride=1,  cmap='Blues', edgecolor='r');</code> <strong>3D</strong>, collega i punti e colora le tegole</li>
</ul>

<p><strong>Consiglio</strong>:
in un Jupyter notebook usa <strong>shift-tab</strong> su una funzione per vederne la sua descrizione (prima devi cliccare sulla cella e poi avere il cursore sulla funzione stessa).</p>

<p><strong>Consiglio</strong> questo <a href="https://www.dataquest.io/blog/jupyter-notebook-tips-tricks-shortcuts/">articolo</a> contiene trucchi su jupyter notebook e alternative a Matplotlib.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>
<span class="c1">#%matplotlib notebook
</span><span class="o">%</span><span class="n">reload_ext</span> <span class="n">autoreload</span>
<span class="o">%</span><span class="n">autoreload</span> <span class="mi">2</span>             
</code></pre></div></div>

<h1 id="functional-plot">Functional Plot</h1>
<p>Cominciamo con un’immagine semplice in cui</p>
<ul>
  <li>c’e’ il titolo: <code class="language-plaintext highlighter-rouge">plt.title('ciao')</code></li>
  <li>ci sono i nomi degli asssi:  <code class="language-plaintext highlighter-rouge">plt.xlabel('Days')</code></li>
  <li>c’e’ un grafico:  <code class="language-plaintext highlighter-rouge">plt.plot(x_1, y_1)</code></li>
</ul>

<p>Quando faccio un disegno, voglio che tutte le coordinate x siano in un contenitore (lo stesso vale per le coordinate y).
Questi “contenitori” devono contenere lo stesso numero di oggetti, altrimenti per un punto avrei solo la coordinata x o solo la y… quindi mi manca il punto!</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>  <span class="c1"># genera un Numpy array con 10 float equispaziati tra 0 e 5
</span><span class="n">y_1</span> <span class="o">=</span> <span class="n">x_1</span> <span class="o">**</span><span class="mi">2</span>              <span class="c1"># genera un Numpy array che e' il quadrato del primo 
</span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span> <span class="n">y_1</span><span class="p">);</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">'ciao'</span><span class="p">);</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Days'</span><span class="p">);</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'Days squared'</span><span class="p">);</span>
<span class="c1">#plt.show()                  # se non siamo in jupyter notebook
</span></code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_3_0.png" alt="png" /></p>

<p><code class="language-plaintext highlighter-rouge">Domanda</code>: posso passare delle <strong>liste</strong> ad un <code class="language-plaintext highlighter-rouge">plt.plot()</code>?</p>

<p><code class="language-plaintext highlighter-rouge">Risposta</code>: si’ certo! posso anche graficare delle liste che contengano delle <strong>stringhe</strong>. Se il contenitore di stringhe e’ una lista, allora esiste un ordine per le stringhe e questo ordine verra’ usato nella visualizzazione. Per un <code class="language-plaintext highlighter-rouge">set</code> invece non esiste un ordine e si ha un errore <em>TypeError: unhashable type: ‘set’</em></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">l1</span><span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="n">l2</span><span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="n">l3</span><span class="o">=</span> <span class="p">[</span><span class="s">'a'</span><span class="p">,</span><span class="s">'b'</span><span class="p">,</span><span class="s">'e'</span><span class="p">,</span><span class="s">'d'</span><span class="p">]</span>
<span class="n">d1</span> <span class="o">=</span> <span class="p">{</span><span class="s">"apple"</span><span class="p">,</span> <span class="s">"banana"</span><span class="p">,</span> <span class="s">"cherry"</span><span class="p">}</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">l3</span><span class="p">);</span>
<span class="c1">#plt.plot(l1,d1)   # non funge!
</span></code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_5_0.png" alt="png" /></p>

<h1 id="pltsubplot-molti-grafici-in-modo-veloce">plt.subplot() molti grafici in modo veloce</h1>
<p>Qui vediamo come mettere piu’ di un grafico vicino all’altro. Nel dettaglio usando <code class="language-plaintext highlighter-rouge">subplot</code> potremo costuire una <strong>griglia</strong>, in ogni casella della griglia verra’ messo un grafico.</p>

<p>Il comando <code class="language-plaintext highlighter-rouge">plt.subplot(1,2,1)</code> fa questo tipo di lavoro.</p>
<ol>
  <li>il primo argomento e’ il numero di <strong>righe</strong> della griglia (in questo caso c’e’ solo una riga)</li>
  <li>il secondo argomento e’ il numero di <strong>colonne</strong> della griglia .</li>
  <li>il terzo argomento e’ l’indice del grafico. L’indice ci dice in quale casella della griglia stiamo mettendo il subplot. L’ordine seguito e’ lo stesso che si ha quando si legge: da SINISTRA a DESTRA da SOPRA a SOTTO.</li>
</ol>

<p>Vediamo un esempio:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># nota che se anche il terzo argomento e' 2 il grafico appare al primo posto, perche'
# non ce ne sono 2! E' un po' come se cadesse a sinistra se ci sono dei buchi?
</span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>        <span class="c1"># questo ci dice che abbiamo una riga e 2 colonne
</span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span><span class="n">y_1</span><span class="p">,</span> <span class="s">'r'</span><span class="p">);</span>   <span class="c1"># r = red 
</span></code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_7_0.png" alt="png" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>        <span class="c1"># questo ci dice che abbiamo una riga e 2 colonne
</span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span><span class="n">y_1</span><span class="p">,</span> <span class="s">'r'</span><span class="p">)</span>    <span class="c1"># r = red 
</span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>        <span class="c1"># se metto 1 mi sovrappone con il primo ma mi dice che c'e' qualcosa di strano
</span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span><span class="n">y_1</span><span class="p">,</span> <span class="s">'b'</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[&lt;matplotlib.lines.Line2D at 0x2de659e5c40&gt;]
</code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_8_1.png" alt="png" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>        <span class="c1"># 
</span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span><span class="n">y_1</span><span class="p">,</span> <span class="s">'r'</span><span class="p">)</span>    <span class="c1">#  
</span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>        <span class="c1"># 
</span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span> <span class="n">y_1</span><span class="o">-</span><span class="n">y_1</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="s">'b'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span> <span class="o">-</span><span class="n">y_1</span><span class="p">,</span> <span class="s">'g'</span><span class="p">);</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>              <span class="c1"># evita sovrapposizione dei numeri dei grafici!
</span></code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_9_0.png" alt="png" /></p>

<h1 id="figure-e-axes">Figure e axes</h1>
<ul>
  <li>Una <strong>figure</strong> e’ un oggetto su cui poi si mette il grafico  (lo vedo come la tela bianca su cui fare il disegno)</li>
  <li>contiene tutti i ‘plot elements’</li>
  <li>puo’ contenere molti <strong>axes</strong> (assi), che in pratica sono gli assi che definiscono il disegno vero e proprio, in quanto i punti sono riferiti agli assi.</li>
  <li>posso definire la sua larghezza e lunghezza in <strong>inch</strong> (inch=2.54 cm), probabilmente posso cambiare scala: <code class="language-plaintext highlighter-rouge">figsize=(5,4)</code></li>
  <li>posso anche definire la risoluzione in dpi</li>
  <li><strong>ATTENTO</strong> se definisci il numero di dpi, quando lo visualizzi come un png, questo definisce la dimensione della figura a video! quindi sembra che figsize non funzioni!</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fig_1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">dpi</span> <span class="o">=</span><span class="mi">100</span><span class="p">);</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;Figure size 500x400 with 0 Axes&gt;
</code></pre></div></div>

<h2 id="axes">Axes</h2>

<p>L’oggetto <strong>axes</strong> (come indica il nome) identifica la posizione, la forma, e tutte le caratteristiche degli ASSI di un grafico. Se non facciamo esplicitamente un grafico, ci saranno solo le due fracce perpendicolari (gli assi) con dentro nulla. Possiamo i <strong>plot</strong> (grafici) sono dei <strong>metodi</strong> degli assi! La logica e’ quindi che siano un oggetto in funzione di dove sono gli assi (e ha senso, quando uno fa un grafico su un foglio, prima disegna gli assi, e poi puo’ definire la posizione dei punti che compongono il grafico. In questo senso quindi il plot e’ stato definito come un metodo di un axes.
Nota che posso mettere piu’ di un <strong>axes</strong> su una singola <strong>figure</strong>. Anche questo e’ intuitivo, posso mettere 2 grafici sullo stesso foglio, poi i punti di un grafico saranno riferiti ad un paio di assi e quelli del secondo ad un altro paio di assi. Gli assi definiscono il sistema di riferimento “inerziale” che determina la posizione dei punti!</p>

<p>Gli assi vengono costruiti su una <code class="language-plaintext highlighter-rouge">figure</code> tramite questo metodo:</p>

<p><code class="language-plaintext highlighter-rouge">axes_1 = fig_1.add_axes([0.1,0.1,0.9,0.9])</code></p>

<p>Significa che <code class="language-plaintext highlighter-rouge">axes_1</code> sara’ un rettangolo il cui:</p>
<ul>
  <li>punto in basso a sx ha coordinate 0.1, 0.1 (rispetto a fig_1). Ovvero, la figure e’ un rettangolo, anche gli axes sono un rettangolo, il cui punto in basso a sinistra si trova nelle coordinate che sono il 10% delle x e il 10% delle y del punto in basso a sx della figure.</li>
  <li>
    <p>punto in alto a dx ha coordinate 0.9,0.9 (rispetto a fig_1)
In questo modo ho un grafico che e’ piu’ piccolo del “canvas” definito da fig_1.</p>
  </li>
  <li>(nel video) non e’ chiaro come ha fatto l’esponente 2 sulla x. Io devo usare i comandi Latex</li>
</ul>

<p><strong>Attenzione</strong>, io avevo messo il comando <code class="language-plaintext highlighter-rouge">fig_1 = plt.figure(figsize=(5,4), dpi =100)</code> in una cella diversa 
da dove facevo il axes.plot. Per questo non vedevo nulla!! Bisogna creare la figura nella stessa cella di Jupyter!</p>

<p>Quindi ricapitolando:</p>
<ul>
  <li>creo un oggetto <code class="language-plaintext highlighter-rouge">figura</code>    ( me lo immagino come un foglio bianco di una certa dimensione)</li>
  <li>creo un oggetto <code class="language-plaintext highlighter-rouge">axes</code> che e’ ottenuto da un metodo della <code class="language-plaintext highlighter-rouge">figura</code>  ( e’ il grafico vero e proprio, definito dagli assi sopra, sotto e destra e sinistra. Al suo interno posso poi mettere dei disegni tramite il metodo plot)</li>
  <li>tramite metodi di <code class="language-plaintext highlighter-rouge">axes</code> aggiungo delle caratteristiche come le label</li>
  <li>tra i <strong>metodi</strong> di un axes c’e’ <code class="language-plaintext highlighter-rouge">plot</code> (e altri tipi di grafico che potrei fare direttamente con plt). Chiamando un metodo che disegna da un axes, il grafico viene messo su questo axes.</li>
  <li>posso aggiungere piu’ di un grafico sullo stesso axes, basta chiamare piu’ volte un metodo che disegna sull’axes.</li>
  <li>nota che si deve fare un axes.plot per ognuno dei disegni che voglio compaiano nella figura!</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fig_1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">dpi</span> <span class="o">=</span><span class="mi">100</span><span class="p">)</span> <span class="c1"># istanzio una FIGURA chiamata 'fig_1' 
</span><span class="n">axes_1</span> <span class="o">=</span> <span class="n">fig_1</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.9</span><span class="p">,</span><span class="mf">0.9</span><span class="p">])</span>  <span class="c1"># istanzio un AXES (axes_1), della figura 'fig_1'
</span><span class="n">axes_1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">'Days new'</span><span class="p">)</span>               <span class="c1"># LABEL degli assi
</span><span class="n">axes_1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">'Days squared new'</span><span class="p">)</span>       <span class="c1"># LABEL degli assi
</span><span class="n">axes_1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">'Ciao new'</span><span class="p">)</span>                <span class="c1"># TITOLO degli assi
</span><span class="n">axes_1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span> <span class="n">y_1</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s">'x/x$^2$'</span><span class="p">)</span>    <span class="c1">#  GRAFICO 1  (all'interno di axes_1)
</span><span class="n">axes_1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">y_1</span><span class="p">,</span> <span class="n">x_1</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s">'x^2/x'</span><span class="p">)</span>      <span class="c1">#  GRAFICO 2  (all'interno di axes_1)
</span><span class="n">axes_1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span> <span class="o">=</span><span class="mi">0</span> <span class="p">)</span>                      <span class="c1"># Loc=0 e' la migliore location scelta da lui
# 1=alt dx; 2=alto sx; 3=basso sx, 4 basso dx 
# oppure si fornisce una tupla di x e y dall'angolo in basso a sinistra
</span><span class="n">tu</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">)</span> <span class="c1"># (tupla) questi valori sono in frazione rispetto alla grandezza totale, vedi sotto 
</span><span class="n">axes_1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">tu</span> <span class="p">);</span>  <span class="c1"># posizione della legenda
</span></code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_13_0.png" alt="png" /></p>

<h2 id="molte-curve-versione-veloce">Molte curve: versione veloce</h2>
<p>se devo fare un grafico veloce, basta che passo le x e y di tutti i grafici in ordine 
al plot, in questo modo verranno visualizzati tutti! Se non metto <code class="language-plaintext highlighter-rouge">color='black'</code> di default le due curve avranno colori diversi</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span> <span class="n">y_1</span><span class="p">,</span> <span class="n">x_1</span><span class="p">,</span> <span class="n">y_1</span><span class="o">/</span><span class="mi">3</span><span class="p">);</span>                   <span class="c1"># disegna le 2 funzioni 
</span></code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_15_0.png" alt="png" /></p>

<h2 id="axes-innestati">Axes innestati</h2>
<p>Voglio ora inserire piu’ di un <code class="language-plaintext highlighter-rouge">axes</code> nella stessa figura. In pratica aggiungo un axes all’esempio precedente.</p>

<p>Per fare questo devo creare un altro axes, proprio perche’ in questo caso
i dati si riferiscono ad assi diverse che devono essere definite.</p>

<p>Ricapitolando:</p>

<ul>
  <li>nell’esempio sopra ci sono una curva  blu e una arancione, sono comunque riferite allo stesso axes. Questi axes vanno da 0 a 25 (circa).</li>
  <li>se voglio inserire una <strong>figura nuova</strong>, i punti di questa figura saranno riferiti a un nuovo sistema di assi, ho quindi bisogno di inserire questi nuovi assi, creando un nuovo oggetto axes (con un nome diverso)</li>
  <li>dovro’ quindi indicare dove si collocano questi nuovi assi rspetto alla <code class="language-plaintext highlighter-rouge">figure</code></li>
  <li>dovro’ anche indicare la loro grandezza, anche in questo caso rispetto alla <code class="language-plaintext highlighter-rouge">figure</code></li>
</ul>

<p><strong>Testo nella figura</strong></p>
<ul>
  <li>per inserire un testo nel disegno si usa il metodo <code class="language-plaintext highlighter-rouge">text</code> di <code class="language-plaintext highlighter-rouge">axes</code>.</li>
  <li>Le coordinate sono riferite all’<code class="language-plaintext highlighter-rouge">axes</code> e partono dal <strong>basso</strong> a <strong>sinistra</strong>.</li>
  <li>Nota che nel disegno sotto ho 2 axes, e il messaggio e’ riferito ad <code class="language-plaintext highlighter-rouge">axes_2</code>. Questo e’ ovvio perche’ e’ chiamato come un metodo di questo axes</li>
  <li>Nota inoltre che <code class="language-plaintext highlighter-rouge">axes_2.text(0,40,'message')</code> fa uscire dal disegno, in quanto per il disegno l’asse delle y arriva solo fino a circa 25!</li>
</ul>

<p>nell’esempio di qui sotto:</p>
<ul>
  <li>il primo axis contiene due curve</li>
  <li>il secondo axis contiene una curva</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fig_1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">dpi</span> <span class="o">=</span><span class="mi">100</span><span class="p">)</span>     <span class="c1"># FIGURA 1
</span><span class="n">assi_1</span> <span class="o">=</span> <span class="n">fig_1</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.9</span><span class="p">,</span><span class="mf">0.9</span><span class="p">])</span>      <span class="c1"># ASSI_1 
</span><span class="n">assi_1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">'Days new'</span><span class="p">)</span>           
<span class="n">assi_1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">'Days squared new'</span><span class="p">)</span>
<span class="n">assi_1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">'Ciao new'</span><span class="p">)</span>
<span class="n">assi_1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span> <span class="n">y_1</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s">'x/x$^2$'</span><span class="p">)</span>        <span class="c1">#  GRAFICO 1 (degli "ASSI_1")
</span><span class="n">assi_1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">y_1</span><span class="p">,</span> <span class="n">x_1</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s">'x^2/x'</span><span class="p">)</span>          <span class="c1">#  GRAFICO 2 (degli "ASSI_1")
</span><span class="n">assi_1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span> <span class="o">=</span><span class="mi">0</span> <span class="p">)</span>                          <span class="c1"># Loc=0 e' la migliore location scelta da lui
</span>
<span class="c1">########   costruisco i secondi assi #####################
</span><span class="n">assi_2</span> <span class="o">=</span> <span class="n">fig_1</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mf">0.45</span><span class="p">,</span> <span class="mf">0.45</span><span class="p">,</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">0.3</span><span class="p">])</span>   <span class="c1"># ASSE 2
</span><span class="n">assi_2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">'Days new'</span><span class="p">)</span>                      
<span class="n">assi_2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">'Days squared new'</span><span class="p">)</span>
<span class="n">assi_2</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">'Ciao dentro'</span><span class="p">)</span>
<span class="n">assi_2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span> <span class="n">y_1</span><span class="p">,</span> <span class="s">'r'</span><span class="p">)</span>  <span class="c1">#  GRAFICO 2        # GRAFICO 1 (degli "ASSI_2")  
</span>

<span class="c1">#assi_2.text(0,40, 'Message')  # testo
</span><span class="n">assi_2</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span> <span class="s">'Message'</span><span class="p">)</span>  <span class="c1"># testo
</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Text(0, 40, 'Message')
</code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_18_1.png" alt="png" /></p>

<h1 id="subplots-una-griglia-di-grafici">subplots() Una griglia di grafici</h1>

<p><strong>OCCHIO</strong>:  <code class="language-plaintext highlighter-rouge">plt.subplots()</code>$\neq$<code class="language-plaintext highlighter-rouge">plt.subplot()</code> (il primo termina in <strong>s</strong>)</p>

<p>Il singolo comando <code class="language-plaintext highlighter-rouge">subplots</code> in pratica costruisce 2 oggetti:</p>
<ul>
  <li>una <strong>figure</strong></li>
  <li>una <strong>array di assi</strong> (ma un array di numpy puo’ contenere degli oggetti strani? non erano solo numeri? no! basta che in tutti gli oggetti siano dello stesso tipo:  omogeneita’ degli array).</li>
  <li>devo quindi descrivere/inizializzare ognuno dei possibili axes dell’array, altrimenti ho solo gli assi senza nessun disegno dentro.</li>
</ul>

<p>In pratica e’ una specie di scorciatoia per ordinare facilmente degli axis in una figure in modo che siano esattamente alle posizioni della griglia che viene definita con il comando, per esempio indicando il numero di colonne e di righe. Altrimenti avrei potuto istanziare una figura, e istanziare tanti axes stando attento a metterli nel posto giusto all’interno della figura.</p>

<p><strong>Attenzione</strong> se voglio mettere degli axes aggiuntivi (oltre all’array di axes iniziale), posso farlo, occhio pero’ che si riferiranno tutti alla <code class="language-plaintext highlighter-rouge">figure</code> per quanto riguarda la posizione e non avranno un particolare ordinamento o forma. Dovro’ essere io a stare attento a metterli nel posto corretto e con la forma corretta!</p>

<ul>
  <li>
    <p>il comando <code class="language-plaintext highlighter-rouge">plt.tight_layout()</code> aiuta a non fare sovrapporre le label.</p>
  </li>
  <li>Attento che devi usare il nome della figura corretto <code class="language-plaintext highlighter-rouge">fig_2</code></li>
  <li>Attento: <strong>non</strong> usare un nome gia’ usato per un altro axes, come <code class="language-plaintext highlighter-rouge">axes_2</code></li>
  <li>Attento: la dimensione del subplot e’ riferita al figsize, non all’axes di cui e’ subplot. Per questo trasborda!</li>
  <li>Attento: se costruisci un nuovo axes viene messo <strong>sopra</strong> l’axis genitore, e per questo lo (puo’) coprire.</li>
  <li>Di default un axes <strong>non</strong> e’ trasparente!</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fig_2</span> <span class="p">,</span> <span class="n">axes_2</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">nrows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span> <span class="mi">3</span><span class="p">)</span> 
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>                    <span class="c1"># evita la sovrapposizione delle label
</span><span class="n">axes_2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">'Plot 2'</span><span class="p">)</span>
<span class="n">axes_2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">'x'</span><span class="p">)</span>
<span class="n">axes_2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">'x quadro'</span><span class="p">)</span>
<span class="n">axes_2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span> <span class="n">y_1</span><span class="p">)</span>

<span class="c1"># Nuovo AXES che non fa parte dell'array creato con   subplots
</span>
<span class="n">axes_3</span> <span class="o">=</span> <span class="n">fig_2</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mf">0.45</span><span class="p">,</span> <span class="mf">0.45</span><span class="p">,</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">0.4</span><span class="p">])</span>
<span class="n">axes_3</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">'Days new'</span><span class="p">)</span>
<span class="n">axes_3</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">'Days squared new'</span><span class="p">)</span>
<span class="n">axes_3</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">'Ciao straripante'</span><span class="p">)</span>
<span class="n">axes_3</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span> <span class="n">y_1</span><span class="p">,</span> <span class="s">'r'</span><span class="p">)</span>  <span class="c1">#  GRAFICO 2
</span>
<span class="n">axes</span> <span class="o">=</span> <span class="n">fig_2</span><span class="o">.</span><span class="n">add_axes</span> <span class="p">([</span><span class="mf">0.085</span><span class="p">,</span><span class="mf">0.15</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.7</span><span class="p">])</span>
<span class="n">axes</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span><span class="n">y_1</span><span class="p">,</span> <span class="s">'co'</span><span class="p">)</span>
<span class="n">axes</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">'Dentro'</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Text(0.5, 1.0, 'Dentro')
</code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_20_1.png" alt="png" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">nrows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span> <span class="mi">3</span><span class="p">)</span> 
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>          

<span class="c1">############ Axes Centrale ###############
</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">'Centrale'</span><span class="p">)</span>
<span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">'x'</span><span class="p">)</span>
<span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">'x quadro'</span><span class="p">)</span>
<span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span> <span class="n">y_1</span><span class="p">)</span>

<span class="c1">############ Axes Ciao Dentro ############
</span><span class="n">a1</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mf">0.45</span><span class="p">,</span> <span class="mf">0.45</span><span class="p">,</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">0.4</span><span class="p">])</span>
<span class="n">a1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">'Days now'</span><span class="p">)</span>
<span class="n">a1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">'Days squared new'</span><span class="p">)</span>
<span class="n">a1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">'Tra centro e sinistra'</span><span class="p">)</span>
<span class="n">a1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span> <span class="n">y_1</span><span class="p">,</span> <span class="s">'r'</span><span class="p">)</span>  <span class="c1">#  GRAFICO 2 della figura centrale
</span>
<span class="c1">############ Axes Sinistro ###############
</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">'Sinistra'</span><span class="p">)</span>
<span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">'x'</span><span class="p">)</span>
<span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">'x quadro'</span><span class="p">)</span>
<span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span> <span class="o">-</span><span class="n">y_1</span><span class="p">,</span><span class="s">'g'</span><span class="p">)</span>

<span class="c1">############ Axes Piccolo sinistra  ######
</span><span class="n">a0</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">])</span>
<span class="n">a0</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">'Days old'</span><span class="p">)</span>
<span class="n">a0</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">'Days squared new'</span><span class="p">)</span>
<span class="n">a0</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">'Piccolo Sinistra'</span><span class="p">)</span>
<span class="n">a0</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span> <span class="n">y_1</span><span class="p">,</span> <span class="s">'r'</span><span class="p">)</span>  <span class="c1">#  GRAFICO 2 della figura centrale
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[&lt;matplotlib.lines.Line2D at 0x2de66e3a190&gt;]
</code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_21_1.png" alt="png" /></p>

<h1 id="colori-e-apparenza">Colori e Apparenza</h1>
<p>I colori di default sono:</p>
<ul>
  <li>r = red</li>
  <li>c = cyan</li>
  <li>m = magenta</li>
  <li>y = yellow</li>
  <li>k = black</li>
  <li>w = white</li>
</ul>

<p>Inoltre</p>

<ul>
  <li>color=”0.75” crea un 75% gray  (e’ una percentuale di black)</li>
  <li>si possono usare i colori con hexcodes   color=”#eeefff”</li>
  <li>
    <p>si possono usare i colori tipo color=”burlywood” che si trovano a https://en.wikipedia.org/wiki/Web_colors</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">lw</code> come gnuplot, ma devo mettere l’uguale, p.es. <code class="language-plaintext highlighter-rouge">lw=2</code></li>
  <li>ls ‘-.’  si trovano qui: https://matplotlib.org/3.1.0/gallery/lines_bars_and_markers/linestyles.html</li>
  <li>marker sono i <strong>punti</strong>: https://matplotlib.org/3.3.3/api/markers_api.html</li>
  <li>markersize = grandezza del punto</li>
  <li>markerfacecolor = colore di riempimento del punto</li>
  <li>makeredgecolor  = colore del bordo del punto</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fig_3</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">axes_3</span>  <span class="o">=</span> <span class="n">fig_3</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">axes_3</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span> <span class="n">y_1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'navy'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.75</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ls</span> <span class="o">=</span><span class="s">'-.'</span><span class="p">,</span> <span class="n">marker</span> <span class="o">=</span> <span class="s">'o'</span><span class="p">,</span> 
           <span class="n">markersize</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">markerfacecolor</span> <span class="o">=</span><span class="s">'y'</span><span class="p">,</span> <span class="n">markeredgecolor</span><span class="o">=</span><span class="s">'k'</span><span class="p">,</span> <span class="n">markeredgewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[&lt;matplotlib.lines.Line2D at 0x2de66eaa970&gt;]
</code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_23_1.png" alt="png" /></p>

<h1 id="grandezza-degli-assi-e-background">Grandezza degli assi e background</h1>
<p>I comandi per gestire gli assi  assomigliano a quelli di gnuplot, ma solo un po’ piu’ “verbose”, in cui
si deve scrivere di piu’.</p>

<p>Possimo anche mettere una griglia e il background color.</p>

<ul>
  <li>axes_3.<code class="language-plaintext highlighter-rouge">set_xlim([0,3])</code>                           limiti asse x</li>
  <li>axes_3.<code class="language-plaintext highlighter-rouge">grid(True, color='0.6', dashes=(5,2,1,2))</code> caratteristiche della griglia (<strong>NON</strong> dello sfondo!), dashes mette delle linee tratteggiate attraverso il disegno. Quindi qui sono le righe che partono da un tic e arrivano dall’altra parte del disegno</li>
  <li>axes_3.<code class="language-plaintext highlighter-rouge">set_facecolor('#FAEBD7')</code>                  colore di sfondo</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fig_3</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="n">axes_3</span>  <span class="o">=</span> <span class="n">fig_3</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">axes_3</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span> <span class="n">y_1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'navy'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.75</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ls</span> <span class="o">=</span><span class="s">'-.'</span><span class="p">,</span> <span class="n">marker</span> <span class="o">=</span> <span class="s">'o'</span><span class="p">,</span> 
           <span class="n">markersize</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">markerfacecolor</span> <span class="o">=</span><span class="s">'y'</span><span class="p">,</span> <span class="n">markeredgecolor</span><span class="o">=</span><span class="s">'k'</span><span class="p">,</span> <span class="n">markeredgewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">axes_3</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">axes_3</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">25</span><span class="p">])</span>

<span class="c1">#axes_3.grid(True, color='0.6', dashes=(5,2,1,2))   # mettiamo una griglia non lasciamo vuoto 
</span><span class="n">axes_3</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">False</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'r'</span><span class="p">,</span> <span class="n">dashes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> 

<span class="c1">#axes_3.set_facecolor('#FAEBD7')
</span><span class="n">axes_3</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="s">'w'</span><span class="p">)</span>

</code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_25_0.png" alt="png" /></p>

<h1 id="salvare-una-figura-a-file">Salvare una figura a file</h1>
<p>strano quando lavoravo con Seaborn sembrave che il save dovesse avvenire nella stessa cella dove si faceva il disegno.</p>
<ul>
  <li>Basta mettere il nome dell’estensione e lui salva correttamente nel formato corrispondente</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fig_3</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">'ultimoPlot.png'</span><span class="p">)</span>
</code></pre></div></div>

<h1 id="pandas">Pandas</h1>
<p>Qui usiamo l’ICE CREAM data table (che diventera’ un DataFrame). Ho copiato il dataframe del video.</p>

<ul>
  <li>
    <p><strong>Assegno</strong> dei nomi alle colonne del csv, mentre leggo il file: <code class="language-plaintext highlighter-rouge">ics_df = pd.read_csv('icecream.csv', names=['temps', 'sales'])</code>  . Nota che io ho usato i nomi sales  e temps (temperatures). Lui li aveva con la prima lettera in maiuscolo. Temp e’ in Farenheit, e sales e’ in unita’ di gelato.</p>
  </li>
  <li>
    <p>Se non usassi il parametro <code class="language-plaintext highlighter-rouge">names=...</code> lui prenderebbe la prima riga e la trasformerebbe nei nomi delle colonne (e i valori della prima riga non sarebbero accessibili)!</p>
  </li>
  <li>
    <p><strong>Osservazione</strong>: il metodo dei DataFrame <code class="language-plaintext highlighter-rouge">sort_values(by='temps')</code> lavora <strong>inplace</strong>, quindi modifica il df!</p>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ics_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">'icecream.csv'</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s">'temps'</span><span class="p">,</span> <span class="s">'sales'</span><span class="p">])</span>
<span class="n">ics_df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</code></pre></div></div>

<div>
<style scoped="">
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>temps</th>
      <th>sales</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>37</td>
      <td>292</td>
    </tr>
    <tr>
      <th>1</th>
      <td>40</td>
      <td>228</td>
    </tr>
    <tr>
      <th>2</th>
      <td>49</td>
      <td>324</td>
    </tr>
    <tr>
      <th>3</th>
      <td>61</td>
      <td>376</td>
    </tr>
    <tr>
      <th>4</th>
      <td>72</td>
      <td>440</td>
    </tr>
  </tbody>
</table>
</div>

<p>Attento <code class="language-plaintext highlighter-rouge">sort_values()</code> lavora <strong>inplace</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ics_df</span> <span class="o">=</span> <span class="n">ics_df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s">'temps'</span><span class="p">)</span>  <span class="c1"># LAVORA INPLACE
</span></code></pre></div></div>

<p>A questo punto lui fa delle cose che sembrano non necessarie.  Prende e converte il <em>DataFrame</em> in un <em>array</em> di Numpy.
Poi prende e scrive le x e le y da questo array di numpy. In effetti ho notato in una sezione sotto che alle volte e’ davvero meglio avere dei numpy array invece che i dataframe, in particolare per evitare dei valori strani sull’asse delle x.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#   con numpy array ###############
#  np_arr = ics_df.values    # prende solo i valori, rimuove le etichette
#  x_2 = np_arr[:,0]         # seleziono colonna 0
#  y_2 = np_arr[:,1]         # seleziono colonna 1  
###################################
</span></code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Alternativa:
</span><span class="n">x_2</span> <span class="o">=</span> <span class="n">ics_df</span><span class="o">.</span><span class="n">temps</span> <span class="c1"># non sono array di np, ma serie di Pandas vanno bene lo stesso
</span><span class="n">y_2</span> <span class="o">=</span> <span class="n">ics_df</span><span class="o">.</span><span class="n">sales</span> <span class="c1"># ricorda puoi usare l nome di una colonna per selezionare tutta le colonna come se fosse un attributo
</span>
<span class="c1">#x_2 = np.array(ics_df.temps) # NON serve... ora, ma in alcuni casi si'
#y_2 = np.array(ics_df.sales) # NON serve... ora, ma in alcuni casi si'
</span></code></pre></div></div>

<p>ok ma fino a qui, dove ha usto il fatto che sia Pandas?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fig_4</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">axes_4</span> <span class="o">=</span> <span class="n">fig_4</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># prendo tutto lo spazio, dall'angolo in basso a sx a quello in alto a dx
</span><span class="n">axes_4</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">'da Pandas: IceCream'</span><span class="p">)</span>
<span class="n">axes_4</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">'temp'</span><span class="p">)</span>
<span class="n">axes_4</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">'sales'</span><span class="p">)</span>
<span class="n">axes_4</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_2</span><span class="p">,</span> <span class="n">y_2</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'+'</span><span class="p">);</span>  <span class="c1"># ho messo sui punti le crocette come in Gnuplot
</span></code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_36_0.png" alt="png" /></p>

<h1 id="annotare-la-figura">Annotare la figura</h1>
<p>Se voglio mettere delle annotazioni nel grafico, come per esempio delle frecce, devo usare un metodo degli axes chiamato <code class="language-plaintext highlighter-rouge">annotate</code>. Vediamo nel dettaglio il comando:
<code class="language-plaintext highlighter-rouge">axes_4.annotate('Good Month', xy=(83, 536), xytext=(60,520), arrowprops= dict(facecolor='black', shrink=0.0, width=0.5))</code></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">'Good Month'</code> e’ il testo che viene inserito</li>
  <li><code class="language-plaintext highlighter-rouge">xy=(83,536)</code>  e’ il punto di arrivo della freccia</li>
  <li><code class="language-plaintext highlighter-rouge">xytext=(60,520)</code> e’ il punto di partenza del testo <strong>orizzontale</strong></li>
</ul>

<p>All’interno di <code class="language-plaintext highlighter-rouge">arrowprops</code> si hanno vari parametri (si deve passare un dizionario con tutti gli argomenti)</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">facecolor</code>= ‘black’</li>
  <li><code class="language-plaintext highlighter-rouge">shrink=0.5</code>   indica quanto piu’ corta deve essere la freccia, rispetto alla lunghezza massima che va dalla fine del testo al punto di arrivo della freccia.</li>
  <li><code class="language-plaintext highlighter-rouge">width=0.5</code> possiamo anche allargare la larghezza</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fig_4</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">axes_4</span> <span class="o">=</span> <span class="n">fig_4</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># prendo tutto lo spazio, dall'angolo in basso a sx a quello in alto a dx
</span><span class="n">axes_4</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">'da Pandas: IceCream'</span><span class="p">)</span>
<span class="n">axes_4</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">'temp'</span><span class="p">)</span>
<span class="n">axes_4</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">'sales'</span><span class="p">)</span>
<span class="n">axes_4</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_2</span><span class="p">,</span> <span class="n">y_2</span><span class="p">)</span>
<span class="n">axes_4</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s">'Good Month'</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="mi">83</span><span class="p">,</span> <span class="mi">536</span><span class="p">),</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span><span class="mi">520</span><span class="p">),</span>
                <span class="n">arrowprops</span><span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">facecolor</span><span class="o">=</span><span class="s">'black'</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.5</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Text(60, 520, 'Good Month')
</code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_38_1.png" alt="png" /></p>

<h1 id="bar-barchart-sotto-il-grafico">bar() Barchart sotto il grafico</h1>
<p><code class="language-plaintext highlighter-rouge">bar()</code>  e’ un metodo di <code class="language-plaintext highlighter-rouge">plt</code></p>

<p>Se voglio fare aggiungere anche le barchart sotto il grafico, basta disegnare ANCHE loro!</p>

<p><strong>Attento</strong> ho fatto 2 plot:</p>
<ol>
  <li>il primo e’ dato da <code class="language-plaintext highlighter-rouge">axes_4.plot(x_2, y_2)</code> ed e’ passato come un <strong>metodo</strong> degli assi</li>
  <li>il secondo e’ un grafico <em>veloce</em> ed e’ una <strong>funzione</strong> di matplotlib: <code class="language-plaintext highlighter-rouge">plt.bar(x_2, y_2, width=1.5);</code></li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fig_4</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">axes_4</span> <span class="o">=</span> <span class="n">fig_4</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># prendo tutto lo spazio, dall'angolo in basso a sx a quello in alto a dx
</span><span class="n">axes_4</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">'da Pandas: IceCream'</span><span class="p">)</span>
<span class="n">axes_4</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">'temp'</span><span class="p">)</span>
<span class="n">axes_4</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">'sales'</span><span class="p">)</span>
<span class="n">axes_4</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_2</span><span class="p">,</span> <span class="n">y_2</span><span class="p">)</span>
<span class="n">axes_4</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s">'Good Month'</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="mi">83</span><span class="p">,</span> <span class="mi">536</span><span class="p">),</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span><span class="mi">520</span><span class="p">),</span>
                <span class="n">arrowprops</span><span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">facecolor</span><span class="o">=</span><span class="s">'black'</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.5</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">x_2</span><span class="p">,</span> <span class="n">y_2</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">1.5</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_40_0.png" alt="png" /></p>

<h2 id="impulsi-stem---e-proprieta-setp">Impulsi stem()   e proprieta’ setp()</h2>
<p>In gnuplot mettevo <em>with impulses</em> quando volevo che il grafico avesse delle linee verticali che partono dall’asse x e raggiungono ogni punto. Il comando descritto qui sopra <code class="language-plaintext highlighter-rouge">bar()</code> non e’ l’ideale per ottenere questo risultato in quanto la larghezza dell’impulso puo’ creare problemi, meglio usare la funzione:</p>

<p><code class="language-plaintext highlighter-rouge">plt.stem()</code></p>

<p>mentre posso decidere di colorare l’asse sotto tramite la funzione set property:</p>

<p><code class="language-plaintext highlighter-rouge">plt.setp()</code></p>

<p>Questa funzione puo’ essere usata per vari oggetti!</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fig_4</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">axes_4</span> <span class="o">=</span> <span class="n">fig_4</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># prendo tutto lo spazio, dall'angolo in basso a sx a quello in alto a dx
</span><span class="n">axes_4</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">'da Pandas: IceCream'</span><span class="p">)</span>
<span class="n">axes_4</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">'temp'</span><span class="p">)</span>
<span class="n">axes_4</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">'sales'</span><span class="p">)</span>
<span class="n">axes_4</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_2</span><span class="p">,</span> <span class="n">y_2</span><span class="p">)</span>
<span class="n">axes_4</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s">'Good Month'</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="mi">83</span><span class="p">,</span> <span class="mi">536</span><span class="p">),</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span><span class="mi">520</span><span class="p">),</span>
                <span class="n">arrowprops</span><span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">facecolor</span><span class="o">=</span><span class="s">'black'</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.5</span><span class="p">))</span>
<span class="n">markerline</span><span class="p">,</span> <span class="n">stemlines</span><span class="p">,</span> <span class="n">baseline</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">stem</span><span class="p">(</span><span class="n">x_2</span><span class="p">,</span> <span class="n">y_2</span><span class="p">,</span> <span class="s">'-.'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">baseline</span><span class="p">,</span> <span class="s">'color'</span><span class="p">,</span> <span class="s">'r'</span><span class="p">,</span> <span class="s">'linewidth'</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[None, None]
</code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_42_1.png" alt="png" /></p>

<h1 id="tex---regular-expressions">TeX - regular expressions</h1>
<p>possiamo usare Latex per scriver formule matematiche usando per esempio $\frac{1}{2}$</p>

<ul>
  <li><strong>IMPORTANTE</strong> nota che nel tutorial ha usato: <code class="language-plaintext highlighter-rouge">r'$\alpha \beta \gamma$'</code>  non ha semplicemente messo ‘’ perche’ cosi’ prende le <code class="language-plaintext highlighter-rouge">regular expression</code>,
come il dollaro e lo slash.</li>
</ul>

<p>Ovvero la scrittura  r’ciao $\frac{2}{3}’ crea una stringa che pero’ ha delle regular expression che vengono valutate ed eseguite.</p>

<ul>
  <li>basta poi ricordare i comandi di Latex</li>
  <li>il metodo <code class="language-plaintext highlighter-rouge">.text</code> degli ‘axes’ mette ha all’inizio le coordinate (separate da una virgola), poi una virgola con il testo da inserire.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fig_5</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">axes_5</span> <span class="o">=</span> <span class="n">fig_5</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">])</span>                       <span class="c1"># costruisco un axes
</span>
<span class="n">axes_5</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">23</span><span class="p">,</span> <span class="s">r'$\alpha~ \beta~ \gamma ~ \frac{1}{2} ~\Sigma$'</span><span class="p">)</span> <span class="c1"># prima le coordinate del testo, poi il testo
</span>
<span class="n">axes_5</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span> <span class="n">y_1</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[&lt;matplotlib.lines.Line2D at 0x2de66ff15e0&gt;]
</code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_44_1.png" alt="png" /></p>

<h1 id="istogrammi-plthist">Istogrammi plt.hist()</h1>

<p>Alcuni argomenti utili per gli istogrammi:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">stacked=True</code></li>
  <li></li>
</ul>

<p>Simuliamo probabilita’ di lancio di 2 dadi. Ci sono 11 possibili valori per la somma:</p>
<ul>
  <li>1+1 =2  I</li>
  <li>1+2 =3  II</li>
  <li>1+3 =4  III</li>
  <li>1+4 =5  IV</li>
  <li>1+5 =6  V</li>
  <li>1+6 =7  VI</li>
  <li>2+6 =8  VII  (nota che tutti gli altri valori di (2+qualcosa) danno dei risultati gia’ ottenuti)</li>
  <li>3+6 =9  VIII</li>
  <li>4+6 =10 IX</li>
  <li>5+6 =11 X</li>
  <li>6+6 =12 XI
Come altri parametri:</li>
  <li><code class="language-plaintext highlighter-rouge">density=True</code> mostra la frequenza di ogni bin (se e’ falso mostra il conteggio)</li>
  <li><code class="language-plaintext highlighter-rouge">stacked=True</code> cosa fa?</li>
</ul>

<p><strong>Attento</strong>: ricorda che il numero di <code class="language-plaintext highlighter-rouge">bins</code> puo’ portare a risultati MOLTO fuorvianti. Per esempio se scegliamo <code class="language-plaintext highlighter-rouge">bins=7</code> otteniamo un oggetto bicefalo attorno al centro. Se invece scegliamo <code class="language-plaintext highlighter-rouge">bins=11</code> otteniamo una campana!</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">arr_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">5000</span><span class="p">)</span> <span class="c1"># genera 5000 numeri interi tra 1 e 6
</span><span class="n">arr_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">5000</span><span class="p">)</span> <span class="c1"># genera 5000 numeri interi tra 1 e 6
</span><span class="n">arr_3</span> <span class="o">=</span><span class="n">arr_1</span><span class="o">+</span><span class="n">arr_2</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">arr3ok</span> <span class="o">=</span> <span class="n">arr_3</span>
<span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">arr3ok</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span> <span class="mi">7</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">stacked</span> <span class="o">=</span><span class="bp">False</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_47_0.png" alt="png" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">arr_3</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span> <span class="mi">11</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">stacked</span> <span class="o">=</span><span class="bp">True</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_48_0.png" alt="png" /></p>

<h2 id="ax0hist-axes-e-istogrammi">ax[0].hist() Axes e istogrammi</h2>

<p>Qui sotto provo a combinare axes e istogrammi.</p>
<ul>
  <li>Ho supposto di poter usare il metodo <code class="language-plaintext highlighter-rouge">hist()</code> direttamente su un asse invece che dover usare un <code class="language-plaintext highlighter-rouge">plt.hist</code>, ovvero:
<code class="language-plaintext highlighter-rouge">axes.hist(...)</code></li>
</ul>

<p>Funge!</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fig</span> <span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">nrows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span> <span class="mi">2</span><span class="p">)</span> 
<span class="c1">#plt.tight_layout()          
</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span> <span class="n">arr_3</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span> <span class="mi">11</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">stacked</span> <span class="o">=</span><span class="bp">True</span><span class="p">);</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span> <span class="n">arr_3</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span> <span class="mi">11</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">stacked</span> <span class="o">=</span><span class="bp">False</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_50_0.png" alt="png" /></p>

<p>altri argomenti che si possono passare:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Range</code> deve essere una <strong>tupla</strong> con il range di cui si e’ interessati</li>
  <li><code class="language-plaintext highlighter-rouge">cumulative =True</code>  costruisce la <strong>CDF</strong> (cumulative distribution function) dati i valori. Attento non me lo prendeva (diceva qualcosa riguardo l’oggetto kernel). Non ho lanciato tutte le altre celle, ma solo quelle iniziali con gli header e quelle della cella Istogramma</li>
  <li><code class="language-plaintext highlighter-rouge">histtype= 'step'</code> genera un grafo con le linee (ma vuoto)</li>
  <li><code class="language-plaintext highlighter-rouge">color = 'orange'</code> colora  di arancione…</li>
  <li><code class="language-plaintext highlighter-rouge">orientation = 'horizontal'</code>  gira di 90 gradi l’istogramma
posso combinare anche due istogrammi insieme come con gli altri plot.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">arr_3</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span> <span class="mi">11</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">stacked</span> <span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">cumulative</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
         <span class="n">histtype</span><span class="o">=</span><span class="s">'step'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'blue'</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span> <span class="s">'horizontal'</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_52_0.png" alt="png" /></p>

<h1 id="bar-charts">Bar charts</h1>

<p>Che differenza c’e’ tra un grafo a barre e un istogramma? de facto nell’istogramma si mettono le frazioni e le “barre” sono attaccate l’una all’altra. In un bar chart invece si hanno i numeri e le barre non sono attaccate l’una all’altra, questo perche’ sull’asse delle x spesso <strong>non si hanno dei valori numerici</strong>, ma categorici (come nell’esempio riportato sotto, dove l’ordine delle colonne e’ sostanzialmente arbitrario).</p>

<p>Per un grafo a barre, si chiama la funzione seguente:</p>

<p><code class="language-plaintext highlighter-rouge">plt.bar(spc, m_eng,width=larghezza, label='maschi', edgecolor ='k')</code></p>

<ul>
  <li>il <strong>primo</strong> argomento contiene la <strong>lista/tupla</strong> con i <strong>nomi</strong> che appaiono sull’asse delle x (dato che spesso lo usiamo per variabili categoriche dobbiamo indicare le label), oppure le <strong>posizioni</strong> delle barre (se ho le posizioni dovro’ poi aggiungere le label sull’asse)</li>
  <li><strong>Attento</strong> se nella prima tupla ci sono dei nomi, allora le loro posizioni sono equispaziate automaticamente. Se io aggiungo un altro bar chart, questo secondo viene messo dopo quelle gia’ esistenti.</li>
  <li><strong>Attento</strong> se invece nella prima tupla ci sono dei float (che quindi definisce la posizione delle barre), allora facendo un secondo plot, quest’ultimo segue le proprie posizioni.</li>
  <li><strong>Attento</strong> pui mettere 2 bar chart, uno con variabili categoriche e uno con float. Le posizioni delle categoriche sono messe automaticamente in integer (che partono quindi da zero). Nell’esempio qui sotto, la barra di <em>nuclear</em> ha posizione sull’asse delle x uguale a 0, <em>hydro</em> e’ in posizione 1, …</li>
  <li>il <strong>secondo</strong> argomento contiene l’array che con le <strong>altezze</strong> della barchart</li>
  <li>yerr ???  serve per la barra che indica l’<strong>errore</strong>, ed e’ un array che deve contenere tanti oggetti quante sono le barre</li>
  <li><strong>width</strong>  larghezza della barra (altrimenti da’ errore? )</li>
  <li>label non la vedo… scritta forse bisogna attivarla. Anche nel video non fungeva</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">## energia francese
</span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="s">'nuclear'</span><span class="p">,</span> <span class="s">'hydro'</span><span class="p">,</span> <span class="s">'coal'</span><span class="p">,</span> <span class="s">'gas'</span><span class="p">,</span> <span class="s">'solar'</span><span class="p">,</span> <span class="s">'wind'</span><span class="p">,</span> <span class="s">'other'</span><span class="p">]</span>
<span class="n">per_1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">71</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>   <span class="c1"># percentuale
</span><span class="n">variance</span> <span class="o">=</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># varianza per anno
</span>
<span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">per_1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'purple'</span><span class="p">,</span><span class="n">yerr</span><span class="o">=</span><span class="n">variance</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">'prova'</span><span class="p">)</span>  
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;BarContainer object of 7 artists&gt;
</code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_54_1.png" alt="png" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">## energia francese
</span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="s">'nuclear'</span><span class="p">,</span> <span class="s">'hydro'</span><span class="p">,</span> <span class="s">'coal'</span><span class="p">,</span> <span class="s">'gas'</span><span class="p">,</span> <span class="s">'solar'</span><span class="p">,</span> <span class="s">'wind'</span><span class="p">,</span> <span class="s">'other'</span><span class="p">]</span>
<span class="n">per_1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">71</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>   <span class="c1"># percentuale
</span><span class="n">variance</span> <span class="o">=</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># varianza per anno
</span><span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">per_1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'purple'</span><span class="p">,</span><span class="n">yerr</span><span class="o">=</span><span class="n">variance</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">'prova'</span><span class="p">)</span>  
<span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">el</span> <span class="o">+</span> <span class="s">'   '</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>
<span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="s">'test1'</span><span class="p">,</span> <span class="s">'test2'</span><span class="p">,</span> <span class="s">'test3'</span><span class="p">]</span>
<span class="n">z2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>
<span class="n">per_2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">34</span><span class="p">,</span><span class="mi">43</span><span class="p">,</span><span class="mi">21</span><span class="p">]</span>
<span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">z2</span><span class="p">,</span> <span class="n">per_2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'red'</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">'prova'</span><span class="p">)</span> 
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;BarContainer object of 3 artists&gt;
</code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_55_1.png" alt="png" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">y</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>['nuclear   ',
 'hydro   ',
 'coal   ',
 'gas   ',
 'solar   ',
 'wind   ',
 'other   ']
</code></pre></div></div>

<h2 id="bar-chart-affiancate">Bar Chart affiancate</h2>
<p>Qui sotto mettiamo due bar chart affiancate una da parte all’altra. In questo modo possiamo confrontare dati diversi.
E’ fondamentale che la posizione dell’array che definisce l’asse delle x della seconda bar chart sia spostato rispetto all’asse delle x della prima bar chart di una quantita’ tale da non fare sovrapporre (a meno di volerlo). Per esempio di puo’ usare lo stesso array maggiorato della larghezza della barchart!</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">m_eng</span> <span class="o">=</span> <span class="p">(</span><span class="mi">76</span><span class="p">,</span><span class="mi">85</span><span class="p">,</span><span class="mi">86</span><span class="p">,</span><span class="mi">88</span><span class="p">,</span><span class="mi">93</span><span class="p">)</span>  <span class="c1"># percentuale maschi ingegneri
</span><span class="n">f_eng</span> <span class="o">=</span> <span class="p">(</span><span class="mi">24</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span>   <span class="c1"># femmine
</span>
<span class="n">spc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">larghezza</span> <span class="o">=</span><span class="mf">0.45</span>
<span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">spc</span>    <span class="p">,</span> <span class="n">m_eng</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="n">larghezza</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">'maschi'</span><span class="p">,</span> <span class="n">edgecolor</span> <span class="o">=</span><span class="s">'k'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">spc</span><span class="o">+</span><span class="n">larghezza</span><span class="p">,</span> <span class="n">f_eng</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="n">larghezza</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">'femmine'</span><span class="p">,</span> <span class="n">edgecolor</span> <span class="o">=</span><span class="s">'k'</span><span class="p">)</span>
<span class="c1">#plt.xticks(spc + larghezza/2, ('Aero', 'Chem', 'Civil', 'Elect', 'Mec'))
</span><span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">spc</span>   <span class="p">,</span> <span class="p">(</span><span class="s">'Aero'</span><span class="p">,</span> <span class="s">'Chem'</span><span class="p">,</span> <span class="s">'Civil'</span><span class="p">,</span> <span class="s">'Elect'</span><span class="p">,</span> <span class="s">'Mec'</span><span class="p">))</span> <span class="p">;</span>   <span class="c1"># altrimenti lo mette a meta' strada del primo istogramma
</span></code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_58_0.png" alt="png" /></p>

<h2 id="bar-chart-impilate-stacked">Bar Chart impilate (stacked)</h2>

<p>Qui mettiamo le barre una sopra l’altra.</p>

<p>Diamo un’occhiata alla list comprehension che viene usata:</p>

<p><code class="language-plaintext highlighter-rouge">ind = [x for x, _ in enumerate(t_type)]</code></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">enumerate</code> restituisce delle coppie: posizione, oggetto.</li>
  <li>Non ci serve l’oggetto ma solo la posizione, qunidi non spreco una variabile y, metto _</li>
  <li>Prendi tutte le posizioni che ci sono nell’oggetto t_type</li>
  <li>questa volta la label e’ apparsa nella legenda.</li>
</ul>

<p><strong>ATTENTO</strong></p>
<ul>
  <li>il parametro <code class="language-plaintext highlighter-rouge">bottom</code> dice cosa c’e’ sotto di questa barchart. In particolare possiamo indicare un array, o anche una somma di array come nell’esempio di cui sotto. Se mettiamo un array che viene disegnato nella barchart, allora stiamo in pratica impilando il nuovo barchart sopra quello dell’altro array</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#############   DATI ######################
</span><span class="n">t_type</span><span class="o">=</span> <span class="p">[</span><span class="s">'kind'</span><span class="p">,</span> <span class="s">'elem'</span><span class="p">,</span> <span class="s">'sec'</span><span class="p">,</span> <span class="s">'special'</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">t_type</span><span class="p">))</span>
<span class="n">m_teach</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">44</span><span class="p">,</span><span class="mi">14</span><span class="p">])</span>
<span class="n">f_teach</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">98</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">56</span><span class="p">,</span><span class="mi">86</span><span class="p">])</span>
<span class="n">n_teach</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">12</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">15</span><span class="p">])</span>

<span class="n">ind</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">t_type</span><span class="p">)]</span>  <span class="c1"># list comprehension. Vedi sopra per come si legge
</span>

<span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">n_teach</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">larghezza</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">'nuovo'</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="n">f_teach</span><span class="o">+</span><span class="n">m_teach</span><span class="p">)</span> <span class="c1"># posso metterne piu' di uno sotto
</span><span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">m_teach</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">larghezza</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">'maschi'</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="n">f_teach</span><span class="p">)</span> <span class="c1"># posso metterne piu' di uno sotto
</span><span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">f_teach</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">larghezza</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">'femmine'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s">'lower right'</span><span class="p">);</span>   <span class="c1"># non ideale....
#plt.legend(loc=0);                # manco questo... 
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;class 'list'&gt;
</code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_60_1.png" alt="png" /></p>

<h1 id="torte---pie-chart--pltpie">Torte - Pie chart,  plt.pie()</h1>

<p>Vediamo i diagrammi a torta.
Per questi si usa il comando:</p>

<p><code class="language-plaintext highlighter-rouge">wedges, texts, autotexts = plt.pie(poke_num, explode=explode, labels=types, colors=colors,
                                  autopct='%1.0f%%', shadow=True,
                                  startangle=140, textprops =dict(color='w'))</code></p>

<p>Dal punto di vista sintattico la funzione <code class="language-plaintext highlighter-rouge">pie()</code> restituisce 3 oggetti:</p>
<ol>
  <li>le <code class="language-plaintext highlighter-rouge">wedges</code> (gli spicchi o cunei del diagramma a torta).</li>
  <li>i <code class="language-plaintext highlighter-rouge">texts</code></li>
  <li>gli <code class="language-plaintext highlighter-rouge">autotext</code></li>
</ol>

<p>In questo caso abbiamo prima costruito la <code class="language-plaintext highlighter-rouge">figure</code>, poi gli <code class="language-plaintext highlighter-rouge">axes</code> ed infine abbiamo chiamato la funzione <code class="language-plaintext highlighter-rouge">pie</code>.
E’ un po’ diverso dal solito quando si usava un metodo dell’axes.</p>

<ul>
  <li>
    <p>Nota che in un diagramma a torta, intuitivamente, i valori di larghezza (angolo) associati ad ogni fetta vengono convertiti in percentuali dell’angolo giro. Questo perche’ ci si aspetta che tutti i valori di un array riempiano <strong>tutto</strong> il cerchio.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">explode</code> a questa keyword si deve passare un array di float con tanti ingressi quante sono le fette. Il valore di ogni ingresso dice di quanto viene “estratta” la fetta alla posizione corrispondente, vedi l’esempio sotto.</p>
  </li>
  <li>
    <p>nell’esempio sotto ci sono 2 array: <code class="language-plaintext highlighter-rouge">types</code> e <code class="language-plaintext highlighter-rouge">pole_num</code>, questi devono avere il medesimo numero di ingressi.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">labels=types</code> e’ un parametro che indica le etichette associate ad ogni fetta</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">autopct</code> indica come vengono arrotondati i numeri associati alle larghezze, gli si deve passare come valore una stringa che indica un formato.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">shadow=true</code> e’ il parametro che dice se mettiamo l’ombra</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">colori</code> ha usato un trucco notevole, ha fatto scrivere dei valori in formato RGB tramite il generatore di numeri casuali. Tre numeri indicano un colore, e lui indicando il range dei colori tra [0, 0.5] ha fatto si’ che vengono scuri. Ha scelto i colori scuri perche’ la scritta viene in bianco!</p>
  </li>
  <li>
    <p>Occhio, avevo fatto un errore di sintassi ma non semplice da osservare. Nell’array <code class="language-plaintext highlighter-rouge">types</code> che contiene dei nomi tra virgolette, in un caso, quando andavo a capo ho dimenticato di mettere una <strong>virgola</strong> tra un nome e l’altro e lui mi ha preso solo uno dei nomi</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">bbox_to_anchor = (1,0,0.5,1)</code> serve per spostare di 1 e 1/2 a destra della piechart (???)</p>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">random</span>
<span class="n">fig_6</span>  <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">axes_6</span> <span class="o">=</span> <span class="n">fig_6</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.9</span><span class="p">,</span><span class="mf">0.9</span><span class="p">])</span>

<span class="c1">#Vogliamo un diagramma a torte
</span><span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="s">'water'</span><span class="p">,</span> <span class="s">'normal'</span><span class="p">,</span> <span class="s">'flying'</span><span class="p">,</span> <span class="s">'grass'</span><span class="p">,</span> <span class="s">'psychic'</span><span class="p">,</span><span class="s">'bug'</span><span class="p">,</span>
        <span class="s">'fire'</span><span class="p">,</span> <span class="s">'poison'</span><span class="p">,</span> <span class="s">'ground'</span><span class="p">,</span><span class="s">'rock'</span><span class="p">,</span><span class="s">'fighting'</span><span class="p">,</span> <span class="s">'dark'</span><span class="p">,</span> <span class="s">'steel'</span><span class="p">,</span>  
        <span class="s">'electric'</span><span class="p">,</span><span class="s">'dragon'</span><span class="p">,</span><span class="s">'fairy'</span><span class="p">,</span><span class="s">'ghost'</span><span class="p">,</span><span class="s">'ice'</span><span class="p">]</span>

<span class="n">poke_num</span> <span class="o">=</span><span class="p">[</span><span class="mi">133</span><span class="p">,</span> <span class="mi">109</span><span class="p">,</span> <span class="mi">101</span><span class="p">,</span> <span class="mi">98</span><span class="p">,</span> <span class="mi">85</span><span class="p">,</span> <span class="mi">77</span><span class="p">,</span> <span class="mi">68</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">57</span><span class="p">,</span> <span class="mi">54</span><span class="p">,</span> <span class="mi">53</span><span class="p">,</span> <span class="mi">51</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">46</span><span class="p">,</span> <span class="mi">40</span><span class="p">]</span>

<span class="n">colors</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">18</span><span class="p">):</span>         <span class="c1"># per il testo bianco genero i coloi delle fette in modo che siano scuri
</span>    <span class="n">rgb</span> <span class="o">=</span> <span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mf">.5</span><span class="p">)</span> <span class="p">,</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mf">.5</span><span class="p">)</span> <span class="p">,</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mf">.5</span><span class="p">)</span>  <span class="p">)</span>
    <span class="n">colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rgb</span><span class="p">)</span>
    
<span class="n">explode</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">18</span>     <span class="c1"># ho creato una lista di 18 zeri (non mi ricordavo questo modo!)
</span><span class="n">explode</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.2</span>       <span class="c1"># esplodi la prima fetta ma solo di 0.2
</span>
<span class="c1">#print(len(types));
#print(len(poke_num));
</span>
<span class="n">wedges</span><span class="p">,</span> <span class="n">texts</span><span class="p">,</span> <span class="n">autotexts</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">pie</span><span class="p">(</span><span class="n">poke_num</span><span class="p">,</span> <span class="n">explode</span><span class="o">=</span><span class="n">explode</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">types</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span>
                                  <span class="n">autopct</span><span class="o">=</span><span class="s">'</span><span class="si">%1.0</span><span class="s">f</span><span class="si">%%</span><span class="s">'</span><span class="p">,</span> <span class="n">shadow</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                  <span class="n">startangle</span><span class="o">=</span><span class="mi">140</span><span class="p">,</span> <span class="n">textprops</span> <span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s">'w'</span><span class="p">))</span>

<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">wedges</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s">'right'</span><span class="p">,</span> <span class="n">bbox_to_anchor</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span> <span class="c1">#  sposto dalla piechart
</span></code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_62_0.png" alt="png" /></p>

<h1 id="serie-temporali">Serie Temporali</h1>

<p>Qui vediamo come fare un grafico con una serie temporale in cui i vari punti sono etichettati con un <strong>timestamp</strong>.
Puo’ essere necessario togliere dei giorni particolari e risulta piu’ comodo sapere la data piuttosto che trovare il punto corrispondente della time series.</p>

<p>Il database usato viene da Yahoo riguardo i dati di google, GOOG.csv. (non e’ esattamente come mostrato nel video ma si trova in fretta). Per trovarlo cerca con google “yahoo google stock”, seleziona le date e fai download (nota che la frequenza e’ giornaliera).</p>

<p>All’inizio si carica il file con <code class="language-plaintext highlighter-rouge">read_csv</code> di Pandas, poi si trasforma la tabella in un array di numpy (sono tutti valori numerici). Lui usa un metodo dei DataFrame di Pandas che io non uso mai: <code class="language-plaintext highlighter-rouge">tp_numpy()</code>. Io invece faccio semplicemente <code class="language-plaintext highlighter-rouge">np.array()</code>.</p>

<p>Ho provato a fare un giro piu’ semplice, cercando di plottare i dati direttamwente DAL DataFrame, di cui seleziono le colonne volute (ma avendo prima selezionato le righe, vedi sotto). Sfortunatamente sull’asse delle x vengono dei valori sballati come tics, il grafico e’ pero’ corretto. Questo e’ probabilmente il motivo per cui lui preferisce trasformare tutto in array di Numpy.</p>

<p><strong>Scrubbing data</strong>: per esempio vogliamo togliere alcune vacanze, ha controllato due date che sono vacanze e vuole escluderlo.
Usa <code class="language-plaintext highlighter-rouge">datetime</code>. La funzione <code class="language-plaintext highlighter-rouge">datetime.datetime(2020,5,25)</code> crea una data in un oggetto specifico, che puo’ poi essere trasformato a seconda delle esigenze, p.es g/m/a  o m/g/a ecc.</p>

<p>Poi <strong>costruisce</strong> un array di date che vanno da una data iniziale ad una finale, tramite un metodo di pandas: <code class="language-plaintext highlighter-rouge">pd.bdate_range</code>, si puo’ passare il parametro frequency <code class="language-plaintext highlighter-rouge">freq ='C'</code> in questo caso, ma no so cosa sia il valore ‘C’!</p>

<p><code class="language-plaintext highlighter-rouge">holidays</code> e’ il nome di un altro parametro che appunto corrisponde alle vacanze e possiamo passare un array/tupla contentente dei dati in formato <code class="language-plaintext highlighter-rouge">datetime</code> che vengono riconosciuti. <strong>ATTENTO</strong> la mia versione non riconosce questo parametro. Ho riscritto tutto e ora funge.</p>

<p><strong>Problema</strong>: non so quando ha preso lui le date da Yahoo, io ho piu’ giorni.</p>

<p><strong>Problema2</strong> se uso tutti questi giorni, i tics che vengono segnati sono troppi e sotto l’asse viene un guazzabuglio di linee. Devo modificare per ottenere le date corrette.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">datetime</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">goog_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">'GOOG.csv'</span><span class="p">)</span>    <span class="c1"># IMPORTO il file GOOG.csv che ho salvato nella dir corrente
</span><span class="n">goog_data_np</span> <span class="o">=</span> <span class="n">goog_data</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>    <span class="c1"># trasformo in np.array
#goog_data_np =np.array(goog_data)     # modo alternativo di trasformare
</span><span class="n">goog_cp</span> <span class="o">=</span> <span class="n">goog_data_np</span><span class="p">[:,</span><span class="mi">4</span><span class="p">]</span>

<span class="n">holidays</span> <span class="o">=</span> <span class="p">[</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2020</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">25</span><span class="p">)</span>  <span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2020</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">19</span><span class="p">)</span> <span class="p">]</span> <span class="c1"># creo una lista con due date che saranno vacanze
</span>
<span class="n">date_arr</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">bdate_range</span><span class="p">(</span><span class="n">start</span> <span class="o">=</span><span class="s">'5/20/2020'</span> <span class="p">,</span>
                            <span class="n">end</span> <span class="o">=</span><span class="s">'8/19/2020'</span> <span class="p">,</span> 
                           <span class="n">freq</span> <span class="o">=</span><span class="s">'C'</span><span class="p">,</span> 
                       <span class="n">holidays</span> <span class="o">=</span> <span class="n">holidays</span><span class="p">)</span> 

<span class="n">date_arr_np</span> <span class="o">=</span> <span class="n">date_arr</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
<span class="n">goog_data</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</code></pre></div></div>

<div>
<style scoped="">
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Date</th>
      <th>Open</th>
      <th>High</th>
      <th>Low</th>
      <th>Close</th>
      <th>Adj Close</th>
      <th>Volume</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2019-08-21</td>
      <td>1193.150024</td>
      <td>1199.000000</td>
      <td>1187.430054</td>
      <td>1191.250000</td>
      <td>1191.250000</td>
      <td>740700</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2019-08-22</td>
      <td>1194.069946</td>
      <td>1198.011963</td>
      <td>1178.579956</td>
      <td>1189.530029</td>
      <td>1189.530029</td>
      <td>947500</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2019-08-23</td>
      <td>1181.989990</td>
      <td>1194.079956</td>
      <td>1147.750000</td>
      <td>1151.290039</td>
      <td>1151.290039</td>
      <td>1687000</td>
    </tr>
  </tbody>
</table>
</div>

<h2 id="selezionare-righe-secondo-delle-date">Selezionare righe secondo delle date</h2>

<p>Seguo questo esempio per selezionare le date:
https://stackoverflow.com/questions/29370057/select-dataframe-rows-between-two-dates</p>

<p>Creo una mask per selezionare le date che voglio e che devono seguire quelle indicate nel <code class="language-plaintext highlighter-rouge">bdate_range</code>.
In pratica creo una <strong>maschera</strong>, ovvero un array di <strong>bool</strong> che poi posso passare a loc!
In questo modo solo gli ingressi in cui la maschera e’ vera vengono selezionati.</p>

<ul>
  <li><strong>Problema I</strong>: devo paragonare delle date… in formati magari diversi</li>
  <li><strong>Soluzione I</strong> uso <code class="language-plaintext highlighter-rouge">pd.to_datetime()</code> che e’ una goduriosa funzione di Pandas che converte una stringa in un oggetto di tipo <code class="language-plaintext highlighter-rouge">datetime</code>. Questo oggetto e’ una data ed e’ possibile paragonare due datetime per vedere chi viene prima o dopo! Questa funzione e’ particolarmente VANTAGGIOSA in quanto riconosce tanti tipi diversi di formato in cui possiamo scrivere una data e li converte i un unico oggetto!</li>
  <li><strong>Alternativa</strong> usa <code class="language-plaintext highlighter-rouge">parse_dates</code> (vedi il Finance Module)</li>
</ul>

<p>Una volta ottenuto un modo per paragonare le date posso creare una lista con valori <code class="language-plaintext highlighter-rouge">booleani</code> in cui seleziono le date (basta un loop), chiamo questo oggetto <strong>maschera</strong></p>

<ul>
  <li><strong>Problema II</strong> la maschera cosi’ creata non e’ un oggetto iterabile che si possa mettere nel metodo <code class="language-plaintext highlighter-rouge">loc</code> di pandas. Devo tasformarlo in un oggetto non iterabile</li>
  <li><strong>Soluzione II</strong> basta costruire una funzione che prende come input qualcosa e quando lo sputa in output gli metto un <code class="language-plaintext highlighter-rouge">tuple</code> davanti!</li>
  <li><strong>DUBBIO</strong> ehi ma nel codice non ho usato la tupla, anzi se dove faccio finanza metto la tupla mi da errore, sembra che una Series di pandas vada bene</li>
</ul>

<p>Attenzione pero’ la maschera cosi’ creata e’ un oggetto <strong>mutabile</strong> e questo non puo’ essere usato come ingresso della funzione loc (di PANDAS) perche’ questa necessita oggetti immutabili da cui puo’ estrarre una hashtable.</p>

<p>link utili:</p>

<p>loc: https://stackoverflow.com/questions/29370057/select-dataframe-rows-between-two-dates</p>

<p>to_datetime: https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.to_datetime.html</p>

<p>convertire lista in tupla: https://www.geeksforgeeks.org/python-convert-a-list-into-a-tuple/</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># PROBLEMA  I
# qui sotto prendo la colonna Date del dataFrame
# poi converto i valori ivi contenuti in un oggetto di tipo datetime con to_datetime
# a questo punto li paragono ai valori entro cui voglio che siano le date, sempre
# sfruttando la funzione di pandas pd.to_datetime
</span>
<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span>   <span class="p">(</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">goog_data</span><span class="p">[</span><span class="s">'Date'</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="s">'5/20/2020'</span><span class="p">))</span> 
         <span class="o">&amp;</span> <span class="p">(</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">goog_data</span><span class="p">[</span><span class="s">'Date'</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="s">'8/19/2020'</span><span class="p">))</span> <span class="p">)</span>



<span class="c1"># PROBLEMA II
# l'oggetto mask non  e' di tipo immutabile e quindi non puo' essere usato come iteratore
# devo trasformarlo in unoggetto immutabile
</span>
<span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="nb">list</span><span class="p">):</span> 
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span> 

<span class="n">mask_t</span><span class="o">=</span> <span class="n">convert</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

<span class="c1">#print(type(mask_t) , 'tipo maschera')    # controllo
#print(len(goog_data.loc[mask]))          # controllo che i due oggetti abbiano lo stesso numero di righe  
</span>
<span class="n">new</span> <span class="o">=</span> <span class="n">goog_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>   <span class="c1"># loc NON lavora inplace &lt;===================
</span><span class="n">new_np</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
<span class="n">goog_cp</span> <span class="o">=</span> <span class="n">new_np</span><span class="p">[:,</span><span class="mi">4</span><span class="p">]</span>       <span class="c1">#  
</span>

<span class="c1"># PROBLEMA III 
# Costruisco un array con le date corrispondenti in modo che io possa poi disegnarle
</span>
<span class="n">fig_7</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>  <span class="c1"># creiamo la figura/canvas come al solito
</span><span class="n">axes_7</span> <span class="o">=</span> <span class="n">fig_7</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">])</span>  <span class="c1"># il grafico non copre tutta la figura, lasciamo un po' di padding
</span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">date_arr_np</span><span class="p">,</span> <span class="n">goog_cp</span><span class="p">);</span>

<span class="c1">#plt.plot(new.Date, new.Close) # questo fa vedere sbagliato i tics sotto
</span>
</code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_67_0.png" alt="png" /></p>

<h1 id="tabelle">Tabelle</h1>

<p>Questo non e’ cosi’ interessante, la cosa che trovo piu’ utile e’ come girare le date sull’asse delle x.
Copio il pezzo di notebook scritto da Banas qui sotto:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Format column data to 2 decimals
</span><span class="n">goog_data</span><span class="p">[</span><span class="s">'Open'</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="nb">round</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">goog_data</span><span class="p">[</span><span class="s">'Open'</span><span class="p">]],</span> 
                              <span class="n">index</span> <span class="o">=</span> <span class="n">goog_data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
<span class="n">goog_data</span><span class="p">[</span><span class="s">'High'</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="nb">round</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">goog_data</span><span class="p">[</span><span class="s">'High'</span><span class="p">]],</span> 
                              <span class="n">index</span> <span class="o">=</span> <span class="n">goog_data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
<span class="n">goog_data</span><span class="p">[</span><span class="s">'Low'</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="nb">round</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">goog_data</span><span class="p">[</span><span class="s">'Low'</span><span class="p">]],</span> 
                              <span class="n">index</span> <span class="o">=</span> <span class="n">goog_data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
<span class="n">goog_data</span><span class="p">[</span><span class="s">'Close'</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="nb">round</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">goog_data</span><span class="p">[</span><span class="s">'Close'</span><span class="p">]],</span> 
                              <span class="n">index</span> <span class="o">=</span> <span class="n">goog_data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
<span class="n">goog_data</span><span class="p">[</span><span class="s">'Adj Close'</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="nb">round</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">goog_data</span><span class="p">[</span><span class="s">'Adj Close'</span><span class="p">]],</span> 
                              <span class="n">index</span> <span class="o">=</span> <span class="n">goog_data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

<span class="c1"># Get most recent last 5 days of stock data
</span><span class="n">stk_data</span> <span class="o">=</span> <span class="n">goog_data</span><span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">:]</span>
<span class="n">stk_data</span>

<span class="c1"># Define headers
</span><span class="n">col_head</span> <span class="o">=</span> <span class="p">(</span><span class="s">'Date'</span><span class="p">,</span><span class="s">'Open'</span><span class="p">,</span><span class="s">'High'</span><span class="p">,</span><span class="s">'Low'</span><span class="p">,</span><span class="s">'Close'</span><span class="p">,</span><span class="s">'Adj Close'</span><span class="p">,</span><span class="s">'Volume'</span><span class="p">)</span>

<span class="n">stk_data_np</span> <span class="o">=</span> <span class="n">stk_data</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
<span class="n">stk_data_np</span>

<span class="c1"># Add padding around cells in table
</span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">tight_layout</span><span class="o">=</span><span class="p">{</span><span class="s">'pad'</span><span class="p">:</span><span class="mf">.5</span><span class="p">},</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>

<span class="c1"># Get rid of axes and plot box
</span><span class="n">axes_8</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
<span class="n">axes_8</span><span class="o">.</span><span class="n">get_xaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="n">axes_8</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">box</span><span class="p">(</span><span class="n">on</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>

<span class="c1"># np.full returns an array filled with 0.1
# cm is a colormap object we are using to use a default blue color
# matplotlib.org/3.1.0/tutorials/colors/colormaps.html
</span><span class="n">ccolors</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">Blues</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">col_head</span><span class="p">),</span> <span class="mf">0.2</span><span class="p">))</span>

<span class="c1"># Receives data, loc, list of column headers, column header color as array of colors
# You can also add rowLabel, rowColours, rowLoc: Text alignment
</span><span class="n">the_table</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">table</span><span class="p">(</span><span class="n">cellText</span><span class="o">=</span><span class="n">stk_data_np</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s">'center'</span><span class="p">,</span> <span class="n">colLabels</span><span class="o">=</span><span class="n">col_head</span><span class="p">,</span>
                     <span class="n">colColours</span><span class="o">=</span><span class="n">ccolors</span><span class="p">)</span>
<span class="c1"># Set table font size
</span><span class="n">the_table</span><span class="o">.</span><span class="n">set_fontsize</span><span class="p">(</span><span class="mi">14</span><span class="p">)</span>
<span class="n">the_table</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">)</span>

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\ProgramData\Anaconda3\lib\site-packages\IPython\core\pylabtools.py:132: UserWarning: Tight layout not applied. The left and right margins cannot be made large enough to accommodate all axes decorations. 
  fig.canvas.print_figure(bytes_io, **kw)
</code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_69_1.png" alt="png" /></p>

<h1 id="scatterplot">ScatterPlot</h1>
<p>Qui ci sono dei dati relativi al Coronavirus.
E’ importante che ci sia uniformita’ di grandezza per quanto riguarda gli array che vanno plottati:</p>
<ul>
  <li>ci sono 26 nazioni</li>
  <li>ci sono 26 tassi di mortalita’</li>
  <li>ci sono 26 valori di casi confermati giornalieri</li>
  <li>ci sono 26 dimensioni dei punti</li>
</ul>

<p>Nota che i questo caso non costruisco la <strong>figura</strong> e poi gli <strong>assi</strong>. Questo perche’ viene fatto automaticamente dal comando <code class="language-plaintext highlighter-rouge">plt.scatter</code>. Ci sono 2 vie per ottenere lo stesso grafico:</p>
<ol>
  <li>costruisco la fig, e gli assi e uso scatter come metodo sull’asse creato</li>
  <li>uso plt.scatter e lui automaticamente crea gli assi!</li>
</ol>

<p>Argomenti dello <strong>scatterplot</strong>:</p>
<ul>
  <li>prima si mettono i valori dell’asse delle x (e’ un <code class="language-plaintext highlighter-rouge">np.array</code>)</li>
  <li>poi l’array per i valori dell’asse delle y (anche questo un <code class="language-plaintext highlighter-rouge">np.array</code> lungo quanto quello sopra)</li>
  <li>s  per size (dei punti): NON e’ come gnuplot che accettava le abbreviazioni, qui il parametro si chiama SOLO s!</li>
  <li>c  per color (dei punti)</li>
  <li>alpha e’ in pratica il livello di trasparenza, in questo caso e’ fondamentale in quanto alcuni punti andranno a sovrapporsi</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Numpy array con i nomi delle nazioni
</span><span class="n">cnt_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s">'Australia'</span><span class="p">,</span><span class="s">'Brazil'</span><span class="p">,</span><span class="s">'Canada'</span><span class="p">,</span><span class="s">'Chile'</span><span class="p">,</span><span class="s">'France'</span><span class="p">,</span><span class="s">'Germany'</span><span class="p">,</span><span class="s">'Greece'</span><span class="p">,</span>
                   <span class="s">'Iceland'</span><span class="p">,</span><span class="s">'India'</span><span class="p">,</span><span class="s">'Iran'</span><span class="p">,</span><span class="s">'Italy'</span><span class="p">,</span><span class="s">'Mexico'</span><span class="p">,</span><span class="s">'New Zealand'</span><span class="p">,</span><span class="s">'Nigeria'</span><span class="p">,</span>
                   <span class="s">'Norway'</span><span class="p">,</span><span class="s">'Pakistan'</span><span class="p">,</span><span class="s">'Peru'</span><span class="p">,</span><span class="s">'Russia'</span><span class="p">,</span><span class="s">'Saudi Arabia'</span><span class="p">,</span><span class="s">'Singapore'</span><span class="p">,</span>
                   <span class="s">'South Africa'</span><span class="p">,</span><span class="s">'Spain'</span><span class="p">,</span><span class="s">'Sweden'</span><span class="p">,</span><span class="s">'Turkey'</span><span class="p">,</span><span class="s">'UK'</span><span class="p">,</span><span class="s">'US'</span><span class="p">])</span>
<span class="c1"># Tasso mortalita per 100k casi Coronavirus
</span><span class="n">dr_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.8</span><span class="p">,</span><span class="mi">53</span><span class="p">,</span><span class="mf">24.5</span><span class="p">,</span><span class="mf">56.5</span><span class="p">,</span><span class="mf">45.4</span><span class="p">,</span><span class="mf">11.2</span><span class="p">,</span><span class="mf">2.2</span><span class="p">,</span>
                   <span class="mf">2.8</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mf">24.6</span><span class="p">,</span><span class="mf">58.6</span><span class="p">,</span><span class="mf">46.3</span><span class="p">,</span><span class="mf">.5</span><span class="p">,</span><span class="mf">.5</span><span class="p">,</span>
                   <span class="mf">4.9</span><span class="p">,</span><span class="mf">2.9</span><span class="p">,</span><span class="mf">83.3</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mf">10.4</span><span class="p">,</span><span class="mf">.5</span><span class="p">,</span>
                   <span class="mf">21.5</span><span class="p">,</span><span class="mf">61.6</span><span class="p">,</span><span class="mf">56.9</span><span class="p">,</span><span class="mf">7.3</span><span class="p">,</span><span class="mf">62.4</span><span class="p">,</span><span class="mf">52.9</span><span class="p">])</span>
<span class="c1"># Numero giornaliero di casi confermati (Tests)
</span><span class="n">test_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">110</span><span class="p">,</span><span class="mi">7197</span><span class="p">,</span><span class="mi">600</span><span class="p">,</span><span class="mi">1862</span><span class="p">,</span><span class="mi">1636</span><span class="p">,</span><span class="mi">1103</span><span class="p">,</span><span class="mi">35</span><span class="p">,</span>
                   <span class="mi">10</span><span class="p">,</span><span class="mi">295</span><span class="p">,</span><span class="mi">1658</span><span class="p">,</span><span class="mi">1226</span><span class="p">,</span><span class="mi">2490</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">243</span><span class="p">,</span>
                   <span class="mi">48</span><span class="p">,</span><span class="mi">1395</span><span class="p">,</span><span class="mi">1101</span><span class="p">,</span><span class="mi">4447</span><span class="p">,</span><span class="mi">1443</span><span class="p">,</span><span class="mi">280</span><span class="p">,</span>
                   <span class="mi">2830</span><span class="p">,</span><span class="mi">1602</span><span class="p">,</span><span class="mi">447</span><span class="p">,</span><span class="mi">1205</span><span class="p">,</span><span class="mi">1546</span><span class="p">,</span><span class="mi">24988</span><span class="p">])</span>
<span class="c1"># Dimensione del punto dei casi confermati
</span><span class="n">cc_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">24236</span><span class="p">,</span><span class="mi">3456652</span><span class="p">,</span><span class="mi">125408</span><span class="p">,</span><span class="mi">390037</span><span class="p">,</span><span class="mi">256534</span><span class="p">,</span><span class="mi">229706</span><span class="p">,</span><span class="mi">7684</span><span class="p">,</span>
                   <span class="mi">2035</span><span class="p">,</span><span class="mi">2836925</span><span class="p">,</span><span class="mi">350279</span><span class="p">,</span><span class="mi">255278</span><span class="p">,</span><span class="mi">537031</span><span class="p">,</span><span class="mi">1654</span><span class="p">,</span><span class="mi">50488</span><span class="p">,</span>
                   <span class="mi">10162</span><span class="p">,</span><span class="mi">290445</span><span class="p">,</span><span class="mi">549321</span><span class="p">,</span><span class="mi">935066</span><span class="p">,</span><span class="mi">302686</span><span class="p">,</span><span class="mi">56031</span><span class="p">,</span>
                   <span class="mi">596060</span><span class="p">,</span><span class="mi">370867</span><span class="p">,</span><span class="mi">85411</span><span class="p">,</span><span class="mi">253108</span><span class="p">,</span><span class="mi">323008</span><span class="p">,</span><span class="mi">5529824</span><span class="p">])</span>

<span class="n">cc_arr_sm</span> <span class="o">=</span> <span class="n">cc_arr</span><span class="o">/</span><span class="mi">1000</span> <span class="c1"># rimpicciolisce a dimensione dei punti (?)
</span><span class="n">color_arr</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">26</span><span class="p">)</span>

<span class="c1"># Se faccio questi sotto vengono aggiunti ad una figura aggiuntiva, non al mio scatterplot
# questo perche' ho provato ad usare la strada per cui prima faccio la figura, aggiungo gli assi
# e il disegno viene con un metodo!
#plt.title('Mortalita per 100k vs. Casi confermati')
#plt.xlabel('Mortalita per 100k')
#plt.ylabel('Casi confermati')
#plt.scatter(dr_arr, test_arr, s=cc_arr_sm, c=color_arr,alpha=0.5 )
#plt.figure(figsize=(8,5))
</span>

<span class="n">fig_13</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">axes_13</span> <span class="o">=</span> <span class="n">fig_13</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.9</span><span class="p">,</span><span class="mf">0.9</span><span class="p">])</span>
<span class="n">axes_13</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">'Mortalita per 100k'</span><span class="p">)</span>
<span class="n">axes_13</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">'Casi confermati'</span><span class="p">)</span>
<span class="n">axes_13</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">'Mortalita per 100k vs. Casi confermati'</span><span class="p">)</span>

<span class="n">axes_13</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">dr_arr</span><span class="p">,</span>       <span class="c1"># valori sull'asse delle x
</span>                <span class="n">test_arr</span><span class="p">,</span>     <span class="c1"># valori sull'asse delle y
</span>                <span class="n">s</span><span class="o">=</span><span class="n">cc_arr_sm</span><span class="p">,</span>  <span class="c1"># valori che indicano la dimensione dei punti
</span>                <span class="n">c</span><span class="o">=</span><span class="n">color_arr</span><span class="p">,</span>  <span class="c1"># colori di ogni punto
</span>                <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span> <span class="p">);</span>  <span class="c1"># trasparenza 1 = no trasparenza, 0 = completamente trasparente
</span></code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_71_0.png" alt="png" /></p>

<h1 id="3d">3D</h1>

<ul>
  <li><code class="language-plaintext highlighter-rouge">from mpl_toolkits import mplot3d</code>  abbiamo bisogno di importare questo modulo</li>
  <li><code class="language-plaintext highlighter-rouge">projection='3d'</code>  quando si costruisce la figura si aggiunge questo parametro</li>
  <li><code class="language-plaintext highlighter-rouge">fig_9 = plt.figure(figsize=(8,5), dpi=100)</code> dpi=100 stranamente sembra avere un effetto sulla dimensione della figura, mentre sembra non prendere il parametro figsize! Probabilmente questo e’ dovuto al fatto che con <code class="language-plaintext highlighter-rouge">%matplotlib inline</code> mi mette le figure come dei png, cambiando il numero di punti questo cambia la dimensione dell’immagine a schermo. Per esempio dpi=100 e’ circa un terzo della figura con dpi=300</li>
  <li><code class="language-plaintext highlighter-rouge">scatter3D</code> la funzione per uno scatterplot 3D</li>
  <li><code class="language-plaintext highlighter-rouge">c= z_3</code> se uso questo parametro per i colori, allora quelli piu’ in alto (asse z) avranno una sfumatura differente da quelli in basso</li>
</ul>

<h2 id="scatter3d">Scatter3D</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">mpl_toolkits</span> <span class="kn">import</span> <span class="n">mplot3d</span>

<span class="n">fig_9</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">axes_9</span> <span class="o">=</span> <span class="n">fig_9</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.9</span><span class="p">,</span><span class="mf">0.9</span><span class="p">],</span> <span class="n">projection</span><span class="o">=</span><span class="s">'3d'</span><span class="p">)</span>   <span class="c1"># mette degli assi 3D
</span>
<span class="n">z_3</span> <span class="o">=</span> <span class="mi">40</span> <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>            <span class="c1"># random:  sample dalla [0,1) uniforme
</span><span class="n">x_3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">z_3</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>   <span class="c1"># randn
</span><span class="n">y_3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">z_3</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>   <span class="c1"># randn: sample dalla N(0,1)
</span>
<span class="c1">#axes_9.scatter3D(x_3,y_3,z_3, cmap='Blues');
</span><span class="n">axes_9</span><span class="o">.</span><span class="n">scatter3D</span><span class="p">(</span><span class="n">x_3</span><span class="p">,</span><span class="n">y_3</span><span class="p">,</span><span class="n">z_3</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">z_3</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s">'Blues'</span><span class="p">);</span>


</code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_73_0.png" alt="png" /></p>

<h2 id="contour3d">Contour3D</h2>

<p>In questo caso ho bisogno di una funzione <code class="language-plaintext highlighter-rouge">z =z(x,y)</code> questo perche’ lui deve poter sapere la altezza in ogni punto.</p>

<ul>
  <li>
    <p>per costruire una griglia rettangolare devo usare <code class="language-plaintext highlighter-rouge">np.meshgrid</code>:  <code class="language-plaintext highlighter-rouge">x_4, y_4  = np.meshgrid(x_4, y_4)</code> occhio che se non metto questo comando mi dice che c’e’ un errore!? Il motivo e’ semplice. meshgrid prende in ingresso due array 1 dimensionali e restituisce due array 2 dimensionali. In pratica ha fatto un prodotto cartesizano per ognuno dei punti del primo array creando una coppia con quelli del secondo array (e viceversa per il secondo array). Questo perche’ contour3D si aspetta delle matrici per le x e le y e anche le z, in quanto per ogni x e y c’e’uno z. Per capire meglio fai fare print(x_4) prima e dopo meshgrid e vedi la differenza.</p>
  </li>
  <li>Angolo di vista, per cambiare: <code class="language-plaintext highlighter-rouge">axes_9.view_init(45, 55)</code>. questo sposta l’angolo di vista di 45 gradi e lo ruota di 55</li>
  <li>il 4to parametro indica il numero di linee. In pratica quante fette parallele al piano xy che vengono visualizzate, se metto 80 sono tante, se metto 20 sono poche</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fig_9</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">axes_9</span> <span class="o">=</span> <span class="n">fig_9</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.9</span><span class="p">,</span><span class="mf">0.9</span><span class="p">],</span> <span class="n">projection</span><span class="o">=</span><span class="s">'3d'</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">get_z</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

<span class="n">x_4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">30</span><span class="p">)</span>
<span class="n">y_4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">30</span><span class="p">)</span>

<span class="c1">#print(x_4)   
</span><span class="n">x_4</span><span class="p">,</span> <span class="n">y_4</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x_4</span><span class="p">,</span> <span class="n">y_4</span><span class="p">)</span>
<span class="c1">#print(x_4)
</span>

<span class="n">z_4</span> <span class="o">=</span> <span class="n">get_z</span><span class="p">(</span><span class="n">x_4</span><span class="p">,</span> <span class="n">y_4</span><span class="p">)</span>

<span class="n">axes_9</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">'x'</span><span class="p">)</span>
<span class="n">axes_9</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">'y'</span><span class="p">)</span>
<span class="n">axes_9</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s">'z'</span><span class="p">)</span>

<span class="n">axes_9</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="mi">35</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>  <span class="c1"># angolo di visione, angolo di rotazione
</span><span class="n">axes_9</span><span class="o">.</span><span class="n">contour3D</span><span class="p">(</span><span class="n">x_4</span><span class="p">,</span><span class="n">y_4</span><span class="p">,</span><span class="n">z_4</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s">'Blues'</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_75_0.png" alt="png" /></p>

<h2 id="wireframe-e-surface">WireFrame e surface</h2>
<p>In questo caso vengono connessi tutti i punti da un segmento.
-<code class="language-plaintext highlighter-rouge">plot_wireframe(x_4,y_4,z_4, cmap='Blues')</code> in questo caso non devo passare il numero di tagli paralleli all’asse xy, quindi non ha il 4to parametro.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">edgecolor ='none'</code> non colora i segmenti di collegamento (il wireframe)</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fig_9</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">axes_9</span> <span class="o">=</span> <span class="n">fig_9</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.9</span><span class="p">,</span><span class="mf">0.9</span><span class="p">],</span> <span class="n">projection</span><span class="o">=</span><span class="s">'3d'</span><span class="p">)</span>
<span class="n">axes_9</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="mi">35</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>  <span class="c1"># angolo di visione, angolo di rotazione
#axes_9.plot_wireframe(x_4,y_4,z_4, cmap='Blues');
</span>
<span class="n">axes_9</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">x_4</span><span class="p">,</span><span class="n">y_4</span><span class="p">,</span><span class="n">z_4</span><span class="p">,</span> <span class="n">rstride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cstride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>  <span class="n">cmap</span><span class="o">=</span><span class="s">'Blues'</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s">'r'</span><span class="p">);</span>

</code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_77_0.png" alt="png" /></p>

<h1 id="finance-module">Finance Module</h1>

<p>per installare ho fatto:</p>
<ul>
  <li>anaconda prompt</li>
  <li>pip install mpl_finance</li>
  <li>pip install –upgrade mplfinance   # upgrade</li>
</ul>

<p>questo modulo fa vedere le candele giapponesi ecc.</p>

<ul>
  <li>posso cambiare il nome dell’index: <code class="language-plaintext highlighter-rouge">goog_df.index.name='Date'</code> a questo punto l’index non si chiama piu’ index ma Date! 
mi pare di capire che questo sia necessario perche’ la libreria prenda correttamente il dataframe.</li>
</ul>

<h2 id="candele-giapponesi">Candele giapponesi</h2>
<ul>
  <li>Attento se prendi tante date, non riesci a vedere le candele! devono essere poche per essere visibili.</li>
</ul>

<h2 id="trendlines">trendlines</h2>
<p>possiamo mettere automaticamente delle medie mobili con il parametro:
-<code class="language-plaintext highlighter-rouge">type='ohlc', mav=4</code>  # che significa che mette Open High Low Close e  la media mobile basata sui precedenti 4 punti,nota che possiamo tenere come type ‘candle’ (ma si vede meno bene)</p>

<ul>
  <li>altri tipi di medie mobili. <code class="language-plaintext highlighter-rouge">mav=(3,5,7)</code> e’ bene usare dispari, quindi fa vedere 3 medie mobili basate sui 3, 5 e 7 gg precedenti</li>
  <li>il parametro <code class="language-plaintext highlighter-rouge">volume=True</code> va vedere i volumi giornalieri</li>
  <li>mostrare non-tading days: <code class="language-plaintext highlighter-rouge">show_nontrading=True</code></li>
</ul>

<h2 id="parse_dates">parse_dates</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">parse_dates=true</code> vuol dire che non prende le date come delle semplici stringhe ma le legge come date, infatti ora sono in formato Timestamp</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">mplfinance</span> <span class="k">as</span> <span class="n">mpf</span>

<span class="n">goog_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">'GOOG.csv'</span><span class="p">,</span> <span class="n">index_col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">parse_dates</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c1">#type(goog_df.index[0])
</span><span class="n">goog_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span><span class="o">=</span><span class="s">'Date'</span>

<span class="c1">#goog_df = pd.read_csv('GOOG.csv')
</span><span class="n">goog_df</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</code></pre></div></div>

<div>
<style scoped="">
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Open</th>
      <th>High</th>
      <th>Low</th>
      <th>Close</th>
      <th>Adj Close</th>
      <th>Volume</th>
    </tr>
    <tr>
      <th>Date</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2019-08-21</th>
      <td>1193.150024</td>
      <td>1199.000000</td>
      <td>1187.430054</td>
      <td>1191.250000</td>
      <td>1191.250000</td>
      <td>740700</td>
    </tr>
    <tr>
      <th>2019-08-22</th>
      <td>1194.069946</td>
      <td>1198.011963</td>
      <td>1178.579956</td>
      <td>1189.530029</td>
      <td>1189.530029</td>
      <td>947500</td>
    </tr>
    <tr>
      <th>2019-08-23</th>
      <td>1181.989990</td>
      <td>1194.079956</td>
      <td>1147.750000</td>
      <td>1151.290039</td>
      <td>1151.290039</td>
      <td>1687000</td>
    </tr>
  </tbody>
</table>
</div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mask</span> <span class="o">=</span> <span class="p">(</span>   <span class="p">(</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">goog_df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="s">'5/20/2020'</span><span class="p">))</span> 
         <span class="o">&amp;</span> <span class="p">(</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">goog_df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="s">'8/19/2020'</span><span class="p">))</span> <span class="p">)</span>

<span class="n">new</span> <span class="o">=</span> <span class="n">goog_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>   <span class="c1"># 
#mpf.plot(new, type='line')     # normali linee
#mpf.plot(new, type='candle')   # candele giapponesi
#mpf.plot(new, type='ohlc', mav=4)   # open high low close + moving average
</span><span class="n">mpf</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s">'ohlc'</span><span class="p">,</span> <span class="n">mav</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">),</span> <span class="n">volume</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">show_nontrading</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>   <span class="c1"># open high low close + moving average
</span></code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_80_0.png" alt="png" /></p>

<h1 id="heatmap">Heatmap</h1>
<p>ho un array 2 dimensionale e voglio mostrarlo con dei colori invece che dei numeri.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">symptoms</code> sono i 4 tipi di malattia a cui si riferiscono i dati (dyspnea = short of breath)</li>
  <li><code class="language-plaintext highlighter-rouge">dates sono</code> i giorni in cui sono state fatte le osservazioni (sono 9 giorni)</li>
  <li><code class="language-plaintext highlighter-rouge">symp_per</code> sono il numero di pazienti per giorno per malattia e’ un array 4x9</li>
</ul>

<p>Nota: pensavo che la heatmap di default mettesse delle righe bianche <strong>in mezzo</strong> alle caselle risultando molto poco chiara! in realta’ e’ una delle opzioni lasciate dal finance module!!!! (se faccio girare prima la casella sotto le righe bianche in mezzo non ci sono!)</p>

<ul>
  <li>Per la heatmap si deve usare <code class="language-plaintext highlighter-rouge">subplots()</code> (non figure)</li>
  <li>Cosa fa il comando? prende la matrice che ha 0,3 righe, e 0,8 colonne. Per ognuna delle righe e delle colonne scrive un colore associato al numero dell’ingresso dell’array da disegnare.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">symptoms</span> <span class="o">=</span> <span class="p">[</span><span class="s">"Coronavirus"</span><span class="p">,</span><span class="s">"Influenza"</span><span class="p">,</span><span class="s">"Pneumonia"</span><span class="p">,</span><span class="s">"Dyspnea"</span><span class="p">]</span>
<span class="n">dates</span> <span class="o">=</span> <span class="p">[</span><span class="s">"Jun28"</span><span class="p">,</span><span class="s">"Jul05"</span><span class="p">,</span><span class="s">"Jul12"</span><span class="p">,</span><span class="s">"Jul19"</span><span class="p">,</span><span class="s">"Jul26"</span><span class="p">,</span><span class="s">"Aug02"</span><span class="p">,</span><span class="s">"Aug09"</span><span class="p">,</span><span class="s">"Aug16"</span><span class="p">,</span><span class="s">"Aug21"</span><span class="p">]</span>
<span class="n">symp_per</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">5.2</span><span class="p">,</span> <span class="mf">5.5</span><span class="p">,</span> <span class="mf">5.7</span><span class="p">,</span> <span class="mf">5.6</span><span class="p">,</span> <span class="mf">5.3</span><span class="p">,</span> <span class="mf">5.1</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">4.9</span><span class="p">,</span> <span class="mf">5.3</span><span class="p">],</span>
                    <span class="p">[</span><span class="mf">3.5</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">4.3</span><span class="p">,</span> <span class="mf">3.9</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">,</span> <span class="mf">3.2</span><span class="p">,</span> <span class="mf">2.7</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span>
                    <span class="p">[</span><span class="mf">1.8</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">,</span> <span class="mf">1.7</span><span class="p">,</span> <span class="mf">1.4</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">],</span>
                    <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">]])</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fig_10</span> <span class="p">,</span> <span class="n">axes_10</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">im</span><span class="o">=</span> <span class="n">axes_10</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">symp_per</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s">'Wistia'</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_83_0.png" alt="png" /></p>

<h2 id="tics">tics</h2>

<p>non chiaro perche’ all’inizio metta un np.arange, dato che abbiamo gia’ un array con dates e symptoms:</p>
<ul>
  <li>ok: <code class="language-plaintext highlighter-rouge">axes_10.set_xtics(np.arange(len(dates))</code> qui definisce la distanza (posizione) che devono avere i tics sulla mappa.</li>
  <li><code class="language-plaintext highlighter-rouge">axes_10.set_xticlabels(dates)</code> questo definisce cosa ci deve essere nei ticks</li>
  <li>occhio che ticks ha la k</li>
  <li>occhio i ticks vanno assegnati <strong>DOPO</strong> avere definito la figura e l’axes</li>
  <li>giro i ticks di 45 gradi! <code class="language-plaintext highlighter-rouge">plt.setp(axes_10.get_xticklabels(), rotation=45, ha='right', rotation_mode='anchor')</code> (non chiaro l’anchor cosa faccia)</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fig_10</span> <span class="p">,</span> <span class="n">axes_10</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">im</span><span class="o">=</span> <span class="n">axes_10</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">symp_per</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s">'Wistia'</span><span class="p">)</span>

<span class="n">axes_10</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dates</span><span class="p">)))</span>       <span class="c1"># posizione tics sull'asse x
</span><span class="n">axes_10</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">symptoms</span><span class="p">)))</span>    <span class="c1"># posizione tics sull'asse y
</span>                  
<span class="n">axes_10</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">dates</span><span class="p">)</span>                 <span class="c1"># cosa viene mostrato ad ogni tic dell'asse x 
</span><span class="n">axes_10</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="n">symptoms</span><span class="p">)</span>                 <span class="c1"># cosa viene mostrato ad ogni tic dell'asse x 
</span>                  
<span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">axes_10</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">(),</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">45</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s">'right'</span><span class="p">);</span>                  

</code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_85_0.png" alt="png" /></p>

<h2 id="numeri-nelle-caselle">Numeri nelle caselle</h2>
<p>metto qui anche i numeri dentro le caselle. Nota che usa un costrutto che non ho mai usato prima, chiama un metodo dell’axes dentro una funzione di matplotlib.</p>

<p>-<code class="language-plaintext highlighter-rouge">plt.setp(axes_10.get_xticklabels(), rotation=45, ha='right'); </code></p>
<ul>
  <li>chiama</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fig_10</span> <span class="p">,</span> <span class="n">axes_10</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">im</span><span class="o">=</span> <span class="n">axes_10</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">symp_per</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s">'Wistia'</span><span class="p">)</span>

<span class="n">axes_10</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dates</span><span class="p">)))</span>       <span class="c1"># posizione tics sull'asse x
</span><span class="n">axes_10</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">symptoms</span><span class="p">)))</span>    <span class="c1"># posizione tics sull'asse y
</span>                  
<span class="n">axes_10</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">dates</span><span class="p">)</span>                 <span class="c1"># cosa viene mostrato ad ogni tic dell'asse x 
</span><span class="n">axes_10</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="n">symptoms</span><span class="p">)</span>                 <span class="c1"># cosa viene mostrato ad ogni tic dell'asse x 
</span>                  
<span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">axes_10</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">(),</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">45</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s">'right'</span><span class="p">);</span> 

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">symptoms</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dates</span><span class="p">)):</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">axes_10</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">,</span> <span class="n">symp_per</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span> <span class="n">ha</span><span class="o">=</span><span class="s">'center'</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s">'center'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'k'</span><span class="p">,</span> <span class="n">fontweight</span><span class="o">=</span><span class="s">'bold'</span><span class="p">)</span>


</code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_87_0.png" alt="png" /></p>

<h1 id="riempire-le-aree-tra-curve">Riempire le aree tra curve</h1>

<p>ci sono ottimi esempi al sito di matplotlib:</p>

<p>https://matplotlib.org/3.1.1/gallery/lines_bars_and_markers/fill_between_demo.html</p>

<p>il metodo degli assi <code class="language-plaintext highlighter-rouge">fill_between()</code> permette di riempire quello che c’e’ tra una curva e l’altra.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>           <span class="c1"># le x
</span><span class="n">y1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>            <span class="c1"># y1 = la funzione seno
</span><span class="n">y2</span> <span class="o">=</span> <span class="mf">1.2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>      <span class="c1"># y2 = funzione seno piu' larga e con maggiore frequenza
</span></code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">,</span> <span class="n">ax3</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  

<span class="n">ax1</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span>          <span class="c1"># riempie tra 0 e y1
</span><span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">'TRA y1 e 0'</span><span class="p">)</span>

<span class="n">ax2</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>          <span class="c1"># riempie tra y1 e 1 (quello che c'e' sopra y1) 
</span><span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">'TRA y1 e 1'</span><span class="p">)</span>  

<span class="n">ax3</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span>         <span class="c1"># quello che c'e' TRA y1 e sotto y2
</span><span class="n">ax3</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">'TRA y1 e y2'</span><span class="p">)</span>
<span class="n">ax3</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">'x'</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Text(0.5, 0, 'x')
</code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_90_1.png" alt="png" /></p>

<p>si possono mettere ulteriori condizioni per dare dei colori diversi tra le curve.
In particolare si aggiungono dei parametri logici.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">ax1</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>       <span class="c1"># costruisce subplots
</span><span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'black'</span><span class="p">)</span>                   <span class="c1"># disegna le 2 funzioni 
</span><span class="n">ax</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">y2</span> <span class="o">&gt;=</span> <span class="n">y1</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s">'green'</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">y2</span> <span class="o">&lt;=</span> <span class="n">y1</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s">'red'</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">'fill between where'</span><span class="p">)</span>

<span class="c1"># Test support for masked arrays.
</span><span class="n">y2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_greater</span><span class="p">(</span><span class="n">y2</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'black'</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">y2</span> <span class="o">&gt;=</span> <span class="n">y1</span><span class="p">,</span>
                 <span class="n">facecolor</span><span class="o">=</span><span class="s">'green'</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">y2</span> <span class="o">&lt;=</span> <span class="n">y1</span><span class="p">,</span>
                 <span class="n">facecolor</span><span class="o">=</span><span class="s">'red'</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">'Now regions with y2&gt;1 are masked'</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Text(0.5, 1.0, 'Now regions with y2&gt;1 are masked')
</code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_92_1.png" alt="png" /></p>

<h1 id="ticks">Ticks</h1>
<p>Al comando ticks possono essere passati degli argomenti per specificare:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">rotation = 45</code> ruota di 45 gradi</li>
  <li>se il primo ingresso e’ un np.array allora quelli sono i ticks (le posizioni)</li>
  <li>se il secondo ingresso e’ una tupla, allora alle varie posizioni dei ticks vengono messi i valori della tupla</li>
  <li><code class="language-plaintext highlighter-rouge">fontsize=24</code> viene passato</li>
</ul>

<p>come al solito puoi passare piu’ di un parametro basta che sia separato dalla virgola!</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span><span class="n">y_1</span><span class="p">)</span>
<span class="c1">#plt.xticks(np.linspace(0,5,100))
#plt.xticks(np.arange(15))
#plt.xticks(np.arange(5), ('Tom', 'Dick', 'Harry', 'Sally', 'Sue'))
#plt.grid(False, color='r', dashes=(0,2,1,2)) 
</span><span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span> 
<span class="c1">#plt.grid(b=None)
</span><span class="n">degrees</span> <span class="o">=</span> <span class="mi">45</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="n">degrees</span><span class="p">)</span>           <span class="c1"># Rotazione dei ticks 
</span><span class="n">mioArray</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span>
<span class="c1">#plt.xticks(np.linspace(0,5,5), ('Tom', 'Dick', 'Harry', 'Sally', 'Sue'))
</span><span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>                         <span class="c1"># presenza della grid 
</span><span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">24</span><span class="p">)</span>                <span class="c1"># GRANDEZZA FONT
</span><span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">mioArray</span><span class="p">,</span> <span class="p">(</span><span class="s">'Gino'</span><span class="p">,</span> <span class="s">'Pino'</span><span class="p">,</span> <span class="s">'Mino'</span><span class="p">,</span> <span class="s">'Tino'</span><span class="p">,</span> <span class="s">'Asdrubale'</span><span class="p">));</span>
</code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_94_0.png" alt="png" /></p>

<h1 id="animazioni">Animazioni</h1>
<p>Testo di riferimento:  https://riptutorial.com/Download/matplotlib-it.pdf</p>

<p>Lo ho scaricato ed e’ nella dir.</p>

<ul>
  <li>Bisogna importare anche la parte del package che fa animazioni.</li>
  <li>Bisogna usare il metodo <code class="language-plaintext highlighter-rouge">set_data()</code> che assegna i valori delle x e y di un grafico</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="n">matplotlib</span> <span class="n">notebook</span>
<span class="kn">import</span> <span class="nn">matplotlib.animation</span> <span class="k">as</span> <span class="n">animation</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TWOPI</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>                    <span class="c1"># costruiamo una figura e un array di assi
</span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">TWOPI</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">)</span>            <span class="c1"># t =array di posizioni 
</span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>                               <span class="c1"># y = sin(t) 
</span><span class="n">l</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>                          <span class="c1"># grafico  
</span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="n">TWOPI</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>               <span class="c1"># assi
</span>
<span class="n">redDot</span><span class="p">,</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">0</span><span class="p">)],</span> <span class="s">'ro'</span><span class="p">)</span>  <span class="c1"># l'oggetto "redDot" disegna il punto rosso, all'inizio e' in zero
</span>
<span class="k">def</span> <span class="nf">animate</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>                             <span class="c1"># questa funzione modifica i parametri del punto rosso
</span> <span class="n">redDot</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>              <span class="c1"># quindi il resto del grafico resta invariato!  
</span> <span class="k">return</span> <span class="n">redDot</span><span class="p">,</span>

<span class="c1"># create animation using the animate() function
</span><span class="n">myAnimation</span> <span class="o">=</span> <span class="n">animation</span><span class="o">.</span><span class="n">FuncAnimation</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">animate</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">TWOPI</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">),</span> \
 <span class="n">interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">blit</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;IPython.core.display.Javascript object&gt;
</code></pre></div></div>

<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAhwAAAFoCAYAAAAcpSI2AAAAAXNSR0IArs4c6QAAIABJREFUeF7snXd8HMX5xp+9IstykXvv1u3J3ZYhphmMwXRiurGxTfkBIYTqAAkdAhiIQ0lCMRAguGEILVTTO6G44np7cpd7QXKRZenu9veZPcmcZUm3d5q92z09+w9YOzvlmXfe+d67szMKeFEBKkAFqAAVoAJUwGIFFIvzZ/ZUgApQASpABagAFQCBg0ZABagAFaACVIAKWK4AgcNyiVkAFaACVIAKUAEqQOCgDVABKkAFqAAVoAKWK0DgsFxiFkAFqAAVoAJUgAoQOGgDVIAKUAEqQAWogOUKEDgsl5gFUAEqQAWoABWgAgQO2gAVoAJUgApQASpguQIEDsslZgFUgApQASpABagAgYM2QAWoABWgAlSACliuAIHDcolZABWgAlSAClABKkDgoA1QASpABagAFaAClitA4LBcYhZABagAFaACVIAKEDhoA1SAClABKkAFqIDlChA4LJeYBVABKkAFqAAVoAIEDtoAFaACVIAKUAEqYLkCBA7LJWYBVIAKUAEqQAWoAIGDNkAFqAAVoAJUgApYrgCBw3KJWQAVoAJUgApQASpA4KANUAEqQAWoABWgApYrQOCwXGIWQAWoABWgAlSAChA4aANUgApQASpABaiA5QoQOCyXmAVQASpABagAFaACBA7aABWgAlSAClABKmC5AgQOyyVmAVSAClABKkAFqACBgzZABagAFaACVIAKWK4AgcNyiVkAFaACVIAKUAEqQOCgDVABKkAFqAAVoAKWK0DgsFxiFkAFqAAVoAJUgAoQOGgDVIAKUAEqQAWogOUKEDgsl5gFUAEqQAWoABWgAgQO2gAVoAJUgApQASpguQIEDsslZgFUgApQASpABagAgYM2QAWoABWgAlSACliuAIHDcolZABWgAlSAClABKkDgoA1QASpABagAFaAClitA4LBcYhZABagAFaACVIAKEDhoA1SAClABKkAFqIDlCjgGOFRVnQRgoKZpl9Sgisvn8z2qKMoEAGFFUR4JBAIPV6ar657lArMAKkAFqAAVoAJUALA9cOTl5TVyu9136Lp+G4DpNQGH3++/Xtf1sV6v97SysrJWbrf7YwCXa5r2aV33aABUgApQASpABahAahSwPXCoqvoygGaKohTpup5dE3CoqvqDoihTAoHAa0I2VVX/COBwTdMurOteaiRmKVSAClABKkAFqIDtgaNPnz4dly9fvklV1XsA9KgFOErcbvfRy5cvXyK61OfznaEoymRN0waqqlrrvRq6PwTABWAXTYMKUAEqQAWoQBoUaA4gAsCThrItLdL2wFHV+jjAEdJ1XQ0Gg6tEer/fP1LX9Wc1TctTVbXWezUoKzpZyc3NtVR0Zv6rAjqAUFhHKBJBKKJDF3+oxyUM2u1S4HEr8LpcUBxj4fVoNB+lAlQgYxQoKSkRbRGeUPz4zajLMe44DnDsikQiRxYWFi6NiXDcr2naYFVVa71XQ08W5+bm5s5bsiajOjmZxvTu0gIri4qTeTTuM+GIjv+t2YmPV2zFD2t+QUXkUMrIcrvQrVVjtG/WCG2aZKFZtgfiby5Fwf5QBKXlIRTvq8DGkjIUFZdh934RnDr06tO+GU7r1x7H57VB4yx33LrVlMBKLZKqUJoeog6/Ck8tqEX1YSjLJob0647du3YJ6miRpqFuWbGZAhw/AnhQ07Q3hVKVazh+o2naGFVVa71H4KjdrmQNntgSBCR8sHwr3ly0EZt27T+o8GaNPBjaNRcFXVugX4fm6NqysRGpMHPpuo6te8qxbPMuLN64y4CYzbsPzr+x14XT+3XAeYM7oW3TRmayPZDGCi0SqoBNElMHTrIEcut9JoHDBg4vToRDfDI7JhwOn6koSjOXy/WJoijXBwKBtys/p63xHoHD+sEjStgfCuOtnzfh5XkbDopE5HjdGN67NU70t8WgzrmmASOeOQoAWb2jFJ8Ht+PDFVuxY2/5gUe8LgUn5bfDhN90NQ0enGij8lEHAgeBw3qfSeCI5+FTcL86cKiqulQsDA0EAjNHjBjh2bhx40MAxos1GIqiPFq1D0dd9wgc1g6eiK7jw+Vb8e8f1mF7zKTfOTcb5w7uZEz8jb3JveYwa3Li9c0Pa3/B6ws3YuEG492ocTXyuHDBkM4YM6Rz3FctnGgJHNXtjTZB+LLKJggcZr2789NxDUdlH9bXoa7cvhePf7ESyzbvPmAV3Vo2xqXDuuGY3q2NtRipvkRdZs5dj+/X/HKg6NY5Xlx7XG8j0lLbVV8tUt1Oq8qjDpxkGeGw9keayJ3AYZUHs1++BI56Akd5OIKXfliHVxdsQNVa0LZNs3DJsG4Y5W8n7bVJfUzn5w0lePqb1dC27T2QjQCO647thVZNsg7JmhMtIxxW/Zqtjx3b5VmOD7njg8BhF8u2vh4EjnoAx5odpZj8sQYR3RCXWPMpFmlOPLxb3NcW1nftwSWI1z0frdiKqd+sObCuRCxcnXR8bxyb1+agxHSoch1qqvvaivJoE4z2WAWhBA4rRqw98yRwJAEcYpHmfxdvxjPfroGIcIjL364p/jgyD73bNLFnT1fWamdpOZ78ahW+KNxxoJ6/7d8BVx3TA4080fUlnFwIHFZNLrYeHCYrx/Ehd3wQOEwaXgYkI3AkCBz7KsJ45LNC44uQqqjG2KFdMPHwrvC4nbNvzVeF2/HI54XYsz9stKNn6xzce2o+OrdoTOBI0CYywA/EbQInWUY4rIJQAkfc4ZcxCQgcCUwuYtOtu99fjlU7So2n2jVrhFtH+TCwkzN3at2yqwwPfKRhaeVCV/GK5a5T/Dj/yB6WbYLmpJHDSZaTbE32SrtghMOsH0v9pwJma5aedAQOk8CxaEMJ7n5/xYH1DwVdcnHHyX7kNvamp+cklSo+o33++7V4Zf6GAxGbu87oi2O6tRDfW0sqxZnZcGIhcBA4ah+7ssYHIxzO9I/J1JrAYQI4vghux0Mfawe2JL9gSCdcfmQPW3yBkkyn1/TMJ4Gt+NtnhagIR7ddP2tAR/zh2J5p+ZxXVpvqm48sh1rfetjheWpB+Kpuh7JsgsBhhxGemjoQOOIAx2sLN+Dpb6JnzYitx28emYdR+e1S0zspLmXFlt24673l2FFaYZR8vK8N/nSiD14HrU2RKZkshyqzTunKi1oQOAgciY++hh0jPlQvAkctwCG+RHnuf7++ahDbkt9zWj6Gds2484UOsopte/bjjvdXoHDrHuPvor1iMWmyB8ElPkTt8wQnWU6yNVkj7SKqiiwdGOGwj8+zuiYEjhqAQ8DGU9+sxhuLNhl3xe6ck8/si7y2Ta3uD1vk36plDsY9+z2Wb4numtqnfVM89Nt+aNrIY4v6paoSshxqquprZTnUgvDFCEfiI4wRjoM1I3BUAw6xQdY/v1qFtxdvNu50bN4IfzurPzo0z07c2hz6hJhclqzegb/MCeDHtdFt0cWx9w+P7osmWQ0HOjjJcpJlhKN2JyZrfDDC4dCJIolqEzhigCO4/hfjPJT3lm4x/topNxuPnNXf+Py1IV1VjqQiHDGg47vVOxskdMhyqJlgO9SC8MUIR+IjmREORjhqtJpenXPxx9kLDrxG6dIi24hstG3asGBDiBM7udQEHX8d3Rc5DSDSwUmWkywjHIxwJI4Zvz5B4CBw1Gg/767Yhsc+0Yx7AjYePXsAWtdwsFl9jM8pz1afaKtDR0HXXDxwRl9kZfjXKwQOAgeBg8BRH79N4CBwHGI/by7aiCe+Xm38vV3TLDx+7kC0b2CvUWJFqWmiFdAhNj77oXJNxwhfG9w2Ss2ovUisChnXx2HZ5VnCF+HLqvHBNRx2GeXW16PBr+EQG149+HHQULpFYy8eP6c/urbMsV55G5dQ2+RSVhHGLf9demAr9NEDOuDaY3tl7I6knGQ5yTLCwQhHfVw1IxyMcBxQYGFRCf709lKEIjrEOSJTzuoHXwP59LWuQVTXRLurrAI3vrEEa3ZGz5O5dFg3jD+8a33GpG2fJXAQOAgcBI76OCgCB4HDUGD9L6W49rXFxtkoHpeCGZcPQ9us6PHsDf2KN9GKzcGue30xtu7eb0h1+0kqRqptM062eDpkXIPraBC1IHxVNw9ZNsFXKg3HkzTIVyol+ypwzWs/Q5z+Kq4/j/LhqhNUnpBaafdmHMnanQLYfsbe8jC8bsVYZNu3Q7OMGjlmdMioBhM4THUn7SIqkywdCBymzC4jEjU44CgPRXDzf5dgyaboLpoTD++Ki4d1kzZ4MsEqzDqSueuKces7SxHRo+tfnjp/INpn0AZpZnXIhD6P1wZqwQgHIxzxRsmh9/lK5WBNGhRwiC3Lp3xaiA9XbDVUOEFti1tH+YxFj3SoyTnUd5ZswuNfrDIe7tk6B/84d0DG7NFBm0jOJhJ3y856gnbBCIdZiyVwNGDg+O/iTfjHl9HJsX/HZphyVv8De0nQiSQ/uTz59aoDG6YN79Uad5/qz4gvV2gTyduEWYfsxHS0CwKHWbslcDRQ4FiyaRcmvbkE4YhubOg19YJBaBWzsRedSPKTi9D09neX4ad1xUYmVxzVHRcWdDE7Jm2bjjaRvE3YtlMlVIx2QeAwa0YEjgYIHNv37MfvX12EnaUVxhcpj57dH/06Nj9ICTqR+k0u4nPZq19dhE279sOlAA//th8KurYwOy5tmY42UT+bsGWnSqgU7YLAYdaMbA8cPp9vmKIoUxVFUXVdnx+JRC4pLCxcGdtAVVWXAuge87csXdfXBINB1e/3N9N1XfzU3Bdz/y5N0x6tQaSMX8Mhdsj845tLDmxWdcOI3jizf4dDpKATqf/kEty2B9e9thjl4Qhysz2YOmawow++o03U3ybMOmYnpaNdEDjM2qutgaNHjx7ZWVlZq3Rdv8nr9b4WCoX+DGCUpmnDa2tgr169cj0ez3xd168PBoPv+v3+o3Vdf0rTtEEmRMl44Hjq61V4fdEmQ4rT+rbHpON717i+gE5EzuTy0YqtePiT6M6t+e2b4rFzBjj2zBXahBybMOGHHJWEdkHgMGuwtgYOVVVPBTBF07T+lQ1yq6q6HcCRmqatqKmRfr9/qq7rbk3TrhD3VVW9GsARmqZNNCFKRgOHOFb9zveWGzL42zXF4+fWPvnRicibXP7+xUq8vWSzkeG5gzri6uG9TJii/ZLQJuTZhP16N/ka0S4IHGatx+7AcaOiKEcHAoHzqhrk8/nmApgcDAbfqN5In8/XR1GU78UeLJqmCTARwPEMABHdaAmgKYDZHo/n1mXLlpXXIFLGAofYBfPK2QuNnUSbZLmN8H6n3Oxa7YRORN7kIl5jXf/6YgS27jEyvf/0PjiyZyuzY9Q26WgT8mzCNp0qoSK0CwKHWTOyNXD4fL47xNqN2OiEqqpfKYrybCAQmFG9kaqqPgtgj6Zpk6ruqar6iK7rFeFw+EEA4nXL6wDe0zTtntqAo7g4+nVBplyhcARjn/seP635xWjSE+OG4IyBnTKleY5ox9ode3H6P77Bnv0htMzx4oPrj0WHOoDPEY1iJakAFZCuQIsWLVBSUlIizs+UnnmaM7Q1cKiqOknX9SODweD5VTqJCIeiKPdrmvZWrHZ9+/bNCoVCWyORyNGFhYViEWmNl8/nO1dRlNs1TSuoDTjmLVmT5m6RW/yL36/FjLlFRqan9xPrNvLiFsBfLb9KJEuLz7RteOAjzch4UOfmmDK6v6OOs5elQ1zjc0ACaiF/fDig2+usoiyb4NbmabIEVVVPA/BgzIJPsYZjRyWERBcjVF5+v/94Xdenaprmj/27qqr36rr+UjAYNHa48vl841wu1zWBQOCohgAcC4qKcfNbS6GLnS9b5eDJCwaikSf+oWyyBk+aTEdqsTK1mPJpEHOWR3d2ddrJsjJ1kNpBaciMWhA4qpudLJsgcKRhQIsiu3Tp0jgnJ2c1gFs8Hs9s8ZWKoiijA4HA0OpV8vv9f9J1va+maRdXA5G3dV0v3bNnz2W5ubltw+HwO4qiPB0IBJ7OdOAQ4fvLX16AbXvK0cjjwlMXDEKPVjmmelPW4DFVmM0TydRiX0UYv39lEdYX7zP253j8nAGH7IFiVzlk6mDXNpqtF7UgcBA4zI6WX9PZ+pWKqGZ+fv7QSCQyVfwvgIVV+3CIvTcURZkcCARmVkYungKwKxgMik9nD1w9e/Zs7/V6xb3jAYREFCQYDN4NGD/6q18ZtWj0wY81fBLYZrSxtv02ajMZOlTrHOrK7Xvxh1cXoSKio3NuNp65cDAae+NHnRIf3nKfoE1YZxNyeyq1udEuonrL0oERjtTabzpLyxjg+LJwO/4yJ2BoOax7SzxwRp+EzvOQNXjS2ZmyyrZCi1fmF+HZ79YaVRw9oAOuO663rOpalo8VOlhWWYszphaEr+omJssmCBwWD14bZZ8RwLFjbzn+b9YC4xPYZo08eH7cEOO8lEQuWYMnkTLtmtYKLcR5K+IsG3GmjbjE1ueHdbP3onQrdLBrn8erF7UgcBA44o2SQ+/b/pVK4k2q1xOOBw5x5Pzt7y7HD2ujn8DedYofx+W1SVgUOlTrHerGkjJcMXsByioiaNMkC/8aOwTNsj0J91WqHqBNWG8TqepLmeXQLqJqytKBEQ6Z1mnvvBwPHO8u2YzHvogeNXOC2ha3naQmpbiswZNU4TZ7yEotYvvrRH9b3Doquf5KhWRW6pCK+sssg1oQvhjhSHxEMcJxsGaOBo4tu8rwfy8vwD4Jv5jpUFPjUEVE6rZ3l+PHyojUvafm45jerRMfySl4gjaRGptIQVdKLYJ2wQiHWYMicGQIcIiJ69Z3luGnddFdUh/+bV8c1k3s5p7cRSeSusklds1NqxwvXhhXYMtXK7SJ1NlEcqM2PU/RLggcZi2PwJEhwPHxiq14qPJU0lP6tMPNJ/jM2kCN6ehEUju5xJ4qK6P/6tX5tTxMm0itTVjRh1bkSbsgcJi1KwJHBgDHL6XluHRm9KsUWb+Q6URSO7mICNWf316GueujEaopo/uhoKu9vlqhTaTWJsw68XSno10QOMzaIIEjA4Djvg8D+CJoHI6Lu0/x49gkvkqpbjB0IqmfXDZXrsERX610bJ6N58baa0Mw2kTqbcKsI09nOtoFgcOs/RE4HA4c367agbveX2G0Yniv1rjnNLEha/0vOpH0TC5vLNqIJ78Wu/kD5w3uhN8f07P+nSkpB9pEemxCUvdZlg3tgsBh1rgIHA4GDnFWymWzFkAsOmzayG0sNkx0g6/aDIVOJD2Ti9gQ7IY3FmPZ5t3GWSv/PG8g8ts3MzueLU1Hm0iPTVjaqRIyp10QOMyaEYHDwcDx+Bcr8c6SzUYLbh6Zh1P6tjfb73HT0Ymkb3JZs7MUV81eaJy10rN1DqZeMAgetytun1mdgDaRPpuwum/rkz/tgsBh1n4IHA4FjhVbduOa//xsnEBX0CUXfx3dL6GzUuIZCJ1IeieXaT+uw0s/rjcq8buje+CCIZ3jdZnl92kT6bUJyzs4yQJoFwQOs6ZD4HAgcIiw+x/+swjBbXvhdSl4buwQdG3Z2Gyfm0pHJ5LeyaU8HMEVLy9AUXEZsr0uvDiuAO2aNTLVd1Ylok2k1yas6tf65ku7IHCYtSEChwOB481FG/FE5cLC8Yd1waVHdDfb36bT0Ymkf3KZv74YN/93qVGR4b1b455T5SwINm0E1RLSJtJvE8n2nZXP0S4IHGbti8DhMOAQC0QvnTkfe8vDxqeTz48bjEYet9n+Np2OTsQek8sDHwbwWeUnz5PP7Ith3ZPfPdZ059eSkDZhD5uobz/Kfp52QeAwa1MEDocBR6omIDoRe0wuqQJMMw6DNmEPmzDTV6lMQ7sgcJi1NwKHg4Bj3vpi3JKiEDudiH0ml1S8QjPjMGgT9rEJM/2VqjS0CwKHWVsjcDgEOFK9iJBOxD6Ty6GLhAeja8scs2NcWjrahH1sQlqnSsiIdkHgMGtGBA6HAMfMuevxwvfrjNqm4jNJOhF7TS6xn0Ef1rUFHvptX6mfQZtxGLQJe9mEmT5LRRraBYHDrJ0ROBwAHNv27MclM+dDnLHRo1UOnhlj/UZQdCL2m1we+7wQ7y7dYlTsvtPzcVTP1mbHuZR0tAn72YSUjq1nJrQLAodZEyJwOAA4HvxYwyeBbUZN/3ZWPwzpYv0ponQi9ptcSvZVYOKMedizP4xOueILpSHISuEOpLQJ+9mEWUdvZTraBYHDrH0ROGwOHEs37cJ1ry82ainzcLZ4BkInYs/JJfZwt8uP7I6xQ7vE60pp92kT9rQJaR2cZEa0CwKHWdMhcNgYOCK6bmxfHti6B163ghcvKjD23kjFRSdiz8klFI7gylcWYu3OfWjsdeGl8UOlHdgXz65oE/a0iXj9ZvV92gWBw6yNEThsDBxzlm3BlM8KjRpedFgXXGbBjqK1GQqdiH0nl9jPo0f52+LPo1Sz471e6WgT9rWJenVsPR+mXRA4zJqQ7YHD5/MNUxRlqqIoqq7r8yORyCWFhYUrYxvo9/ub6bpeDGBfzN/v0jTtUQAun8/3qKIoEwCEFUV5JBAIPFyLQMW5ubm585asMaufZen2lodw8Yz5+KW0Am2aZOHf4wvQ2Ct/R1ECR/wutKNDvev95fh21U6j8k+cNxB9Olh/hL0ddYjfe9akoBaEr+qWJcsmhvTrjt27dpUAsH6xnjXDo9ZcbQ0cPXr0yM7Kylql6/pNXq/3tVAo9GcAozRNG14NOI7Wdf0pTdMGVW+p3++/Xtf1sV6v97SysrJWbrf7YwCXa5r2aQ2q2AY4nvl2DV5dsMGo4q2jfDjR3y6lpiFr8KS00hYVZkctNpbsw2UzFxhH2Oe3b4p/njcQLsXa4WxHHSzq8rjZUgsCB4Ej7jA5JIG1Hirx+hz0hKqqpwKYomla/8obblVVtwM4UtO0FVWJVVW9GsARmqZNrF6kqqo/KIoyJRAIvCbuqar6RwCHa5p2oV2Bo6h4H/5v1gKEIjr6dWiGv587gHsu1NOW6vO4XSeXf/1vLV6eV2Q07ZYTfDi5j7VQalcd6tO3yT5LLQgcBI7ER4/dgeNGRVGODgQC51U1zefzzQUwORgMvhEDHM8AENENcbJVUwCzPR7PrcuWLStXVbXE7XYfvXz58iUivc/nO0NRlMmapg20K3Dc+d5yfLd6J0TnPHXBIKjtRJNSe9Gh2t+h7isP4+KZ8yHOW2ndJAsvWfzajTZhf5tIrZeIlka7kKsDX6mkw4qjcHCHWLsRG7lQVfUrRVGeDQQCM2KA4xFd1yvC4fCDAHI9Hs/rAN7TNO0eVVVDuq6rwWBwlUjv9/tH6rr+rKZpebUBR3GxWA6Snut/K3dg7HPfG4WfP7QLppx/yFui9FSMpdpSgdfnFeGP/1lk1G3SKBXXneCzZT1ZKSpABcwp0KJFC5SUlHANhzm55KVSVXWSrutHBoPB86tyFREORVHu1zTtrdpK8vl85yqKcrumaQWqqu6KRCJHFhYWLhXpKyMc4vnBtQFHuhaNis9g//DqImjb9iLbIz55LECbpo3kCZpATvzV8qtYdtZC2MzvX1mEwu17ke11Yfr4oWjVJCuBnjaf1M46mG+FnJTUwhnjQ05vm8tFlk0wwmFOb+mpVFU9DcCDMYtBxRqOHZUQsryqQFVV79V1/aWqKIbP5xvncrmuCQQCR6mq+mNlHm+K9JVrOH6jadoYuwHHp4FtmPyxZlRrwuFdccmwbtI1NZuhrMFjtjw7p7O7FguKinHTWwZP4/R+7THp+JqCd/VX2O461L+F5nOgFgSO6tYiyyYIHObHodSUXbp0aZyTk7NarInzeDyzxVcqiqKMDgQCQ2ML8vv9b+u6Xrpnz57LcnNz24bD4XcURXk6EAg8LaIkAMaEw+EzFUVp5nK5PlEU5fpAIPC2nYCjPBQx3sdv3b0fLXO8xi/Vxlmp+wzWqsEj1SDSlJksR2Jl9W97Zxl+WPsLXArw3IVD0KO1/NNknaCDlRrH5k0tCBxW+UwCR6pGcQ3l5OfnD41EIlMB5ANYWLUPh6qqS8Xiz0AgMLNnz57tvV7vUwCOByDWbEwNBoN3A9BHjBjh2bhx40MAxgPiYw/lUTvuwzF7fhGe+26tocCNI3rjjP4d0qg6F4I5bXJZs7MUV7y8ABEdGNa9JSaf2Ve6/XCS5SRbk1HRLqKqyNKBwCHdddk2w7TswyEO5ZowfR72lofRvVVj4xeqW/xUTeMla/CksQnSinaKFrGnyf51dD8M7Sp33yCn6CCt4+vIiFoQvhjhSHykpXdWS7y+Vj+RFuB44qtVePPnTUbbHjijD47o0crqdsbNnw7VeQ51595y4zTZfRUR9G7TBE9fMEgquNImnGcTcQe6hAS0C0Y4zJoRgeNgpVIOHGKTr8tmLUA4omNIl1xMGd0v5Zt8MUxa93BxkkOd8dN6vPjDOqNBN5+Qh1P6tDfrC+Kmc5IOcRtTzwTUgvDFCEfig4jAkWbguOf9Ffh61Q5jk6+nxwyCr23qN/kicGQOcJRVhDFxxq+bgU0bX4BsSWfwcJLlJEtfUbuvkDU+uIYjcZBx6hMpjXAs2bQL17++2NAqlad+mukcWYPHTFl2T+M0LeYs34Ipn0ZPGb78yO4YO7SLFImdpoOURteSCbUgfDHCkfgIY4QjTREOXddxwxuLsWTTbmS5XcZpsO2bpWeTL/5qyZwIh2iJeD33u9kLsXpnKZo2cmPGhMPQLNuTuHeo9gQnWU6y9BWMcNTHkRA40gQc36/Zidvfje5ddsGQzvjd0T3q04/Sn+Xk4uzJRZzFI87kEdeFBZ1xxVH1ty/ahLNtQrqTqMyQdhEVQpYOfKVilaXaL9+UvFIR21GLX6CrdpSiSZYbMyYORfNsr63UkDV4bNWoJCvjRC2qR9CmTShA23puk+9EHZLs8riPUQvCV3UjkWUTBI64wy9jEqQEOGK3ML/siG646LCuthNQ1uCxXcMlYwHKAAAgAElEQVSSqJBTtVi8cZfx2k5cMrY8d6oOSXR53EeoBYGDwBF3mBySgK9UDpbEcuCoCEdw6cwF2LSrLLqF+YShaCzpK4LEu7/2J+hQM8Ohxm55/sK4AnRt2ThpM6FNZIZNJG0AtTxIu4gKI0sHRjhkW6h987McOP67eBP+8eUqQ4Frj+2FswZ2tKUasgaPLRuXYKWcrMXK7XuN13c6gOPyWuOuU8QJAcldTtYhuRYTyM3oRrsgcJixE5GGEY4URjj2iT0Sps/DztIKdGzeCC9eVACv22W2r1Kajk4kc37NPvixhk8C24wGPXX+QPjbN0vKlmgTmWMTSRkAIxx1yiZrfDDCIdM67Z2XpRGOWXOL8Pz30QPabh3lw4n+drZVQ9bgsW0DE6iY07XYWFKGS2fORyiiG+eriHNWkrmcrkMyba7tGWpB+KpuG7JsgsAhc6TaOy/LgGNXWQXGT4se0NardQ6euXAwXIp9A0yyBo+9u9tc7TJBi39+uQpvLY6e1yO2zy9I4mC3TNDBXI/HT0UtCBwEjvjjpHoK+854ibdFxhOWAcdz363B7PkbjDref3ofHNkz/Qe01SUYHWpmOdSdpeXGicRlFRH42zXFk+cPTPjMHtpEZtmEDIcp8qBdRJWUpQMjHLIs0/75WAIc2/bsx8Tp81EejqB/x2Z4/JwBCTv7VEsna/Ckut5WlJcpWrz4w1rM+KnIkOjuU/w4Nq9NQnJlig4JNbqWxNSC8MUIR+IjiRGOgzWzBDge+7wQ7y7dYpQkYGNAp+aJ91SKn6BDzTyHurc8hItemofd+0Po0SoHz144OKHj62kTmWcTMtwK7YIRDrN2ROCwGDg2luzDJTOjx88P694Sk8/sa7Zv0pqOTiQzJ5fZ84vw3HfRhcu3n6RipNrWtJ3RJjLTJkwbAKM9dUola3zwlUp9LdI5z0uPcDz8SRAfrdhqKPDMmEHIs8nx8/G6RNbgiVeOE+5nkhbi02yxeLl4XwU652Ybn2a7XeZ+d2SSDvW1O2pB+OIrlcRHkTlPk3i+Tn1CKnCs/6UUl81agIgOHNu7Ne4+NflNl1ItKB1q5jrU1xdtxFNfrzYaePMJeTilT3tT5kWbyFybMGUAjHAwwlEfQ+HGX4eoJxU4HvgwgM+C243d1f41dgh6tM6pZ3el7nFOLpk7uZSHIsYXK9v3lqNDs0b493hzG9DRJjLXJurjWWgXUfVk6cBXKvWxRmc9Kw04Vu/Yiytejm4pPdLXBref7HeUErIGj6Ma3YB+wb2zZBMe/yK6xf4NI3rjzP4d4nYVbYLAUZOR0C4IHHGdR2UCvlI5WClpwHHvByvw1codEK/HXxg3BF1bOie6IZPWzRqindNlokMVhwheMmM+Nu/ejzZNsoxDBLM8dW+zn4k6JGt31ILwVd12ZNkEIxzJjkrnPScFOAq37cHvXllktH6Uvy3+PEp1nBKyBo/jGl5DhTNViznLtmDKZ4VGi68e3hPnDupUZ3dlqg7J2Ci1IHAQOBIfOYxwWBDhuPO95fhu9U4juvHS+AJ0yk3+SPDEu1TOE3Some9Qxafa4oyVDSVlaJnjNaIcjb3uWg2INpH5NpGM96Bd8JWKWbuxPXD4fL5hiqJMVRRF1XV9fiQSuaSwsHBlbAN79eqV6/F4ngBwCoAwgFc9Hs9Ny5YtK/f7/c10XS8GsC/mmbs0TXu0BpHqHeFYsWU3/vCfn42sT+vbHn8cmWe2L2yVjk6kYUwunwa2YfLHmtHYK47qjgsLuhA4TIxEjo+GMT5MmMKBJLJsgq9UElFdYtoePXpkZ2VlrdJ1/Sav1/taKBT6s3hLoWna8NhiVFV9Vtf1ll6v99Ly8vLGLpfrbQDvaJo22e/3H63r+lOapg0yUbV6A8et7yzDj2t/gcelYNr4ArRvnm2iWPslkTV47NeyxGuUyVqIKMcVsxdg7c59aJ7twYyJQ9Eky1OjSJmsQ6JWQS0IHNVtRpZNEDgSHY2S0quqeqo43FLTtP6VWbpVVd0O4EhN01ZUFaOq6nMAntA0zVg44fP5rlUU5SRN085UVfVqAEdomjbRRLXqBRxLN+3Cda8vNor5bf8OuH5EbxNF2jOJrMFjz9YlVqtM1+Krwu24d07AEOWSYd0w4fCuBI44JpLpNpHICKEWUbVk6UDgSMT6JKZVVfVGRVGODgQC51Vl6/P55gKYHAwG36itKFVVPwCwQNO021RVfQaAiG60BNAUwGyPx3OreN1Sw/P1Ao6b31qC+UUl8LoV431426aNJKqR2qxkDZ7U1tqa0jJdi4iu4/evLELh9r1okuXGzImHoVn2oVGOTNchEeuhFoxwMMKRyIiJprX1Gg6fz3eHWLsRG51QVfUrRVGeDQQCM2pqrs/ne1hRlDEul2voihUrdqiq+oiu6xXhcPhBAGKtx+sA3tM07Z7agKO4WCz5SOz6ftUOXPjs98ZDlx7dA3ef2S+xDJiaCqRRgU+Xb8H/vSRYHrh2ZB7+eJKz9o1Jo3QsmgpIVaBFixYoKSkpAdBCasY2yMzWwKGq6iRd148MBoPnV2klIhyKotyvadpbsfqNGDHCs3HjxqkAjo9EIidVX1ga8/y5iqLcrmlaQW3AMW/JmoS6Rtd1THpzCX7euAuNPC7MmDAUrZpkJZSH3RLzF9yvPdIQtBA2LBY7B7buqTXK0RB0MDsOqUXDGh9m7EKWTfCVihm1LUijquppAB6MWfAp1nDsqISQ5VVF5uXlNXK5XG8CaB0Oh89cuXJl9LQ0AKqq3qvr+kvBYNDYVtHn841zuVzXBAKBo2QBx7z1xbjlv0uN7C4Y0gm/O7qnBWqkNktZgye1tbamtIaixQ9rduK2d6PDSqzjEOs5Yq+GooMZK6IWBI7qdiLLJggcZkagBWm6dOnSOCcnR5wydYvH45ktvlJRFGV0IBAYGluc+EoFwIA9e/acsHHjxtLYe36//21d10v37NlzWW5ubttwOPyOoihPBwKBp2UAh/hlKBaKLtu8G9lel/H+u0VjrwVqpDZLWYMntbW2prSGokW8KEdD0cGMFVELAgeBw8xIOTiNrV+piKrm5+cPjUQi4lWJOGp1YdU+HKqqLlUUZXJFRcW7Ho9nJ4AKAKGY5n2tadqpPXv2bO/1ep8Sr1rEfV3XpwaDwbsB45iT6lfCi0bnrivGn96ORjfGFnTG5Uf1SLwXbPgEHWrDdKjfr9mJ22uJctAmGqZNxHNPtIuoQrJ0YIQjnsVlzv2EgEP8IrzhjcVYsika3Zg18TDkZkB0Q+bgyQTTkOVInKBF9SjHrIsPQ9NG0S9WGpIO8fqKWhC+GOGIN0oOvW/7CEfiTarXEwkBx4KiYtz0VjS6cWFBZ1yRIdENTi4H21BDm1xioxwTD++KiyvXcjQ0HeryJNSCwEHgSHyuJXAcrFlCwHHjG4uNL1OyPS7MvDgz1m5UyUGH2nAdam1RDtpEw7UJwlf8yVXW+OArlfhaZ0oK08CxaEOJ8SmsuDLly5TYTpQ1eDLBMBqiFv9bvRN3vBf9YuXi33TFxN904yuVGGNuiDZR21imFlFlZOlA4MiEWcNcG0wDxx/fXIKFG0qi+25MHIpWOc7ed8Oq8KA52e2dSpYjsXcrD66diHJc/eoiaNuiu4+KtRyDerfByqLEN8VzUrvN1rUh2gSBo27rkGUTBA6zo9D56UwBx88bS3DjG9HoxrmDOuHq4c7fd4PAUbvxynIkThse363eiTtjohz3njOQwFHZiQ3VJmqyYWrBCIdZ38Y1HAcrZQo4bv7vEsxfX4IsdzS60drhu4rSiaTml4vZQWmXdCLK8ftXFyG4bS+aNnLj2z+fgO079tqlemmtByfZX+WnFgQOs4ORwJEgcMSeCHv2wI645theZrV2VDo6ETpUoUBslOPGE1Wckd/WUXZsVWU5Pjg+rIoK85WKVaPWfvnGjXD8+e2l+GldMbwuBdMnOvtE2Lrkp0OlQxUKxEY5mmd7jFOQq/blsN/wTV2NOD44PggciY83RjgSiHAs37wb17z2s/HE6AEdcN1xvRNX3CFP0KHSoVYp8N3qHbjzvRXGP8X5KuKclYZ+cXxwfBA4EvcCBI4EgOO2d5bhh7W/wCOiGxOGol2zRokr7pAn6FDpUKsUEFGOq15dhMLKtRzivKCGHuXg+OD4IHAkPpkROEwCR2DLblz9n2h048z+HXDDiMyNbog20qHSocYOjW9X7cBd7zPKUaUJxwfHB4GDwJG4AiaB4453l+F/a6LRjWnjC9C+eXZ9y7L183SodKixBmqcivzGEizbtAvNGnmMr7MacpSD44Pjg8CR+BTGCIcJ4Ahu24OrXllkpDy9b3tMGpmXuNIOe4IOlQ61usmuLCnDldPnGX++dFg3jG/Aazk4Pjg+CByJT2oEDhPAcdf7y/Htqp1wuxS8NL4AHTM8usFXKgcbBSeXqB69OufixEe+xMrte40ox8yLh6JJVvQk2YZ20SYIHASOxEc9gSMOcAjneuXshUaqU/q0w80n+BJX2YFP0KHSodbkUP/95Urc80F0LcdlR3TDRYc1zC9WOD44PggciU9sBI44wCGc69crd8ClwIhudMptnLjKDnyCDpUOtSaHGlz/iwHgq3eUGlGOWRcPRU4DjHJwfHB8EDgSn9gIHHUAx+ode3H5y9Hoxkn57fCnExtGdEO0lw6VDrU2h/pl4Xb8ZU7AuH35kd0xdmiXxD2Pw5/g+OD4IHAkPogJHHUAx31zVuCLwmh048WLCtClRcOIbhA4DjYKTi5RPap0iOg6rnx5IVbvLEVutgdiX47GWe7EvY+Dn6BNEDgIHIkPYAJHLcCxZmcpLp+1ADqAE/1tcesoNXF1HfwEHSodal0O9Yvgdtz3YTTKceVR3TGmoGFFOTg+OD4IHIlPcASOWoDjgQ8D+Cy4HUKgFy4agm4tcxJX18FP0KHSodblUEWU4/KXF2Dtzn1o0dhr7MvR2NtwohwcHxwfBI7EJzgCRw3A8ebXy3DZzGh0Y6SvDW4/2Z+4sg5/gg6VDjWeQ/1M24YHPtKMZL87ugcuGNLZ4VZvvvocHxwf8caHeWs6OCVPi01WOec9Z5wWe95jH+GTwDYjuvGvcUPQo1XDim6IbqNDpUON51DDkWiUY90v+9Ayx4sZE4Yiu4FEOTg+OD7ijY9kpz8CR7LKOe+54mbNc3PbXD0TER0Ykdcad56S77xWSKgxHSodqhmH+klgKx78OGgkvfqYnjh3cCcJ1mf/LDg+OD7MjI9kLJnAkYxqznymuFFO09wO1842av/chYPRq00TZ7aknrWmQ6VDNeNQRZTjslnzUVRchlYiyjFxKBp5Mn8tB8cHx4eZ8ZGMGyZwJKOapGd8Pt8wRVGmKoqi6ro+PxKJXFJYWLiyWvYun8/3qKIoEwCEFUV5JBAIPFyZpq571WtZ3BxK7qed8/HTKWNw0l3XAi6XpJY4Kxs6VDpUsw714xVb8dAn0SjHH4b3xDmDMj/KwfHB8WF2fCTq+QkciSomKX2PHj2ys7KyVum6fpPX630tFAr9GcAoTdOGxxbh9/uv13V9rNfrPa2srKyV2+3+WOxJpGnap3Xdq6GaxblA7g4oUNwulJ56BrY8+UKDhA46VDpUsw5VRDkunTkfG0rK0LpJlrGWI8uT2aDO8cHxYXZ8JDodEjgSVUxSelVVTwUwRdO0/pVZulVV3Q7gSE3Togc6AFBV9QdFUaYEAoHXKv/9RwCHa5p2YV33agOO4sobutuNrY89hT1nXyCpRc7Jhg6VDjURh/rh8q3466fRKMe1x/bCWQM7OsfYk6gpxwfHRyLjIxETG9K3O3bv3lUCoEUizzkhra0/i1VV9UZFUY4OBALnVYnp8/nmApgcDAbfiAGOErfbffTy5cuXiL/5fL4zFEWZrGnaQFVVa70XFzgUBWVDf4ONb85xQl9KrSMdKh1qIg5VRDkunjEfm3aVoU2TLEyfOBRZ7syNcnB8cHwkMj7MOuetu/djeEFvhMv2EjjMiiYrnc/nu0Os3dA0bWIMXHylKMqzgUBgRszfQrquq8FgcJX4m9/vH6nr+rOapuWpqlrrvXjAYdzv3BkoKpLVJOZDBTJWgVd/Wo9bXv/ZaN99Z/XHhCO6Z2xb2TAqYIUCt7+5GA+OPRL6fgKHFfrWmaeqqpN0XT8yGAyeHxvhUBTlfk3T3ooBjl2RSOTIwsLCpTERDpFmsKqqtd6LBxw6Ixwp73M7Fshfs9FeiadDKBzBJTNFlGM/2jXNwktiLUeGRjniaWFHO7aqTtTC3PiIp7+IbkyYPg+rHr2AwBFPLCvuq6p6GoAHNU0bVJm/WMOxoxJClscAx4+V6d4Uf1NVVazh+I2maWNUVa31Xlzg4BoOK7rVcXnSoZp3qO8t3YxHP49+RHbDiN44s38Hx/W3mQrTJn5ViVqYHx912dY/v1yFtxZvwrrHxxA4zAxC2Wm6dOnSOCcnZzWAWzwez2zxlYqiKKMDgcDQ2LJEJATAmHA4fKaiKM1cLtcniqJcHwgE3q7rXm3A8YuiGF+m7OVXKrK71JH50aGad6gV4YixlmPL7v1o16wRpo0vgDcDoxy0CQJHdWdWH5vYvmc/xk+fh4qwjo3/uBAV+/ZwDUc6Zov8/PyhkUhkKgCx5efCqn04VFVdKhaGBgKBmSNGjPBs3LjxIQDjASiKojxatQ9HXfdqBA5Fyd009DfYNfEy7Bl9XoP8JNZM+DwdtpCuMuvjSNJVZyvKNavDu0s247EvolGOScf3xun9Mi/KYVYLK/rBbnlSC/NAXlvfPfn1KryxaJNxe/uT47B3D79SsZudW1Ef4yyVeUvWWJG3o/KkE+EvuGR/wYkox8QZ8yHeSXdo1ggvjS+AJ8OiHBwfHB/Jjo/qz+3cW46Lps1DeTiCgq65+OS207F7F4HDURNmkpUlcFQKR4dKh1ofh/rOkk14/AvjozHcNDIPp/Ztn+SQtOdjHB8cH/UZH7HPTv1mNf6zcKPxp8fO6Y+LRw0kcNhz2EuvFYGDwHGIUXFySTxkLH6tTZw+D9v2lKNj82z8+6IhGRXloE0QOGQAxy+l5Rg/bR7KQhEM6twcj549ANxpVPq8btsMCRwEDgJHLcMz0Un2rZ834Z9fRaMcN5+Qh1P6ZE6UI1EtbOvxJFSMWiQO5FWyP/fdGsyev8H459/O6ochXVoQOCTYpFOyIHAQOAgckoCjPBQxVt7v2FuOTrkiylEAt8vWmxub9lOcZBnhqG+Eo2RfBcZNm4uyigj6d2yOx8/pL754IHCYHoXOT0jgIHAQOCQBh8jmzUUb8cTX4st24E8n+nBSfjvnewkTm6BlRCNNNoLwlVyE44Xv12Lm3Ogu1g//th8O6xY9OoWvVEwaXgYkI3AQOAgcEoHDiHJMm4sdpRXonJuNFzMkysFJlhGO+kQ4dpeFMO6luSitCKNP+2b453kDjOgGgSMDKCKBJhA4CBwEDonAIbJ6fdFGPFUZ5fjzKB9G+Z0f5SBwEDjqAxwv/bAO035ab2Tx4Jl98ZvuLQ9kxwhHAjO2w5MSOAgcBA7JwLE/FDb2GfiltAJdWzTG8+OGOH4tB4GDwJEscOzZH41u7C0Pw9+uKZ48f+CB6AYjHA4niASrT+AgcBA4JAOHyO4/CzZg6rfRDfVuP0nFSLVtgkPTXskJHASOZIFj+k/r8e8f1hmP3396HxzZs9VBWTHCYa+xbmVtCBwEDgKHBcBRVhGNchTvq0C3lo3xr7HOjnIQOAgcyQDH3vIQLnppHnbvDyGvbRNMvWDQQdENRjisnN7tlzeBg8BB4LAAOESWr87fgGe+i0Y57jhZxfE+50Y5CBwEjmSAY9bcIjz//Vrj0XtPy8cxvVofMtoY4bAfGFhVIwIHgYPAYRFw7KsIG7sqiihHj1Y5eG7sYLgqV+ZbNaCtypfAQeBIFDj2lYeNfTd2lYXQq3UOnrmwZvsncFg1au2XL4GDwEHgsAg4RLaz5xfhue+iv/DuOsWP4/La2M8LmKgRgYPAkShwvDK/CM+asH0Ch4kBmCFJCBwEDgKHhcAhfuVdNG0uSspC6Nk6B8/W8ivP7v6EwEHgSAQ4YtcwxYvuETjsPvrl1Y/AQeAgcFgIHCLrl+cV4V//i0Y57jk1H8N7H/oeW96QtiYnAgeBIxHgeG3hBjz9jbn1SwQOa8asHXMlcBA4CBwWA0dpudiHILpSv3ebJpg6ZpDj1nIQOAgcZoFD7EMj1i7tLDX3hRaBw45oYE2dCBwEDgKHxcAhsp85dz1e+D66F0Ftq/WtGeJyciVwEDjMAkfseUK3jvLhxDg77RI45IxRJ+RC4CBwEDhSABxm9iOws8MgcBA4zACHiG5MmDYvobOECBx2Hvly60bgIHAQOFIAHKKI2B0X7zs9H0f1dM5aDgIHgcMMcMSeI2T2tGQCh9xJ3c65ETgIHASOFAGHOFNCfLGyZ38YatsmeKqGXRft6iwIHASOeMARu3YjkZOSCRx2HfXy60XgIHAQOFIEHKKYaT+uw0s/Rk/NfOCMPjiix8HnSsgf4nJyJHAQOOIBR+yXKYmckkzgkDNGnZALgYPAQeBIIXDEOznTrk6DwEHgqAs4xL4b46cnd0IygcOuo15+vQgcBA4CRwqBQxT14g9rMeOnIqPUyWf2xbDuLeWPbMk5EjgIHHUBx6sLNuCZytORbxul4gS/+XODCBySB6uNsyNwEDgIHCkGjl1lFcYJmqUVYfRp3xT/PG/gISdo2s1nEDgIHLUBR+yZQcmcjEzgSNNoz8vLa+tyuV4CMBzAZkVRrg0EAnNqqo7f779T1/UrATQF8E0kEvl9YWGh8bPJ5/PNdblcfXRd1yuf/VjTtLNryIfAQeAgcKQYOERxL3y/FjPnRqMcD53ZF4fbPMpB4CBw1AYcsWem3H6SipGq+eiGyJPAkSbgUFX1TQAbPB7PpHA4PFLX9Vnl5eW91qxZUxxbJZ/PN05RlLvcbvfJFRUVm10u16OCMzRNOwmAW1XVPV6vt/PSpUt3xmkKgYPAQeBIA3CU7KswvljZVxFB3w7N8I9zB9g6ykHgIHDUBBxLVu04cFZQ91aN8dyFQ+B2KQnNoASOhOSSk7hv375NQ6FQcSQS6VhYWLhN5Kqq6ju6rr8XDAanxpaiquo1AHZrmiaiIcjPzx8QiUS+0zStWV5eXl+XyzVH07RuJmpG4CBwEDjSAByiSHG+ijhnRVx/Hd0PQ7u2MDFk05OEwEHgqAk47v/vkgPnBN15sh8jfImfhkzgSMOYzsvLG+JyucSrjwM9pqrq3wBkaZp2XV1VUlX1z4qi/DYQCBzl8/nGKooyGcAWAL3E6xZFUa4JBAIba8iDwEHgIHCkCThElGPctLkoq4igf8fmePyc/raNchA4CBzVh0n7tk1x1IOfYpc4CblVDp4dOzipM4IIHBYCh9/vP0XX9Q9qKOJTEdSIjUz4fL6/KIrSSdO0y2urkt/v/6149aIoysmBQOBbv99/ka7ro0Oh0E3Z2dk7Q6HQ44qi5AUCgRG1AUdx8UFvbCxsPbOmAlQgVoEHP1iOZ75cZfxp1uXDcFRe4r8QqSgVSIcCT35eiCkfBoyin7qoAKcN6JhUNVq0aIGSkpISAPYN8SXVMiCxl0tJFhLnMWXEiBHu6mmKiooGulyuDzVNO7DiRkQ4dF33BIPBG2rKU1XVKwCIKMhYTdPerylNfn5+60gksj0UCrVYtWqV6NTYixEORjgY4UhThEMUWyzWcrw0F2WhCAZ2ao7HzhlgjdepZ66McPwqILUAxNlAE2fMR3FpBXq1zsEzFyYX3RCqMsJRz8GZzON5eXnNXS7XDq/X275qsadYw6EoyvuBQODp6nmqqnoXgD8AOFPTtB+r7quqOiESiWwpLCz8SPzN7/d30nV9fXl5eZM1a9aUEThq7h06ETrU6paRKpt45tvVeHVB9I3nI2f1x+Auucm4EEufSZUWljZCUubU4uDTj+85NR/Deyd/LhCBQ5JhJpqN3+9/W3ylsn///huzs7OPi0Qir3g8nvxly5Ztjs2r8iuVf7jd7iOXL18ejL2nquokAFdEIpFRWVlZxeFw+BkRJdE0bUwN9WGEgxEORjjSGOEQRe8sLcf4afOwPxTBoM7N8ejZ9otycJIlkFcpEHsmUO82TTB1zKCk1m5U5UfgSJQUJKXv3bt3O7fb/SwAsd5ii6Io11ftw+H3+40vVQKBwFVinw1FUQYB2B9btKZpYk8Ot9/vf0jX9QkAcgC8X15eflX1T2srnyNwEDgIHGkGDlH809+sxmsLo1GOx87uj4Gd7RXlIHAQOKoUiD0P6N7T8nFMr+SjGyJPAockgHBANgQOAgeBwwbAsXNvOS6aNg/l4QgGdWqOR8621xcrBA4Ch1BA7JIronF7y8Po27E5/iHhyyoChwNIQVIVCRwEDgKHDYCjepTj4d/2w2Hd7LNon8BB4BAK/Ou7NXh5/gZDjOcvPgw9mjWq91RE4Ki3hI7JgMBB4CBw2AQ4xBcr4yt3H/W3a4onz7fPGSsEDgKHiMJNmD7P+KKqT/tmeP+G4Vi1ofqHj4nPfQSOxDVz6hMEDgIHgcMmwCGqEXuSrIz347IcE4GDwPHEV6vw5s+bDCH+dlY/nHdED6wsqv8eTgQOWaPU/vkQOAgcBA4bAYf4AkC8I9+9P4QeYvfGCwcnfDaFFW6HwNGwgWPL7v24ePo8VER0FHTJxZSz+kOWTRA4rBix9syTwEHgIHDYCDhEVcT5KuKcFXHdOsqHE/3t0u49ZE0uaW+IhAo0RC3+9lkQHyzbaqj3xHkD0adDMwKHCVuyw06jJqqZsiQEDgIHgcNmwLGvIoyJ0+dhZ2kFOjbPxr8vGgKP25Uyp1BTQQ1xkq1N8Iamxfpf9uGyWfMR0YGjerbCfaf3MaSRpQMjHGkd2iktnMBB4CBw2Aw4RHXe+nkT/vlV9IyVG/XVK8wAACAASURBVEf0xhn9O6TUMVQvTNbkktZGSCq8oWlx/4cBfB7cbpwLIrYwF5t9ETjMGRMjHAfrROAgcBA4bAgcYj+OS2bMh3h33qZJFqZPGIosT/qiHA1tkq1rOmlIWqzcvhdXzl5oyDHS1wa3n+w/II0sHRjhMAcvmZCKwEHgIHDYEDhEleYs24IpnxUatfv9MT1w3uDOafM5siaXtDVAYsENSYs731uO71bvhEsBXryoAF1aNCZwJGBLjHAwwlGjuTQkJxJvvFCLqELp1iEc0fF/sxZgffE+5GZ7MGPiUORkeeJ1nyX3062FJY1KMtOGosXyzbtxzWs/Gyqd2rcdbhrpO0gxWTowwpGkITrwMUY4GOFghMOmEQ5RrS+C23HfhwGjhpcO64bxh3dNi5uRNbmkpfKSC20oWtz81hLMLyqB16XgpQlD0b7arqKydCBwSDZQG2dH4CBwEDhsDBwRXcfvX1mEwu170STLbUQ5mmd7U+5SZE0uKa+4BQU2BC0WFBXjpreWGuqdPbAjrjm2l2V+gsBhgZHaNEsCB4HDMkdiU5s3XS27TCzfr9mJ299dbtR7TEFnXHlUD9NtkJXQLlrIak998sl0LXRdxx/+8zMCW/cg2+PC9IlD0SonyzI/QeCojzU661kCB4HDMkfirKFwaG3tMrGICeD61xdj6ebd8LoVTBs/FO0kHJqVSP/YRYtE6mxV2kzX4svC7fjLnOhrvPGHd8Glw7rXKKUsHQgcVlmq/fIlcBA4CBy1jEtZDlXGsF+yaZcBHeI6Ob8dbjnx4AV8MsqoKw87aWF1W+Pln8lahMIRXDZrATaUlBkLlUV0o0ktC5Vl6UDgiGdxmXOfwEHgIHA4ADhEFas+URSf2okzVnpVbsCUCncka3JJRV2tLiOTtYjdcO6a4T1x9qBOtcopSwcCh9UWa5/8CRwEDgKHQ4Bj7c5SXP7yAmOL6WHdW2LymX1T5klkTS4pq7CFBWWqFqXlIUyYPh/F+6Jb6r940RB469hSX5YOBA4LjdVmWRM4CBwEDocAh6jmo58V4r1lW4waP3JWfwzukpsSlyJrcklJZS0uJFO1eOmHdZj203pDvdtPUjFSbVunkrJ0IHBYbLA2yp7AQeAgcDgIOLbv2Y+JM+ZjfygCf7umePL8gVAU6/czlDW52Mj3JV2VTNRiZ2k5Jkyfh7KKCNS2TfDkBYPgimNXsnQgcCRtio57kMBB4CBwOAg4RFVf+H4tZs4tMmp958l+jPC1sdzxyJpcLK9oCgrIRC3+/uVKvL14s6HelNH9UNC1RVwlZelA4IgrdcYkIHAQOAgcDgOOveJd+7R5KCkLoVNuNl4YV/e7dhneStbkIqMu6c4j07QoKhbHzy+A2Er/sK4t8PDofqYklqUDgcOU3BmRiMBB4CBwOAw4RHXfWLQRT3692qj5tcf2wlkDO1rqkGRNLpZWMkWZZ5oWf5mzAl8W7jDUe2bMIOS1bWpKSVk6EDhMyZ0RiQgcBA4ChwOBoyIcwaUzF2DTrjK0aOzFtAkFte6XIMNTyZpcZNQl3XlkkhaxB7SdoLbFbSeppuWVpQOBw7Tkjk9I4CBwEDgcCByiyp9p2/DAR5pR+/GHdcGlR9S8I6QMLyVrcpFRl3TnkSlaHLSDrUvBi+MLjM9hzV6ydCBwmFVccrq8vLy2LpfrJQDDAWxWFOXaQCAwp6ZifD7fXJfL1UcXVhO9PtY07WzxPz6f7xJFUf4CoCWAN0tLS39XVFS0r4Z8CBwEDgKHQ4FDHOx2TeWZF1luF/49vuCQEz1luShZk4us+qQzn0zR4vPgNtz/YRRYkzmjR5YOBI40WbOqqm8C2ODxeCaFw+GRuq7PKi8v77VmzZrialVyq6q6x+v1dl66dOnO2Hs+n2+woigfu1wu8fwaXddnK4oyPxAI3EngqL1jZQ2eNJmO1GKpRVROJ+jw88YS3PjGEqO+J6htcNtJfqm2UJWZE7SwpOE1ZJoJWpSHIrhk5nxs2b3feCX30vgCNG3kSUhCWToQOBKSXU7ivn37Ng2FQsWRSKRjYWHhNpGrqqrv6Lr+XjAYnBpbSl5eXl+XyzVH07Ru1Uv3+XwPK4rSRNO0a8S9/Pz8oZFI5F1N02paVcYIByMcjHA4NMJRVe17P1iBr1ZGF/3987yB6NuhmRynFJOLrMlFesXSkGEmaPHyvCL8639rDfVuGNELZ/ZPfNGxLB0IHGkw4ry8vCEul0u8FjnwUb2qqn8DkKVp2nWxVfL5fGMVRZkMQGw52AvAN4qiXBMIBDb6fL7/igiHpmlPiGcqQWa31+ttXT0aAoDAQeAgcDgcOMTC0UtnzEdFREef9k0N6JC9GZisySUNrlV6kU7XQmzydfH0+SitCKNHqxzjXB63K/HN42TpQOCQbqK/Zuj3+0/Rdf2DGor4VAQ1YqMWPp/vL4qidNI07fLY9H6//yJd10eHQqGbsrOzd4ZCoccVRckLBAIjVFX9RFGUWYFA4IXKZ1yqqoYjkUjXwsLC6G5Bv14GcBQXV39jY6EAzJoKUAHpCjw8ZwWe/mKlke/fLxyM0YM7Sy+DGWaGAre+8TNe/jG6hfm0y36DY+NsYW51q1u0aIGSkpISAPF3G7O6MpLzTxzjJFcAgDJixAh39WyLiooGulyuDzVNO7CBvYhw6LruCQaDN9RVjfz8/NaRSGR7KBRq4fV6p+u6LvJ5UjxTFeEoLy9vWcNaEEY4KoWVRevyzSX1OVKLqOZO0kFsBjax8uCtdk2z8OJFBcj2HuJmkjYmJ2mRdCNNPuhkLVZu34urXlloHAD4m+4t8WA9DgCUpQMjHCYNT2ayvLy85i6Xa4fX621f9epDrOFQFOX9QCDwdGxZqqpOiEQiWwoLCz8Sf/f7/Z10XV9fXl7epFGjRuLrlEaBQOB6ca9yDcd7mqZ1qKG+BA4CxyFmIcuRyBwf6cjLaTq8t3QzHv08GuW4ZFg3TDi8qzTZnKaFtIbXkJFTtRAfNN7y9lLMX18C8QblX2OHoHurnKSlkqUDgSPpLqjfg36//23xlcr+/ftvzM7OPi4Sibzi8Xjyly1bFt3kvvJSVXUSgCsikciorKys4nA4/IyIhGiaNqYSMOZEIpGT3W53UHylAiCgaZp4pvpF4CBwEDhqGbayHGr9vIL5p8XW1L9/dRHEr9hsj8v48qBN00bmM6gjpdO0kNLoDLGLqmb8b/VO3PHecuOfowd0wHXH9a6XTLJsgsBRr25I/uHevXu3c7vdzwIYIRaEKopyfdU+HH6/3/hSJRAIXAXA7ff7H9J1fQIAgajvl5eXX1X1ykREQADcA0AsQH27tLT0Su7DUXe/yBo8yfe+fZ6kFtG+cKIOC4qKcdNbS436n5TfDn860SfFsJyohZSG15CJE7UoD0dw+awF2FBShiZZbkyfMBS5jb31kkiWDgSOenWDox5mhIMRDkY4MuyX7F3vL8e3q6Lb8zxx3kD0kfCZrKzJxVHeMYPsYtbcIjz/ffQz2KuP6YlzB3eqd1fIsgkCR727wjEZEDgIHASODJpYRFM2FO/D/81aYHwmq7ZtgifOH5TUZ4+xssiaXBzjGeuoqNO02Lp7Py6dOR9loYjxGaw4oM3jdtW7K2TpQOCod1c4JgMCB4GDwJFhwCGa8+L3azFjbvQr+BtG9MaZ/WtaM27eT8maXMyXaN+UTtPivjkr8EXlabB/O6sfhnSR8/WpLB0IHPa1ddk1I3AQOAgcGQgcZRVhXDZrgbF1dbNGHmMBaX3e2cuaXGQ7sHTk5yQtYtf0jPC1wZ0ny9v6XpYOBI50WHF6yiRwEDgIHBkIHKJJ36zcgbs/WGG07vS+7TFpZF7SXkbW5JJ0BWz0oFO0CIUjuPKVhVi7c5/x1ZI43K+tpK+WRHfI0oHAYSPjtrgqBA4CB4EjQ4FD7Ltw6zvL8NO6YogdD584fyDy2yd3zoqsycVif5aS7J2ixesLN+Kpb1Ybmlx+ZHeMHdpFqj6ydCBwSO0WW2dG4CBwEDgyFDhEs9b/sg+Xv7wAoYgOf7umBnS4lMQ3XJY1udjaG5qsnBO02Lm33DgNdm95GJ1zs/GvcUOQJWGhaKxEsnQgcJg0vAxIRuAgcBA4Mhg4RNOe/99azJoXXUA66fjeOL1f4gtIZU0uGeAzpb1KsFKLBz/W8EnAOHQck8/si2HdW0ovTpZNEDikd41tMyRwEDgIHBkOHPvEAtKZ87F1T3nSC0hlTS629YQJVMzuWsxbX4xb/hvd/O2onq1w3+l9Emid+aSydCBwmNfc6SkJHAQOAkeGA4do3leF23HvnIDR0mR2IJU1uTjdYYr621mL/aEwrnh5obGjaLbXhRfHFaBdMznb21fvO1k6EDgyYVSYawOBg8BB4GgAwCEWkN7+7nL8sPYXo7VTRvdDQVfz+zHImlzMuSV7p7KzFrH7r8jaUbS23pClA4HD3vYus3YEDgIHgaMBAIdo4pZdZbjs5QUoq4igk1hIOHYwGnnMHWEva3KR6bzSlZddtVizsxS/m73QWCDsa9sET0rYYbYujWXpQOBIlyWnvlwCB4GDwNFAgEM0M/ZTyXFDu+D/juxuyuvImlxMFWbzRHbUIqLruPGNJViyaZdx9LyADbVdU0uVlKUDgcPSbrJV5gQOAgeBowEBhzjC/trXfkZg6x7jfJWpFwxCrzZN4jolWZNL3IIckMCOWry/bAse+azQUO+cQR3xh+G9LFdSlg4EDsu7yjYFEDgIHASOBgQcoqnBbXtw9auLENGBPu2b4u/nDox7uJusycU2nq8eFbGbFmLPDbGN/e79IbRtmoUXxg1BTpanHi0096gsHQgc5vTOhFQEDgIHgaOBAYdo7jPfrsGrCzYYLb/22F44a2DHOv2ZrMklE5ymnbQQi4HF9vXfrtppSHvvafk4plfrlMgsSwcCR0q6yxaFEDgIHASOBggcYm+OK15egE279qOx14V/jR2CDs2za3VKsiYXW3i9elbCTlp8pm3DAx9pRotG5LXGnafk17N15h+XpQOBw7zmTk9J4CBwEDgaIHCIJs9dV4w/vR3dIGpIl1z8dXS/Wrc9lzW5ON1hivrbRYtfSqOvUnaVhZCb7cELFxWgRWNvyiSWpQOBI2VdlvaCCBwEDgJHAwUO0exHPy/Ee0u3GApcd1wvjB5Q86sVWZNL2j2ehArYRYu/zFmBLwt3GC0Sx86L4+dTecnSgcCRyl5Lb1kEDgIHgaMBA0dpeQiXv7wQW3bvN44wf27sEGOPjuqXrMklve5OTul20OLLwu34S+XOscN7t8bdp/ihJHEoX30UkaUDgaM+veCsZwkcBA5OLg0YOETT568vxs2VZ28M7NQcj5zd/5BXK7ImF2e5x5prm24tSvZVGK9SivdVoHm2B8+PG4JWOVkpl1aWDgSOlHdd2gokcBA4CBwNHDhE8//+5Uq8vXizocQfhvfEOYM6HaSKrMklbZ5OYsHp1EJ8lXLvBwF8vSr6KuX2k1SMVNtKbJ35rGTpQOAwr7nTUxI4CBwEDgIH9pWHccXs6FcrjTwuPDNmMLq2bHxAGVmTi9Mdpqh/OrWYs2wLplRu8DW8V2vcfWrqX6VU9aEsHQgcmTAqzLWBwEHgIHAQOAwFFm0owaQ3lxj/r7Ztgn+cNxBet8v4t6zJxZxbsneqdGmxsWQfrpy9EPsqImid4zXW2+Sm8KuU6r0iSwcCh73tXWbtCBwEDgIHgeOAAlO/WY3/LNxo/PvCgs644qgeBI5q9iFrok3EkYst6W94YzGWbd5tPPbQmX1xePeWiWQhPa0sHQgc0rvGXIZ5eXltXS7XSwCGA9isKMq1gUBgTvWn/X7/VF3Xx8f8XRz5KJaWd9E0bYPP55vrcrn66OKFX/T6WNO0s2uoBYGDwEHgIHAcUKA8HDHOWinctheKOMb+rH4Y0qUFIxwxNiJrojU3K0RTTftxHV76cb3x/2cP7IhrjrX+rJR49ZOlA4EjntIW3VdV9U0AGzwez6RwODxS1/VZ5eXlvdasWVNcV5Gqqr6uKMrKQCBwCwC3qqp7vF5v56VLl0b3u639InAQOAgcBI6DFFj3SymuemUR9ociaN0kC89dOBgFvrZYWVSnG7LIK9ovW1kTrdmWLd+8G9e9/rNx9k33Vo3x9AWD0MgjfmOm95KlA4EjDf3Yt2/fpqFQqDgSiXQsLCzcJqqgquo7uq6/FwwGp9ZWJVVVLwRwV7NmzQbNmzevIi8vr6/L5ZqjaVo3E80gcBA4CBwEjkMUeG/pZjz6+Urj78f0aoXpVxyBVRtKTLiUzE8ia6I1o9TushCuemUhNu/eD49LwZPnD0ReW2uPnTdTL5FGlg4EDrOKS0yXl5c3xOVyiVcfB7aLU1X1bwCyNE27rqaiRowY4dm0aZPwCr+revXi8/nGKooyGYDYPlDE3b5RFOWaQCAQfTF78EXgIHAQOAgchygg3sbe88EKfFN5KNh9Z/XHUV1yJXo852Yla6KNp4Dog7veX4HvVkcD1Vcd3QPnD+kc77GU3ZelA4HDwi7z+/2n6Lr+QQ1FfCqCGrGRCZ/P9xdFUTppmnZ5TVXy+XzjFEW5SdO0gqr7fr//Il3XR4dCoZuys7N3hkKhxxVFyQsEAiNqA47iYoZKLexyZk0FHKnAL3vLcerfv8bmXWXIcrvw2u+PxMAuLRzZFidW+vlvVuO+d5cZVT+xT3s8N3FoyncTTYVuLVq0QElJiQifZZxxiXVQ6b6UESNGHPICrqioaKDL5fpQ07QDu7iICIeu655gMHhDTZVWVVWAy7uapj1ZW6Py8/NbRyKR7aFQqMWqVauqx0QZ4WCEgxEORjhq9YmLN+7CpDcXG+sH2jdrhKljBqF5duoOCEu3s66pfFm/7Otq24otu3H964sRiuiG7mJflGbZHlvJIUsHRjjS0K15eXnNXS7XDq/X275qsadYw6EoyvuBQODp6lXq0aNHdlZWVonb7e6xfPnyTVX3VVWdEIlEthQWFn4k/ub3+zvpur6+vLy8yZo1a8qq5UPgIHAQOAgcdXq8/yzYgKnfrjHSDOveEvef0afWU2XT4DpTXqSsiba2iot1G797JXq+jVi38fdzByC/fbOUtzNegbJ0IHDEU9qi+36//23xlcr+/ftvzM7OPi4Sibzi8Xjyly1bFt1zOOby+XzDXC7Xq4FAoHvs31VVnQTgikgkMiorK6s4HA4/I6IkmqaNqaHaBA4CB4GDwFGnRxNrCf72xSrMWRp1Q5cO64bxh3e1yAvaP1tZE21NLRX7bdz+7jL8tC76mvvqY3ri3MEHbzNvF4Vk6UDgSFOP9u7du53b7X4WgFhvsUVRlOurFoOKvTdEtQKBwFXiv36//wJd1ydpmnZEteq6/X7/Q7quTwCQA+D98vLyq2r5tJbAQeAgcBA44nq8tm2a4NTHvsKGkjJjf46HftsPh3XLuFfucXUQCWRNtDUV9tx3azB7/gbjVrq3Lo8nhiwdCBzxlM6c+wQOAgeBg8AR16OJyeWjhRuMTcHE/hxNG7nx5PmD0KXFr+etxM0kQxLImmiry/F5cBvu/1Az/tyjVQ7+ed4A5GTZa91GbJ1l6UDgyJCBYaIZBA4CB4GDwBHXVVRNLp8GtmHyx9FJsWuLxnji/IFo2si+k2LchiWRQNZEG1t04bY9uO71xQdg7qnzB6GzzWFOlg4EjiSM0KGPEDgIHAQOAkdc9xU7uTz/v7WYNa/IeObwbi3wwBl94XbZ4QPAuM2QkkDWRFtVmV9Ky/GH//xsLBIVMk4+I/3npJgRSpYOBA4zamdGGgIHgYPAQeCI681iJ5dI5aZg31ZuCnbuoI64enj6z/aI2whJCWRNtKI6ZRVh/PGtJVixZY9RuyuP6o4xBV0k1dTabGTpQOCwtp/slDuBg8BB4CBwxPVJ1SeXfeVh43yPVTtKjWevPbYXzhrYMW4+mZBA1kQrvki5d84KVIHbSfntcMsJeY7Z3EuWDgSOTBgV5tpA4CBwEDgIHHG9RU2Ty5ZdZbj6Pz+jeF+F8eXKnaf4cVzegZMZ4ubp1ASyJtonv16FNxZFt1Aa0iUXD57ZF163yzGyyNKBwOGYLq93RQkcBA4CB4EjriOpbXLRtu7BjW8uRllFBF6XYnwuOzjDz1yRMdG+vnAjnvpmtaF7z1Y5ePzcAY5bfCtDBwO2+nXH7l27uLV53FHo/AQEDgIHgYPAEdeT1TW5zF33C257dznEK4ImWW48ds4A9G7TJG6eTk1Q34l2zrItmPJZodH81jlePHH+ILRr1shxctRXh6oGEzgc1/VJV5jAQeAgcBA44jqQeJPLx4GteOjjoJFPqxwvHj17ALq2zMw9OuJpUZeYXxZux/0fBoyzaQScPXp2f9scNx/XCKolqI8OsVkROBJV3rnpCRwEDgIHgSOuBzMzubw6fwOe+S565kqbJll47Jz+6JSbedBhRouaBP1hzU7c+f4KIxKU7XXhr7/th34dm8fV3q4JktWhensIHHbtYfn1InAQOAgcBI64nsXs5PLvH9Zh+k/rjfzaNc3Co+cMQMfm2XHzd1ICs1rEtkm8drrzvRUoD0fXukw+sy8Kujp7a/hkdKipnwkcTrL++tWVwEHgIHAQOOJ6EbOTizjo7fnv1+Hlyo3BOjRrhEfO7o8OGQQdZrWoEvV/q3fi3g9WoCKiGxt73XtaPo7q2Tqu5nZPkKgOtbWHwGH3npZXPwIHgYPAQeCI61ESmVwEdDz73Vq8uiB6CJl4vfLw6H7G+SCZcCWixVdizcZHmvEaRRw1f8fJfgzv7XzYEP2YiA519TuBIxNGhbk2EDgIHAQOAkdcb5Ho5BKFjjV4dcFGI+/m2R5jn4n89s3ilmX3BGa1+GjFVkz5NGgsEPW6Fdxzaj6O6NHK7s0zXT+zOsTLkMART6HMuU/gIHAQOAgccT1aMpOLgA5x5soL368z8hcLJf9yWh8MzfC1C6LdM+cW4cUfou1u5Im2+7Buzl6zUd1IkrGJmgyNwBF3+GVMAgIHgYPAQeCI69DqM7m8s2QT/v7FKuiAccjb9cf1wun9OsQt064J6tIiFI7g71+uwvvLthjVb9rIjftO74OBnXLt2pyk61Ufm4gtlMCRdBc47kECB4GDwEHgiOu46ju5fB7choc/DhoLJ8UlDnz73dE9HXnKbG1alOyrwP0fBTB/vdg0E2jfrJHxGql7hqxdYYQj7jA5JEHDOUPZnDYEDgIHgYPAEddb1Bc4RAFLN+3CXe+vMM5eEZc42v7WUSpyG3vjlm+nBDVpIbZ4v+eDFcYR8+LytW1iHDPfqkmWnaoutS4ybEJUiBEOqd1i68wIHAQOAgeBI66TkjW5iAPf7nhv+YFTZts2zcLtJ/kxoJNzNsCK1UKs15izfCv+/uVKVISj0ZsRea1x00gfGme54+rq5ASybILA4WQrSKzuBA4CB4GDwBHXa8iaXERB4mj7v34axFcrdxjlir0pLhnWDRcWdHHEK5YqLcQrlMc+X4mvV/3ajiuO6oHzB3dyzBHzcTu+jgSybILAUZ9ecNazBA4CB4GDwBHXa8maXKoKEpGBt5dsxtNfrz6wriO/fVPcPNKHHq3tvV+H0GLWt6vxyKdB7CiNvh5qmePF7SepGNIls75EqcswZNkEgSPu8MuYBAQOAgeBg8AR16HJmlyqF1S4bQ/u+zCAouIy45bY9nv84V1xQUFnZLldceuV6gTb9+zHtPkb8N7Pmw4UfXSvVph0fB5aOGwtSn21k2UTBI769oRznidwEDgIHASOuB5L1uRSU0FlFWGIM1heX7TR2CRLXOL8lSuP6m7syqko6V/rXx6K4K3FmzD9x/UorQgbdWzsdeEPw3vhlD7tbFHHuJ0oOYEsmyBwSO4YG2dH4CBwEDgIHHFdlKzJpa6CVmzZjSmfFmLNztIDyfp3bI6Lf9MVQ7r8f3t3HxzFWccB/Pc8l0togFLAgkSCCbl99pJpaZ0oFFttRkXajlq1OqNVO/hPoa2lLe3UN+p0HGytOmNRazvVsaUqMg4WZdCqrWO0OiJTmFIMuX12KRlMQoGibSjXcFyex/mFS8iEvKybC8llvzvD8Mc+z7589rnN93af57lZE/JHnack5xlDn9p1iI6+kes/rqtTc+mWq2rp4hkVo9pN1QLFahMIHFO1hZx7XggcCBwIHAgco97xivXHZbQd8cRZO1qO0KZdh6irO99fvH7+DPpU40JaXjPnvHQsPZnL0zP7j9DTew/3D3Xlg1l40TTa8LFLqXoKD3cd7Rr1rS9Wm0DgCCs+TuWUUkuJ6Odaa2e4XTiOs0oI8XXur0RE27LZ7Or29vY3ufxI6wZtD4EDgQOBA4Fj1DtZsf64jLqjQoET3XnavPvftH3fK9SdN/3V5k4v732FsTI9j9520QVhNxeqnLGW9nV20XPeMWr2X+1/dcKVefjuTUsX9e5XLZpNB9pfC7XNqVyoWG0CgWMCW4njODcKIX5ARF1a65qhDsVxnMuFEM9KKd9nrW2z1m4RQuzxPO++kdYNsS0EDgQOBA4EjlHveMX64zLqjgZ/I3rzNG3b20nbXjpMJ3Nn+k70Lfzrs8tr51Bj9SxKz5sZad4LHtq6t+N1euHQa7Tr0H/p2IDXJrwffqJxw2VVtLJ+HlWUnZlXY6Is/l+78S5fLAcEjvG+UsNs33Gc1UKItUKITdbaW0cIHA8JIaZrrb/Am0qn043GmB1a6wWO4wy7DoFj+AtbrA/PBDWdou4WFmc44XC2WU20RTaXp+bgOP2u5RVqPfLGOe2d5/LgALJoTiVVXTitd1rxGRVlVFme6J3nI9djiTt+Hs/miEeadLzeTf6xk3S0MDPowA3y770se/tsuq5hPi2rmU1yUKfVibYo6od9DBsrlgMCxxguwliq1tbWzj948OCxdDr9XmPMkyMEjt/wEw6tNT8JoYaGhhn5fP5EMpmcAONMgwAACHNJREFUm8vlnhhuXUtLy38GHR8/qxQzLyydWf7G4jtSXb6p8CNVLDwREyy4HcDh7KdhMlkYQ8SdOfPGUGFyzzF/bHkcDAcN/lcmBY00MGYyWYz5xMewgWI5nOjq4qPgm+/kGwc9Bh+uOuHjq1zXvcZa+8wQ57FJa72q8MSiaaTAoZR6Tgix2fO8nxS2I5VSPcaYainlk8OtC4KgfdB+uVcWX+TeK44FAhCAAAQgcJ4F+Bsvf/ktO8/7HffdTXjg4NDT1NR0ziT7zc3NDN7bOyqdTo8YOFzX3W6t/YPW+pGBTzhyudzsioqKp4Zb19bWhp5O497EsAMIQAACEIDAJHjCEeYihAgc3yKiCs/z7igEFO7D8Vut9Vtd1x12XZh9owwEIAABCEAAAmMXmAxPOEY9i9ECR6GT6O+NMSsTiYTPo1SIyNNarxtp3ag7RgEIQAACEIAABIoiULKBw3Xdx1jA87w1/L9S6nNEdD8RvYWItmez2Zv75uEYaR3XdRxnmRDiMSGEstbuMcasCoLgQFGES3QjSql1RLSkrx9NiZ7GmA7bdd3rrbUPEFG1tVZLKe/wPO/vY9poCVZ2HOcGIcQ3eFQkEbUaY9YGQfCPEjyVoh1yKpVqkFLukVKmM5lMW9E2XEIbUkp9h4h4ZGDfjGTdWmu+/8ZqSaVSdVLKx4loGRF1ENGdWuuh+iXGymWoky2JwDGeV6mmpmZaeXn5y9bae5LJ5NZ8Pv8lIlqhtX7PeO53sm47lUpVJBKJ9dbarxDRT+MaOFzXrbXWvmiM+UgQBM+7rvtpa+33hBA1nuedmKzXr9jHlU6na4wx/7LWvt/3/X86jvN5nmBPa11d7H2VyvaamprKOjs7OXgulVLWxjhwPEtEP9RabyuVazcOxykdx9lLRFt8338wnU6vMMZsLSsrW7B///5zxyuPwwGU0iZjHziUUtcS0be11pcULlxCKfUqES3XWmdK6WIW41iVUr8goplCiHZr7bS4Bo5UKnW1lPLDWut7+lyVUsellB/MZDK7i2FdKtvgYeZ881y8ePGsRCJxsxDiM1rry0vl+It9nK7r3met5d9dXxfzwHHUWnuF7/svF9u4VLbnuu6V1loeUcmzYPfOI8CTTZ4+fTrT1tZ25id/sfQLIHAodZcQ4krP8z7Rp+I4zgtE9IDv+0/Hra3U19cvaG1tPayU4tdTNXENHIOveyqVukJK+WdjzPwgCGI3bDqdTl9qjHmRH59baz/k+z5/u43dopS6jH9mIZvNvquysjIb18DB94menh7+UrJDCPFuIjpgjLkzCIKdcWoUSqnbhBArjTHtQgj+G8JTLazVWv8tTg5hzzX2gcNxnPXcd0NrfdOAb7J/FUI87nnez8JCTrVyCBxnr2hdXV0qkUj8xVr7Xd/3+b117JbGxsYkn3RXV9dnhRAbjTF1QRAcixNEQ0NDeT6f3ymEuJ378iilbFwDRyGAPmyMWV9eXr47n8/z/fObUko3k8kcj0u7KPz9uN9ae1symXwin89/nIgeSSaTzhATS8aFZdjzjH3g4M6R1trlvu9/cuATDiHEBq31r+PaQhA4zlz5wg8H7ii8q+anPrFfHMfZxx20fd//VZwwXNfdYK2t5NFvhbYR28Ax1HXndiGl/Krnedvj0i5c173XWrtaa1034AvrS9wHzvd9vm9gGSCAwKHUdUT0oNaaH5Xywn04jhdCSGtcWwsCR++Ec/yo9JdEdLfW+sdxbAuO43xACPFFrfWKATdUj4j4t43+FCcTpRT36VrQ966eiGYR0Qlr7Rrf9zfHyYL7LvAoNs/zHh3YLowxtwdB8Me4WCilPkpEP9JaXzzAoUUI8eU4Ba+w1zv2gWPhwoUXVFZWHiSie8vKyrbwKBUhxPWe5zWGRZyK5eIeOOrr652enp491tpVcfsmP7A9K6V4mKPmgFFVVbW1s7OTh6Hflc1mL+kbdj4V23+Yc4rzKxXXdd9prW0momuqqqp2dnR03CqlvPvUqVNunDpLLlmyZHp3dzdPobBRa/2Q67o3Wms3xm00W5jPC5eJfeBghMLkYDyvR5qIeCgk5uGIeafRwhwD/Og8O+jDdK3W+vmwH7CpUE4pdRURfZ+IaolojxDiFs/z+ClHrJc4Bw6+8Eop7rfxNSHEAh5CLqVck8lk+HVbrBbHceqllI9aa99hrT0khOCnf7G6R4S94AgcYaVQDgIQgAAEIACByAIIHJHpUBECEIAABCAAgbACCBxhpVAOAhCAAAQgAIHIAggckelQEQIQgAAEIACBsAIIHGGlUA4CEIAABCAAgcgCCByR6VARAhCAAAQgAIGwAggcYaVQDgIQgAAEIACByAIIHJHpUBECEIAABCAAgbACCBxhpVAOAhCAAAQgAIHIAggckelQEQIQgAAEIACBsAIIHGGlUA4CEIAABCAAgcgCCByR6VARAhCAAAQgAIGwAggcYaVQDgIQgAAEIACByAIIHJHpUBECEIAABCAAgbACCBxhpVAOAhCAAAQgAIHIAggckelQEQIQgAAEIACBsAIIHGGlUA4CEIAABCAAgcgCCByR6VARAhCAAAQgAIGwAggcYaVQDgIQgAAEIACByAIIHJHpUBECEIAABCAAgbACCBxhpVAOAhCAAAQgAIHIAggckelQEQIQgAAEIACBsAIIHGGlUA4CEIAABCAAgcgCCByR6VARAhCAAAQgAIGwAggcYaVQDgIQgAAEIACByAIIHJHpUBECEIAABCAAgbACCBxhpVAOAhCAAAQgAIHIAggckelQEQIQgAAEIACBsAIIHGGlUA4CEIAABCAAgcgCCByR6VARAhCAAAQgAIGwAggcYaVQDgIQgAAEIACByAIIHJHpUBECEIAABCAAgbAC/wNel7KTdUUYTAAAAABJRU5ErkJggg==" width="432" /></p>

<h2 id="mio-test-di-animazione">Mio test di animazione</h2>
<p>vorrei fare estendere la funzione seno, in modo che ad ogni frame sia moltiplicata per una diversa ampiezza.
Attenzione: ho provato a farlo girare molte volte e non andava. Ho resettato il kernel e ora sembra fungere.
Mi viene il dubbio che il problema fosse connesso a qualche cella che avevo lasciato attiva.</p>

<ul>
  <li>Curiosamente se metto i limiti degli assi il grafico non appare! <strong>Errore</strong> Ax e’ un array di assi!</li>
  <li><code class="language-plaintext highlighter-rouge">interval=1</code>  rallenta l’esecuzione del programma</li>
  <li>frames sono tutti i vari prarametri che andranno a definire i frame</li>
</ul>

<p>possiamo ingrandire o diminuire la dimensione dei limiti:
https://stackoverflow.com/questions/53423868/matplotlib-animation-how-to-dynamically-extend-x-limits</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TWOPI</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="c1">#fig, ax = plt.subplots()                    # costruiamo una figura e un array di assi
</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">autoscale_on</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">xlim</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">6.29</span><span class="p">),</span> <span class="n">ylim</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>


<span class="c1">#ax = plt.axis([0,TWOPI,-1,1])              # ATTENTO assi QUESTO BLOCCA set_xlim
#ax.set_xlim([0,TWOPI])                     # ERRORE ax non e' un asse ma una tupla di assi!  
#ax.set_ylim([-1,1])                        # ERRORE    
</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">TWOPI</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">)</span>            <span class="c1"># t =array di posizioni 
</span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>  
<span class="c1"># y = sin(t) 
</span><span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>

<span class="n">new</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>                        <span class="c1"># bisettrice
</span><span class="n">second</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">s</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="n">curva</span><span class="p">,</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>                     <span class="c1"># grafico  
#ax = plt.axes(xlim=(0, 10), ylim=(-1, 1))
</span>

<span class="k">def</span> <span class="nf">animate</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>                             <span class="c1"># questa funzione modifica i parametri del punto rosso
</span> <span class="n">curva</span><span class="o">.</span><span class="n">set_ydata</span><span class="p">(</span><span class="n">A</span> <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>              <span class="c1"># quindi il resto del grafico resta invariato!  
</span> <span class="c1">#print(A*np.sin(t))
</span> <span class="k">return</span> <span class="n">curva</span><span class="p">,</span>

<span class="n">frames1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">0.001</span><span class="p">)</span>
<span class="n">frames2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="o">-</span><span class="mf">0.001</span><span class="p">)</span>
<span class="n">frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">frames1</span><span class="p">,</span> <span class="n">frames2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>

<span class="c1"># create animation using the animate() function
#myAnimation = animation.FuncAnimation(fig, animate, frames = np.arange(0.0, 1.0, 0.001), \
# interval=10, blit=True, repeat=True)
</span>
<span class="n">myAnimation</span> <span class="o">=</span> <span class="n">animation</span><span class="o">.</span><span class="n">FuncAnimation</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">animate</span><span class="p">,</span> <span class="n">frames</span> <span class="o">=</span> <span class="n">frames</span><span class="p">,</span> \
 <span class="n">interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">blit</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;IPython.core.display.Javascript object&gt;
</code></pre></div></div>

<p><img src="data:," width="0" /></p>

<h2 id="slider-interattivo">Slider interattivo</h2>
<p>possiamo modificare la figura tramite uno slider interattivo!
In questo caso non uso la funzione animate, perche’ la modifica viene fatta in base a cosa tocco sullo slider.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">matplotlib.widgets</span> <span class="kn">import</span> <span class="n">Slider</span>
<span class="n">TWOPI</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>

<span class="n">A0</span> <span class="o">=</span> <span class="mf">.5</span>                                       <span class="c1"># valore iniziale ampiezza 
</span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">TWOPI</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">)</span>              <span class="c1"># x del grafico 
</span><span class="n">s</span> <span class="o">=</span> <span class="n">A0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>                              <span class="c1"># y del grafico  (iniziale)
</span>
<span class="n">l</span><span class="p">,</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>                     <span class="c1"># grafico (da capire la virgola)
</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="n">TWOPI</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>                 <span class="c1"># assi (che non verranno toccate) ??? 
</span><span class="n">axamp</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">axes</span><span class="p">([</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">.03</span><span class="p">,</span> <span class="mf">0.50</span><span class="p">,</span> <span class="mf">0.02</span><span class="p">])</span>     <span class="c1"># non chiaro axIs e axEs
</span>
<span class="c1"># Slider
</span><span class="n">samp</span> <span class="o">=</span> <span class="n">Slider</span><span class="p">(</span><span class="n">axamp</span><span class="p">,</span> <span class="s">'Amp'</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">valinit</span><span class="o">=</span><span class="n">A0</span><span class="p">)</span> <span class="c1"># SLIDER interattivo, si chiama  "samp"
</span>
<span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
 <span class="c1"># amp is the current value of the slider
</span> <span class="n">amp</span> <span class="o">=</span> <span class="n">samp</span><span class="o">.</span><span class="n">val</span>                               <span class="c1"># valore corrente dello slider
</span> <span class="c1"># update curve
</span> <span class="n">l</span><span class="o">.</span><span class="n">set_ydata</span><span class="p">(</span><span class="n">amp</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>                   <span class="c1"># fai update delle y della curva  
</span> <span class="c1"># redraw canvas while idle
</span> <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw_idle</span><span class="p">()</span>                       

<span class="n">samp</span><span class="o">.</span><span class="n">on_changed</span><span class="p">(</span><span class="n">update</span><span class="p">)</span>                       <span class="c1"># ridisegna la figura se muoviamo lo slider
</span>
<span class="c1">#plt.show()
</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;IPython.core.display.Javascript object&gt;
</code></pre></div></div>

<p><img src="data:image/png;base64,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" width="432" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0
</code></pre></div></div>

<h1 id="foto">Foto</h1>
<p>Vediamo come mostrare una immagine. Si passa un array 2D e questo viene convertito automaticamente, assegnando ai valori un colore. Per esempio:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">immagine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                      <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                      <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                      <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                      <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                      <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>

<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">immagine</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;matplotlib.image.AxesImage at 0x2de6a38e640&gt;
</code></pre></div></div>

<p><img src="/images/posts/Matplotlib_images/Matplotlib_PA_103_1.png" alt="png" /></p>

<h1 id="unpacking">Unpacking</h1>
<p>questo non e’ strettamente connesso con matplotlib….</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="n">first</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">numbers</span>       <span class="c1"># multiple assignment
</span><span class="k">print</span><span class="p">(</span><span class="n">rest</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">first</span><span class="p">)</span>

<span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[2, 3, 4, 5, 6]
1
</code></pre></div></div>

<h1 id="enumerate">enumerate()</h1>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">o</span><span class="p">,</span><span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>                <span class="c1"># stampa l'ordine degli oggetti
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0
1
2
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>                <span class="c1"># stampa le chiavi del dizionario
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a
b
c
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">o</span><span class="p">])</span>              <span class="c1"># stampa i valori del dizionario
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>5
2
4
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>              <span class="c1"># stampa le NUOVE coppie chiave-chiave vecchia costruite da enumerate()
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(0, 'a')
(1, 'b')
(2, 'c')
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

      </div>
    </div>

    <div class="tag-list">
      
      
      
      <a class="tag-chip" href="/tags#grafici_cap"><div class="chip z-depth-1">Grafici</div></a>
      
      
      
      <a class="tag-chip" href="/tags#python_cap"><div class="chip z-depth-1">Python</div></a>
      
    </div>
    
          <style type="text/css">
.related-posts{
  border: 3px dotted #2e87e7;
  border-radius: 5px;
  margin: 20px 0;
  padding: 10px 10px 0 10px;
}
.related-posts span{
  font-size: 130%;
  font-weight: 500;
  color: #2e87e7;
}
.related-posts ul{
  margin-top: 5px!important;
}
.thi-icon{
  float: left;
  line-height: inherit;
  margin-right: 5px;
  margin-left: 2px;
  color: #2e87e7;
}
</style>

<div class="related-posts">
  <i class="material-icons thi-icon">grade</i><span>You might also like ...</span>
  
  <ul>
    
    
      
      
        
      
        
      
        
      
        
      
    
      
      
        
          <li>
            <a href="/Pytorch-1">
              Pytorch 1 Inizio, Tensori
            </a>
            <small>12 Nov 2021</small>
          </li>
          
          
    
      
      
        
          <li>
            <a href="/Seaborn">
              Seaborn - appunti
            </a>
            <small>08 Nov 2021</small>
          </li>
          
          
    
      
      
        
          <li>
            <a href="/Pytorch-7">
              Pytorch 7 Recurrent Neural Network
            </a>
            <small>17 Oct 2021</small>
          </li>
          
          
    
      
      
        
          <li>
            <a href="/Pytorch-9">
              Pytorch 9 Autoencoder
            </a>
            <small>15 Oct 2021</small>
          </li>
          
          
    
      
        

    
    
  </ul>
</div>

    
    		
			<script src="  https://unpkg.com/showdown/dist/showdown.min.js"></script>
<script>
const GH_API_URL = 'https://api.github.com/repos/4phycs/4phycs.github.io/issues/25/comments';

let request = new XMLHttpRequest();
request.open( 'GET', GH_API_URL, true );
request.onload = function() {
	if ( this.status >= 200 && this.status < 400 ) {
		let response = JSON.parse( this.response );

		for ( var i = 0; i < response.length; i++ ) {
			document.getElementById( 'gh-comments-list' ).appendChild( createCommentEl( response[ i ] ) );
		}

		if ( 0 === response.length ) {
			document.getElementById( 'no-comments-found' ).style.display = 'block';
		}
	} else {
		console.error( this );
	}
};

function createCommentEl( response ) {
	let user = document.createElement( 'a' );
	user.setAttribute( 'href', response.user.url.replace( 'api.github.com/users', 'github.com' ) );
	user.classList.add( 'user' );

	let userAvatar = document.createElement( 'img' );
	userAvatar.classList.add( 'avatar' );
	userAvatar.setAttribute( 'src', response.user.avatar_url );

	user.appendChild( userAvatar );

	let commentLink = document.createElement( 'a' );
	commentLink.setAttribute( 'href', response.html_url );
	commentLink.classList.add( 'comment-url' );
	commentLink.innerHTML = '#' + response.id + ' - ' + response.created_at;

	let commentContents = document.createElement( 'div' );
	commentContents.classList.add( 'comment-content' );
	commentContents.innerHTML = response.body;
	// Progressive enhancement.
	if ( window.showdown ) {
		let converter = new showdown.Converter();
		commentContents.innerHTML = converter.makeHtml( response.body );
	}

	let comment = document.createElement( 'li' );
	comment.setAttribute( 'data-created', response.created_at );
	comment.setAttribute( 'data-author-avatar', response.user.avatar_url );
	comment.setAttribute( 'data-user-url', response.user.url );

	comment.appendChild( user );
	comment.appendChild( commentContents );
	comment.appendChild( commentLink );

	return comment;
}
request.send();
</script>

<hr>

<div class="github-comments">
	<h2>Comments</h2>
	<ul id="gh-comments-list"></ul>
	<div class="buttonArea">
	  <a target="_blank" href="https://github.com/4phycs/4phycs.github.io/issues/25"class="button">Add comment (via Github)</a>
	</div>
</div>


		
 
  </div>
</main>

	<script src="/assets/js/jquery-1.11.0.min.js"></script>
<script type="text/javascript">
  jQuery(document).ready(function($){
    // browser window scroll (in pixels) after which the "back to top" link is shown
    var offset = 300,
      //browser window scroll (in pixels) after which the "back to top" link opacity is reduced
      offset_opacity = 1200,
      //duration of the top scrolling animation (in ms)
      scroll_top_duration = 700,
      //grab the "back to top" link
      $back_to_top = $('.cd-top');

    //hide or show the "back to top" link
    $(window).scroll(function(){
      ( $(this).scrollTop() > offset ) ? $back_to_top.addClass('cd-is-visible') : $back_to_top.removeClass('cd-is-visible cd-fade-out');
      // if( $(this).scrollTop() > offset_opacity ) { 
      //  $back_to_top.addClass('cd-fade-out');
      // }
    });

    //smooth scroll to top
    $back_to_top.on('click', function(event){
      event.preventDefault();
      $('body,html').animate({
        scrollTop: 0 ,
        }, scroll_top_duration
      );
    });

  });
</script>
<style type="text/css">
.cd-top {
  display: inline-block;
  height: 50px;
  width: 50px;
  position: fixed;
  bottom: 2%;
  right: 2%;
  border-radius: 40px;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.05);
  /* image replacement properties */
  overflow: hidden;
  text-indent: 100%;
  white-space: nowrap;
  background: #bbb url(/images/cd-top-arrow.svg) no-repeat center 50%;
  visibility: hidden;
  opacity: 0;
  -webkit-transition: opacity .3s 0s, visibility 0s .3s;
  -moz-transition: opacity .3s 0s, visibility 0s .3s;
  transition: opacity .3s 0s, visibility 0s .3s;
}
.cd-top.cd-is-visible, .cd-top.cd-fade-out, .no-touch .cd-top:hover {
  -webkit-transition: opacity .3s 0s, visibility 0s 0s;
  -moz-transition: opacity .3s 0s, visibility 0s 0s;
  transition: opacity .3s 0s, visibility 0s 0s;
}
.cd-top.cd-is-visible {
  /* the button becomes visible */
  visibility: visible;
  opacity: 1;
}
.cd-top.cd-fade-out {
  /* if the user keeps scrolling down, the button is out of focus and becomes less visible */
  opacity: .5;
}
.no-touch .cd-top:hover {
  background-color: #e86256;
  opacity: 1;
}
</style>

<a href="#0" class="cd-top">Top</a>
	<footer class="page-footer light-blue accent-4">  
  <div class="footer-copyright">
    <div class="container text-white">
     <a href="">4Phycs</a> &#xA9; 2022 Inherited from <a href="https://shawnteoh.github.io/matjek/">MatJeck</a>.
    </div>
  </div>
</footer>

<script src="//code.jquery.com/jquery-2.2.4.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/materialize/0.99.0/js/materialize.min.js"></script>


  
    <script src="/assets/js/post.js"></script>
  





<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})
  (window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', '', 'auto');
  ga('send', 'pageview');
</script>

<script src="/assets/js/main.js"></script>

        <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-158698892-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-158698892-1');
</script>

</body>
</html>
