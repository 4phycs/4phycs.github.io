<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <link href="https://fonts.googleapis.com/css?family=Maven+Pro:400,500&amp;subset=latin-ext,vietnamese" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Dancing+Script:400,700&amp;subset=vietnamese" rel="stylesheet">
  <meta name="google-site-verification" content="8zqeFQNuNAWS7ye6oN69hdEeYC_RsDyAlhht79xtAQo" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta property="og:image" content="/assets/res/banner.png" />

  

  <title>
    
      Search on this page | 4Phycs
    
  </title>

  

  <!-- page's cover -->
  
    <meta property="og:image" content="http://localhost:4000/images/defaultCoverPost.png" />
    <meta property="og:image:type" content="image/png">
    <meta property="og:image:width" content="1234">
    <meta property="og:image:height" content="592">
  

  

  <link rel="shortcut icon" type="image/x-icon" href="/assets/res/favicon.png">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/materialize/0.99.0/css/materialize.min.css">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="/assets/css/main.css">

  <link rel="stylesheet" href="/assets/css/thi_scss.css">

  
    
      <link rel="stylesheet" href="/assets/css/page.css">
    
  

  
    
      <link rel="stylesheet" href="/assets/css/page.css">
    
  
    
      <link rel="stylesheet" href="/assets/css/search.css">
    
  

  <link rel="stylesheet" href="/assets/css/syntax.css">
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml">
  <link rel="sitemap" type="application/xml" title="Sitemap" href="/sitemap.xml">
  
  <!-- Begin Jekyll SEO tag v2.6.1 -->
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Search on this page" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="my ideas and notes, and useful stuff." />
<meta property="og:description" content="my ideas and notes, and useful stuff." />
<link rel="canonical" href="http://localhost:4000/search" />
<meta property="og:url" content="http://localhost:4000/search" />
<meta property="og:site_name" content="4Phycs" />
<meta name="google-site-verification" content="" />
<script type="application/ld+json">
{"description":"my ideas and notes, and useful stuff.","@type":"WebPage","url":"http://localhost:4000/search","headline":"Search on this page","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body>
	<header>
	
		<nav class="top-nav light-blue darken-4">
  <div class="nav-wrapper">
    <div class="container">
      <a class="page-title font-title" href="/">4Phycs</a>
      <ul id="nav-mobile" class="right hide-on-med-and-down">
        <li><a href="/tags">Tags</a></li>
        <li><a href="/categories">Categories</a></li>
        <li><a href="/me">Me</a></li>
        <li><a href="/about">About</a></li>
        <li><a href="/contact">Contact</a></li>
      </ul>
    </div>
  </div>
</nav>

<div class="container">
  <a href="#" data-activates="slide-out" class="button-collapse top-nav full hide-on-large-only">
    <i class="material-icons">menu</i>
  </a>
</div>
<ul id="slide-out" class="side-nav fixed">
  <li>
    <div class="userView thi-userView">
      <div class="background"></div>
        <a href="/">
          <img style="display:inherit;" class="circle z-depth-2" src="/assets/res/user.png">
        </a>
      <span style="font-size: larger;" class="white-text name">Paolo Avogadro</span>
      <span class="white-text email"><a style="color: #bdbdbd;" href="http://"></a></span>
    </div>
  </li>
  <li style="padding: 10px;">
    <form action="/search" method="get">
      <input class="search-sidebar" type="search" name="q"  placeholder="Search something?" autofocus>
      <input type="submit" value="Search" style="display: none;">
    </form>
  </li>
  <div id="nav-bar">
    <li><a class="waves-effect" href="/"><i class="material-icons">home</i>Home</a></li>
    <li><a class="waves-effect" href="/categories"><i class="material-icons">sort</i>Categories</a></li>
    <li><a class="waves-effect" href="/tags"><i class="material-icons">loyalty</i>Tags</a></li>
    <li><div class="divider"></div></li>
    <li><a class="waves-effect" href="/me"><i class="material-icons">person</i>Me</a></li>
    <li><a class="waves-effect" href="/about"><i class="material-icons">info</i>About</a></li>
    <li><a class="waves-effect" href="/contact"><i class="material-icons">perm_contact_calendar</i>Contact</a></li>
  </div>
</ul>

	
</header>
<main>
	<div class="container">
	  <div id="page-info">
		  <h2>Search on this page</h2>
		</div>
		<div class="row">
			<form action="/search" method="get">
	<input type="search" name="q"  placeholder="Type what you wanna search..." autofocus>
	<input type="submit" value="Search" style="display: none;">
</form>

<p style="opacity: 0.6; color: darkmagenta; font-size: 1.2rem;margin-bottom: 20px;" ><span id="search-process">Loading</span> results <span id="search-query-container" style="display: none;">for keyword "<strong id="search-query"></strong>"</span></p>
<ul id="search-results"></ul>

<script>
	window.data = {
		
			
				
					
					
					"mapreduce": {
						"id": "mapreduce",
						"title": "MapReduce, Calcolo Parallelo, UNIMIB",
						"categories": "italiano",
						"url": " /mapReduce",
						"content": "MapReduce a.a. 2019-2020, in queste diapositive mostro un paio di modi\n  per fare il prodotto matrice-matrice tramite MapReduce; in pratica ho fatto un adattamento e traduzione di quanto fatto da\n http://www.norstad.org\n (Attenzione, il sito originale sembra non piu’ raggiungibile, probabilmente tramite quei servizi che contengono un archivio di internet e’ possibile trovarne una copia). \nQueste diapositive sono state usate durante il corso di “Sistemi di Calcolo Parallelo” tenuto persso il DISCo all’Universita’ degli Studi di Milano-Bicocca.\n\n\nHo usato inoltre due Jupyter notebook:\n\n\n  \n    HADOOP Streaming, qui viene introdotto come usare degli eseguibili scritti\n nel linguaggio preferito per usare  Hadoop (invece che dover usare Java)\n  \n  \n    MRJob, per utilizzare delle semplici classi di Python per\n job di tipo MapReduce anche complessi (e testarli facilmente in locale, senza dover installare Hadoop)\n  \n\n\ni notebook originali erano forniti in un corso del CINECA del 2015. Eventuali errori di queste versioni modificate sono miei e non da imputare agli autori dei notebook\noriginali.\n\nA chi e’ rivolto MapReduce?\n\nUna premessa: questa e’ l’ultima parte del corso, prima introduco MPI,\n poi OpenMP \ne CUDA\n, infine passo  HADOOP/MapReduce.\n\nI primi 3 argomenti sono pertinenti per chi e’ interessato a fare High Performance Computing. Richiedono di imparare \nnuove API, capire nel dettaglio come e’ fatto l’hardware sottostante e scrivere dei codici abbastanza complessi.\n\nSe invece lo scopo e’ quello di utilizzare hardware (quasi) commerciale e  cercare di evitare\nle problematiche legate ad imparare un nuovo linguaggio, allora ha senso pensare in termini di Hadoop/Mapreduce.\n\nL’ipotesi di lavoro e’ che si abbia a che fare con grandi moli di dati (che devono essere distribuiti su computer distinti).\n\nL’idea e’ proprio quella di facilitare buona parte della comunicazione necessaria quando si ha a che fare con\ntante macchine che lavorano in parallelo. Per questo, molto del lavoro e’ fatto dal filesystem distribuito (nel caso di HADOOP\nsi chiama HDFS). Il cuore di un calcolo MapReduce e’ di utilizzare coppie chiave-valore.\nIl compito/algoritmo da eseguire in parallelo deve poter essere spezzato in 2 fasi, una di seguito all’altra, chiamate:\n\n\n  \n    Map\n  \n  \n    Reduce\n  \n\n\nDurante la fase di Map, tanti computer in parallelo eseguono il medesimo compito (chiamato Mapping). \nIl risultato dell’esecuzione di ogni Mapper e’ l’emissione di molte coppie chiave-valore (intermedie).\nAttenzione, i Mapper lavorano in modo indipendente l’uno dall’altro: non comunicano tra loro! \nEssi fanno tutti la stessa cosa ma con parti diverse di dato (HDFS assegna i pezzi del dato senza un ordine particolare).\n Le coppie chiave-valore prodotte dai Mapper\nvengono ridistribuite (shuffling) da HDFS ai Reducer, in un modo specifico: ogni reducer riceve solo coppie chiave-valore\nche abbiano la stessa chiave (intermedia).\n\nTutta la comunicazione di un job MapReduce si riassume quindi nella fase di shuffling! Sta al programmatore scrivere dei Mapper che emettano\nle chiavi intermedie corrette, in modo che poi i reducer facciano il lavoro che ci si aspetta. Una volta fatto questo, la cominicazione e’ interamente\ngestita da  HDFS!\n\nA questo punto, tutti i Reducer lavorano con i dati ottenuti ed emettono a loro volta coppie chiave-valore (il risultato finale del calcolo MapReduce).\nTutti i Reducer fanno esattamente lo stesso algoritmo, ma ognuno ha dei dati diversi opportunamente re-distribuiti tramite l’uso di coppie\nchiave-valore.\n\nIl difficile di un job  MapReduce e’ proprio nel trovare le giuste coppie chiave-valore intermedie emesse dai Mapper che consentano di fare arrivare\nai Reudcer i dati corretti."
					}
					
				
			
		
			
				
					,
					
					"cuda": {
						"id": "cuda",
						"title": "CUDA, Calcolo Parallelo, UNIMIB",
						"categories": "italiano",
						"url": " /Cuda",
						"content": "CUDA a.a. 2019-2020:\nqueste diapositive sono estese, ovvero contengono tutte le immagini e le “animazioni” (per esempio i punti di una lista possono comparire uno dopo l’altro).\nRispetto all’anno precedente, sono state fatte varie modifiche, sia di tipo strutturale (alcuni argomenti sono stati modificati e spostati) e sono state\naggiunte nuove immagini e “animazioni”.\n  \n  \n    CUDA a.a. 2018-2019: queste diapositive sono in formato “handout”, ovvero le\n animazioni del singolo frame sono condensate nell’ultima immagine del frame, e le liste appaiono tutte insieme (non una per volta).\nD’altra parte la quantita’ di memoria richiesta e’ minore, e sono piu’ facilmente studiabili.\n  \n\n\nI link qui sopra si riferiscono alle note che ho scritto su CUDA. Sono state usate durante il corso di “Sistemi di Calcolo Parallelo”, presso il\nDipartimento di Informatica, Sistemisitca e Comunicazione dell’Universita’ degli Studi di Milano-Bicocca.\nIn alcuni casi possono esserci dei richiami ad altre parti del corso, in particolare\na  MPI\n e OpenMP.\n\nA chi si rivolge CUDA?\n\n\n  \n    a chi ha una scheda grafica NVIDIA!\n  \n  \n    … e vuole velocizzare dei calcoli che richiedono molte volte la stessa operazione ma su dati differenti.\n  \n\n\nIn una GPU infatti, ci sono centinaia (migliaia) di Aritmetic Logic Units (ALU) che possono eseguire operazioni in modo concorrente,\n ma ci sono poche unita’ di controllo che gestiscono le ALU. Per questo motivo le \nALU devono lavorare in lockstep ovvero un gruppo (warp) di ALU deve eseguire la stessa operazione … su dati differenti.\n\nQuesto approccio e’ una specie di versione piu’ complessa rispetto a  OpenMP\n dove molti thread possono accedere ad aree di memoria condivise.\n\nIl punto chiave da comprendere quando si vogliono velocizzare \ndei calcoli tramite CUDA e’ spesso legato alla memoria (o meglio alle memorie).\nAvendo a disposizione molte unita’ di processazione, il problema puo’ diventare quello di portare i dati \ndalla memoria al chip. Se eseguire un calcolo puo’ richidere un solo ciclo di clock, \nla latenza necessaria per portare il dato sulla ALU ne puo’ richiedere centinaia!\n\nLe GPU sono progettate per “nascondere” la latenza con un trucco:\nmentre un warp aspetta la memoria, un altro warp puo’ essere attivato a costo zero ed eseguire operazioni. \nNelle normali CPU, questo passaggio (context switch), puo’ essere molto costoso e come risultato\nuna CPU puo’ passare molto tempo in stato di idle. Con una GPU e’ invece possibile ottenere \ndelle occupancy molto alte.\n\nDal punto di vista del programmatore, invece, \nper ottenere un codice che sfrutti al meglio le caratteristiche di CUDA \ne’ necessario conoscere bene come si relazionano le strutture fisiche (CUDA core,\nStreaming Multiprocessor,…) e le strutture logiche (thread, warp, blocco e griglia).\n\nE’ altrsi’ necessario sfruttare i vari tipi di memoria: registri, shared memory, cache, \nConstant, Texture e Global.\n\nUna buona applicazione di CUDA puo’ velocizzare notevolmente un calcolo, ma ha una\ncurva di apprendimento piu’ ripida rispetto ad OpenMP (e probabilmente anche di MPI)."
					}
					
				
			
		
			
				
					,
					
					"figli": {
						"id": "figli",
						"title": "Probabilita' figli e misura",
						"categories": "italiano",
						"url": " /figli",
						"content": "Il Problema\n\nMi sono imbattuto in questo interessante e “semplice” problema di statistica \n(sarebbe meglio dire dalla semplice formulazione).\nQuesto mio post e’ in pratica una riassunto di questo bel video\n di Zach Star, a cui aggiungo qualche considerazione personale.\n\nUn’osservazione: e’ molto importante la definizione della domanda che verra’ posta,\nperche’ ci sono vari dettagli che possono sfuggire.\n\nVedremo inoltre una cosa molto interessante, non e’ sufficiente pensare in termini di popolazioni, \nma e’ necessario pensare anche in termini di come queste popolazioni vengono misurate.\n\ninfoSupponiamo di incontrare una persona in un bar, Tizio per gli amici. Durante una conversazione, \nTizio ci dice che ha 2 figli (senza specificarne il sesso), a questo punto decide in darci \ndue informazioni aggiuntive, una dopo l’altra:\n\n\ninfo1. almeno uno di questi figli e’ femmina \n\ninfo2. la propria figlia si chiama Jane (come la morosa di Tarzan).\n\nerror\nDomanda 1: quando il nostro interlocutore ci ha detto di avere almeno una\nfiglia femmina quale probabilita’ esiste che anche il secondo figlio sia una femmina? \n\nerror\nDomanda 2: quando aggiunge che la propria figlia si chiama Jane, la probabilita’ che il secondo figlio sia femmina cambia?\n\n\nProbabilita’\nPrima di procedere bisogna dare una definizione operativa di probabilita'. In questo caso ne prendiamo una ragionevole e\nsemplice (di tipo frequentista). Supponiamo che la situazione appena descritta si ripeta molte volte:\n incontro molti padri che mi dicono: ho due figli di cui almeno una figlia femmina. A questo punto aggiungo la famiglia appena\nconocsciuta sul taccuino; in seguito annoto sul anche il sesso del secondo figlio.\nQuando ho una popolazione abbastanza grande (migliaia di casi), conto il numero di famiglie totali e conto quante di esse\n hanno 2 femmine. La probabilita' sara’ il rapporto tra le famiglie con 2 femmine sul totale delle famiglie\nannotate.\n\nIl tutto va ripetuto anche nel caso in cui il genitore ci dice di avere 2 figli, di cui almeno una femmina di nome Jane\n, segnandoci la famiglia e il sesso del secondo figlio. La probabilita’ sara’ anche in questo caso il numero dei casi\n favorevoli rispetto ai totali.\n\nAttenzione: teniamo 2 conti separati per i due casi (potremmo usare due taccuini separati).\n\nPopolazione A\n\n\n\n  \n\n\n\nA questo punto il bravo statistico comincia a costruire un modello in cui ci sono tutti gli oggetti possibili (meglio se\nquesti sono equiprobabili, cosi’ basta contarli).\nIn questo caso parliamo di popolazioni e di famiglie equiprobabili.\n\nLe combinazioni di famiglie equiprobabili sono le seguenti (M=maschio, F=femmia):\n\n  MM    (primogenito= maschio, secondogenito= maschio)\n  MF    (primogenito= maschio, secondogenito= femmina)\n  FM    (primogenito= femmina, secondogenito= maschio)\n  FF    (primogenito= femmina, secondogenito= femmina)\n\n\nQuesto perche’ possiamo considerare che all’incirca ci sia il 50% di probabilita’ di avere un figlio\nmaschio e altrettanto di avere una femmina (inoltre il sesso del secondo figlio non e’ influenzato dal sesso del\n primo figlio, resta il 50%)\n\nL’insieme delle famiglie che comprende almeno una figlia femmina e’ un sottoinsieme del totale.\nChiamiamo questo sottoinsieme  popolazione A, restano  solo i casi:\n\n  MF\n  FM\n  FF\n\n\nOgnuna di questi tipi di famiglie ha la stessa probabilita’ dell’altra.\nData questa popolazione (2 figli, di cui almeno una femmina),possiamo dire che solo in 1/3 dei casi la seconda figlia sara’ femmina.\nSi noti che questo risultato e’ indipendente dal nome dei ragazzi.\n\nPopolazione B\n\n\n\n  \n\n\n\nCerchiamo ora la popolazione di famiglie per cui si ha almeno una figlia femmina di nome Jane. Questa popolazione, sara’ \nun sottoinsieme della popolazione A.\n\nPer facilitarci le idee, assegnamo delle quantita’ alle popolazioni. Per esempio ci sono 100 000 famiglie MF, 100 000 FM  e 100 000 FF.\nSupponiamo che la frazione di ragazze chiamate Jane sia 1/100.\n\nVediamo qual’e’ ora la popolazione di riferimento (popolazione B):\n\n\n  si passa da 100 000 famiglie MF  $\\rightarrow$  1000 famiglie del tipo MJ  (dove J sta per Jane)\n  si passa da 100 000 famiglie FM  $\\rightarrow$  1000 famiglie del tipo JM\n  dalle 100 000 famiglie FF $\\rightarrow$ si passa a famiglie del tipo JF  e FJ, quindi in totale 2000 famiglie\n con 2 femmine hanno una ragazza chiamate Jane.\n\n\n(nel grafico sono state sottolineate in verde le famiglie che contribuiscono alla popolazione totale)\nIn questo caso quindi la popolazione totale comprende 4000 famiglie che corrispondono alle caratteristiche: \n2 figli di cui una femmina di nome Jane (supponiamo inoltre che i due figli non possano avere lo stesso nome).\nA differenza del caso precednte 1/2 delle famiglie comprendera’ una seconda figlia femmina.\n\nParadosso\n\nUn momento:\n\n  se conosco il nome della ragazza questo cambia in modo consistente la probabilita' che l’altro figlio \nsia una femmina: si passa da 1/3 a 1/2.\n  Il cambio e’ indipendente dal nome della ragazza!\n  quando Tizio mi aveva detto di avere una figlia, io sapevo gia' che questa doveva avere un nome… solo non sapevo\nquale!\n\n\nQueste tre condizioni sembrano in qualche modo contradditorie. Se il passaggio da 1/3 ad un 1/2 e’ indipendente dal nome,\ndato che io sapevo gia’ che la ragazza aveva un nome, come e’ possibile che il fatto che mi venga comunicato cambi \nle probabilita? La probabilita’ o e’ indipendente dal nome, o dipende!\n\nSoluzione: a cosa corrispondono le probabilita’ 1/3 e  1/2?\n\nIl problema e’ molto semplice: le probabilita’ 1/3 e 1/2 non corrispondono al problema iniziale!\nQueste probabilita’ sono corrette se si campionano le popolazioni in un modo differente rispetto a quello enunciato\ndal problema. Vediamo ora un modo per ottenere quelle probabilita’.\nPrendiamo un campione rappresentativo di genitori con 2 figli e mettiamolo in uno stadio. \n A questo punto si chiede a tutti quelli con 2 figli maschi di uscire.\n\n\n  Si chiede a quelli con due figlie femmine di alzare la mano. E si ottiene 1/3 del totale dei presenti.\n\n\nSe invece, facciamo uscire dallo stadio tutti i genitori, tranne quelli che hanno almeno un figlio femmina chiamato Jane,\n e a questo punto chiediamo loro di alzare la mano se hanno anche una seconda figlia femmina, \notterremo che circa 1/2 dei presenti alzera’ la mano.\n\nOra inserisco una piccola digressione.\nEsiste un interessante teorema che indica che per un “metodo di scelta random” la media spaziale \n(ovvero in questo caso contare tutte le famiglie con una caratteristica) puo’ essere rimpiazzata\nda una media temporale, a patto proprio che il criterio di scelta delle famiglie sia sufficientemente “caotico/random”.\nPer questo posso ottenere lo stesso risultato indicato sopra se io chiedo a tutte le persone che \nincontro al bar, una dopo l’altra (supponendo che siano sinceri, ovviamente):\n\n  se hanno 2 figli di cui almeno uno femmina\n  se il nome della ragazza e’ Jane\n\n\nSe uno guarda al problema dal punto di vista delle persone presenti allo stadio, il fatto di fare uscire\ndallo stadio tutti coloro che non corrispondono a “avere una figlia femmina” ha un effetto tangibile.\nQuando si chiede di uscire a tutti coloro che non corrispondono ad “avere una figlia femmina chiamata Jane” \nl’effetto sara’ diverso. Vengono fatti dei campionamenti differenti dalla popolazione iniziale e questo\nmodifica quindi le frazioni/probabilita’.\n\nerrorAttenzione: il modo di procedere appena esposto non corrisponde al problema iniziale!\n\nIl problema iniziale era invece: incontro Tizio ad un bar, ad un \ncerto punto lui mi dice  di avere due figli, di cui almeno una femmina e successivamente ci dice il nome della femmina: Jane.\n\nIn questo caso il campionamento delle popolazioni e’ fatto in modo differente!\nSono i vari possibili “Tizio” che incontro al bar che definiscono il campione. \nQuesto cambia molto il risultato. Vediamo come:\n\nPopolazione C\n\nSupponiamo che ogni padre abbia piu’ o meno la stessa probabilita’ di parlare dei propri figli\n (non e’ necessariamente vero ma e’ ragionevole), prendiamo ora la popolazione A e vediamo\ncome si modifica, con un campionamento spontaneo (e’ il genitore che decide di cosa parlare):\n\n  da 100 000 famiglie del tipo MF, e’ ragionevole pensare che solo 1/2 dei padri mi parlera’ della figlia femmina\nl’altra meta’ mi dira’ di avere un figlio maschio $\\rightarrow$ solo 50 000 famiglie di tipo MF vengono aggiunte al mio taccuino\n  da 100 000 famiglie del tipo FM $\\rightarrow$ 50 000 famiglie anche in questo caso solo la meta’ dei padri parlera’ della femmina\n  da 100 000 famiglie del tipo FF $\\rightarrow$ 100 000 famiglie: siamo certi che, se il padre\nparla di un solo figlio, dovra’ dire che ha almeno una femmina!\n\n\n\n\n  \n\n\n\nQuindi se io lascio che l’interlocutore decida di cosa parlare, la popolazione A diventa la popolazione C:\n\n  50 000 famiglie del tipo MF\n  50 000 famiglie del tipo FM\n  100 000 famiglie del tipo FF\n\n\nPer questo motivo se non si fa un campionamento attivo, quando si incontra Tizio al bar  e questi ci dice che\nha 2 figli di cui almeno uno femmina, la probabilita’ che anche l’altro figlio sia femmina e’ 1/2.\n\nPopolazione D\n\nVediamo ora cosa succede se Tizio ci indica che il nome della propria figlia e’ Jane (nome con un’occorrenza\n ipotetica di 1/100),\n chiamo questo insieme di famiglie popolazione D:\n\n  da 50 000 famiglie MF si passa a 500 famiglie MJ\n  da 50 000 famiglie FM si passa a 500 famiglie JM\n  da 100 000 famiglie FF si passa a 1000 famiglie composte la meta’ da Jf e l’altra meta’ da fJ (non e’ possibile dare lo stesso nome a due figli…)\n\n\nIn questo caso e’ interessante notare che un genitore con 2 figlie femmine, di cui una chiamata Jane, \npotrebbe decidere di dirci il nome dell’altra figlia (50% dei casi). Per questo, nonostante la sua famiglia rientri\nnelle caratteristiche che noi vorremmo, verra’ rimossa dalla popolazione totale perche’ lui ha deciso di\nrivelarci un’altra informazione!\n\nIn questo caso, il fatto che il genitore mi abbia indicato il nome della figlia non\nha cambiato la probabilita’ che la seconda figlia sia femmina: resta 1/2.\n\n\n\n  \n\n\n\nQuando succede?\nE’ questo un discorso questo di lana caprina? No! se effettivamente potessimo fare un esperimento del genere e scommettessimo\ndei soldi sul sesso dell’altro figlio di un nostro interlocutore, potremmo vincere (in media, ripetendo l’esperimento molte volte)\nsolo chiedendo ATTIVAMENTE delle informazioni sulla sua famiglia. Altrimenti, lasciando \nall’interlocutore l’iniziativa di parlare e scommettendo sul sesso dell’altro figlio avremmo il 50% \ndelle probabilita’ di azzeccare.\n\nConclusioni\nIl modo in cui l’informazione viene raccolta (come si fa l’esperimento per un fisico) modifica in modo sostanziale la risposta. Non e’ una cosa nuova.\nTutti sanno, per esempio, che per studiare una popolazione di qualche natura, non posso basarmi sui dati\nche mi vengono spontaneamente dati. \nNel caso in questione, il fatto di chiedere attivamente all’interlocutore informazioni riguardo i\npropri figli, modifica quello che lui ci dira’. Nel caso di domande attive, le probabilita’ ottenute saranno quindi:\n\n  1/3 di coloro che ci dicono di avere una figlia femmina avra’ anche un’altra figlia femmina\n  1/2 di coloro che ci dicono di avere una figlia di nome Jane  avra’  anche un’altra figlia femmina.\n\n\nSe invece si registrano le informazioni fornite spontaneamente, anche se l’informazione fornita dall’interlocutore e’ la stessa rispetto \nal caso precedente, otterremo:\n\n  1/2 di coloro che ci dicono di avere una figlia femmina avra’ anche un’altra figlia femmina\n  1/2 di coloro che ci dicono di avere una figlia di nome Jane  avra’  anche un’altra figlia femmina.\n\n\nQuindi il motivo per cui la probabilita’ (nel caso di domanda attiva) e’ differente nei 2 casi e’ perche’ io\nseleziono delle famiglie particolari creando delle popolazioni specifiche. \nNel dettaglio, selezionare le famiglie con almeno una figlia femmina di nome Jane privilegia le famiglie con 2 \nfemmine. Per questo motivo la probabilita’ che anche il secondo figlio sia femmina passa da 1/3 a 1/2.\n\nP.S:\nprobabilmente in un altro post descrivero’ cosa succede nel caso in cui ci sia del rumore e l’informazione non\nvenga passata correttamente.\n\nP.P.S:\n Una considerazione da fisico, questo tipo di fenomeno ricorda curiosamente\nil problema della misura in meccanica quantistica. L’evoluzione spontanea di un sistema e’ profondamente\ndifferente dall’evoluzione dove interviene una misura."
					}
					
				
			
		
			
				
					,
					
					"random-access": {
						"id": "random-access",
						"title": "Random numbers towards Philosophy",
						"categories": "English",
						"url": " /random_access",
						"content": "Random numbers and algorithms:\nI was once browsing a math newsgroup, at a certain point I found a tricky \nquestion which made me think a bit.\n\nThe question sounded like this:\n\n  consider all the possible numbers (Real \nor Rational, there is no big difference) between 0 and 1.\n  Now please extract a random number among them.\n  (within 3 seconds I thought: 0.4324), done?\n\n\nAt this point the person highlighted the following strange thing:\nIf a set contains infinite numbers, \neach of them has ZERO probability. How could you extract a number?\n\nThat made me think.\n\nThis is one of the typical paradoxes based on the fact that you are told by\nsombody to do something, you think that you have done it, but in reality \nit is not true. It is generally called false choice when used by \nmagicians or mentalists. For example they make you choose freely a card,\nbut in reality your choice is guided… In this case I think it was a genuine question.\n\nHow do you pick a random number?\nLet’s suppose that a human brain contains a natural mechanism which allows\n you to  select digits randomly (like those random number generators based\n on quantum mechanics). \nLet’s also suppose that a brain can think of 100 digits per second.\nIt took me 3 seconds to answer, so at most I had the time for thinking at a number\nwith 300 digits: a lot! (well my brain is surely much slower…).\n\nUnfortunatelly, as long as the number of digits is finite, it means that \nthe mechanism for picking random number works on a finite set of numbers (and not\non an infinite set as it appeared from the question).\nSo we can say that at least one of them has a probability different from zero.\n\nAnother way to see the same thing is to think that, even if I had \nthe “possibiliy” to choose among an infinite set of numbers, for most of them\nthe probability was zero. However I don’t like very much this last \ninterpretation. I can use it for the sake of math modelling what is going\non but…. there are no infinities in real life.\n\nInfinities\n\nWell, this should be explained with a bit more of detail since in every\ncourse of undergrad physics one deals with all sort of infinities.\n\nThe potential of a point charge diverges at the center. Every time an integral\n is carried out we are dividing an interval in an infinite set of “points” and so on\nand so forth.\nThe models requiring infinties are in fact very pervasive, but curiously enough\npeople tend to forget that no infinite quantity has ever been measured.\n\nThe reason for this is essentially the same one that prevents a person to pick \na number from an infinite set. In order to measure an infinite quantity,\nwhich needs to be described with an infinite set of digits, one person needs\ntoo much time: infinite.\n\nEpistemology\n\nSince I am walking in the kingdom of phylosophy, please let me walk a bit further.\n\nThe practical “feasability” of an action should always be taken into account.\nSometimes people have the tendency to think too much “theoretically”.\nIf something is theoretically feasible, than it is as if we have already done it.\n\nThis is clearly not true. If an action requires too much time to be completed \nit might become practically impossible. The same happens if the action requires too \nmany resources. The different paths taken which might lead to a result should also be taken into\naccount.\n\nOne of the most popular definitinos of science (due to Karl Popper), suggests\nthat a statement is scientific if it is possible to disprove it.\nIt is a very compact definition which grasps a lot of what is science, and that\nis probably the reason of its popularity.\n\nI notice however one of it limits with the following example.\nThere is at least a mushroom in Norway, underneath which lives a gnome.\nIt is enough to look under a mushroom to check, and the number of mushrooms\nin Norway is clearly finite. In this respect there is a clear method to disprove\nthe sentence, and somebody might think that for this reason it becomes “scientific”.\nNonetheless the practical feasibility of checking all of the mushrooms, is \nessentially zero. According to my opinion\nthe scientific value of the sentence is essentially zero too.\n\nIn general, I belive that an adjustment of this definition of science should\nuse weights for the sentences. The more “feasible” it is to disprove the \nsentence, the more scientific it becomes.\n\nAn even better way to see science should include not only partial disproofs, but \nalso partial proofs and hints. Think of Cosmology for example, it is a science\nwhich deals with the whole universe (and even more…) we can easily say that \nmost of the cosmological theories, including the more accepted ones can hardly\nbe disproved. On the other hand, we can collect many hints which can guide our idea\nof the universe and build theories which are more and more solid as a function\nof the hints that we have. I remember once at a school of general relativty with some\nof the big shots around, one of the finest lecturers was George Ellis, who, among other things provided, a very\nnice survey of many possibile variations regarding the structure of the universe.\nAt the same school,  Andrey Linde, one of the fathers of inflationary cosmology,\nwhen asked about his theory of many universes each with its own constants of physics, simply\nrepied that he could not prove it, but like a nice music, he was going to stick with this idea\nunless he heard a better one. The point here is that, for some complex topics,\nthe very idea of proving or disproving becomes blurry.\n\nI am aware that this modified definition of science has limits (for example\nis very difficult to decide the weight which defines to which extent an action\nis feasible). However one might accept the fact that science is\nnot just a block of granite, but its boundaries are more like the sea shore.\n\nP.S.:\nPeople who have seen an analog tester, might claim that when you measure the\nresistence there is a scale with an  sign on it.\nThis is a bit misleading, it simply means that the resistence under observation\nexceeds the max range measurable by the tester.\n\nP.P.S:\nI think that, among the approaches dealing with science, the paradigms shifts by\n Thomas Kuhn are very appealing (but less compact than Popper ideas,\nand thus less easy to use)."
					}
					
				
			
		
			
				
					,
					
					"cpp": {
						"id": "cpp",
						"title": "Tutorial di C++ per utenti C",
						"categories": "italiano",
						"url": " /Cpp",
						"content": "Autore:  Eric Brasseur\n  Traduzione in italiano di Paolo Avogadro\n  Qui il link della versione originale (inglese)\n  Qui invece il pdf di questa pagina\n\n\nUn nuovo modo di includere librerie\n\nEsiste un nuovo modo per includere (#include) delle\nlibrerie (il vecchio metodo funziona comunque, ma il compilatore si\nlamenta). L’estensione .h non viene piu’ usata, mentre\ni nomi delle librerie standard del C devono ora cominciare con la\nlettera c. Per fare si’ che il porgramma usi queste\nlibrerie correttamente bisogna aggiungere la seguente linea di comandi:\nusing namespace std;\n\nusing namespace std;\n#include &lt;iostream&gt;    // questa e' una libreria chiave del C++ \n#include &lt;cmath&gt;       // questa e' la libreria standard del C chiamata math.h\nint main ()\n{\n  double a;\n  a = 1.2;\n  a = sin (a);\n  cout &lt;&lt; a &lt;&lt; endl;\n  return 0;\n}\n\n\n output:  0.932039\n\n\nQualche consiglio per chi ha poca esperienza:\n\nPer compilare questo programma, prima va scritto (o copiato) in un\neditor di testo (gedit, kwrite, kate, kedit, vi, emacs, nano, pico,\nmcedit, Notepad…), il file va salvato e e chiamato, per esempio\ntest01.cpp (se si e’ proprio dei principianti sarebbe utile mettere il\nfile all’interno della propria home directory, ovvero per esempio\n/home/jones in un sistema di tipo Unix).\n\nPer compilare questo file sorgente, bisogna scrivere questo comando\n(sulla maggior parte dei sistemi di tipo Unix) in una console o nella\nterminal window:\n\ng++ test01.cpp -o test01\n\n\n(questo produrra’ un binario eseguibile chiamato test01) per far\ngirare questo eseguibile prodotto dalla compilazione (supponendo che non\nci siano stati degli errori, nella fase di scrittura o copia), si deve\nscrivere:\n\n./test01\n\n\nOgni volta che si modifica il file sorgente test01.cpp, e’ necessario\ncompilarlo ancora se si vuole che le modifiche si propaghino\nall’eseguibile (per esempio con la freccia cursore in su si puo’\nscorrere la lista dei vecchi comandi lanciati).\n\nNuovi modi per commentare linee di codice\n\nE’ possibile usrare // per indicare che una linea non e’ codice ma un\ncommento:\n\nusing namespace std;    // uso del namespace della libreria standard\n#include &lt;iostream&gt;     // la libreria iostream e' molto utile\nint main ()             // la funzione principale del codice \n{\n  double a;             // dichiarazione della variabile a \n  a = 456.47;\n  a = a + a * 21.5 / 100; // un calcolo\n  cout &lt;&lt; a &lt;&lt; endl;      // mostra il contenuto di a\n  return 0;               // fine della funzione \n}\n\n\n554.611\n\n\n(La possibilita’ di usare // per i commenti e’ stata aggiunta al C nel\nC99 e nell’ ANSI C 2000)\n\nNuovi modi per fare leggere comandi da tastiera e scrivere a video\n\nPer interfacciare i comandi da tastiera e a schermo con il codice e’\npossibile usare dei nuovi comandi:\n\n\n  \n     cout &lt;&lt;\n  \n  \n     cin &gt;&gt;\n  \n\n\nusing namespace std;\n#include &lt;iostream&gt;\nint main()\n{\n  int a;         // a e' una variabile di tipo integer\n  char s [100];  // s punta a una stringa \n  cout &lt;&lt; \"Questo e' un programma di esempio.\" &lt;&lt; endl;\n  cout &lt;&lt; endl;         // endl e' identico a \\n (end of line)\n  cout &lt;&lt; \"Inserisci la tua eta': \";\n   cin &gt;&gt; a;\n  cout &lt;&lt; \"Inserisci il tuo nome: \";\n   cin &gt;&gt; s;\n  cout &lt;&lt; endl;\n  cout &lt;&lt; \"Ciao \" &lt;&lt; s &lt;&lt; \", hai \" &lt;&lt; a &lt;&lt; \" anni\" &lt;&lt; endl;\n  cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; \"arrivederci\" &lt;&lt; endl;\n  return 0;\n}\n\n\n Questo e' un programma di esempio.\n Inserisci la tua era':  12\n Inserisci il tuo nome:  Paolo\n \n Ciao Paolo, hai 12 anni\n \n \n arrivederci\n\n\nDichiarazione delle variabili\n\nLe variabili possono ora essere dichiarate in qualunque parte del\ncodice:\n\nusing namespace std;\n#include &lt;iostream&gt;\nint main ()\n{\ndouble a;\ncout &lt;&lt; \"Ciao, questo e' un programma di prova.\" &lt;&lt; endl;\ncout &lt;&lt; \"Inserisci il parametro a: \";\ncin &gt;&gt; a;\na = (a + 1) / 2;\ndouble c;        // &lt;=========== variabile appena dichiarata\nc = a * 5 + 1;\ncout &lt;&lt; \"c contiene : \" &lt;&lt; c &lt;&lt; endl;\nint i, j;        // &lt;=========== variabili appena dichiarate\ni = 0;\nj = i + 1;\ncout &lt;&lt; \"j contiene : \" &lt;&lt; j &lt;&lt; endl;\nreturn 0;\n}\n\n\nCiao, questo e' un programma di prova.\nInserisci il parametro a: 7\nc contiene              : 21\nj contiene              : 1\n\n\nE’ consigliabile usare questa caratteristica per rendere il proprio\ncodice piu’ leggibile, e non piu’ disordinato. Come nel C, le variabili\npossono essere incapsulate tramite le parentesi graffe {}. In questo\ncaso sono locali nello scope definito proprio dalle\nparentesi graffe. Quello che succede a tali variabili all’interno della\nzona incapsulata non modifica eventuali variabili con\nlo stesso nome ma che si trovano all’esterno.\n\nusing namespace std;\n#include &lt;iostream&gt;\nint main ()\n{\n  double a;\n  cout &lt;&lt; \"Inserisci un numero: \";\n  cin &gt;&gt; a;\n  {\n    int a = 1;\n    a = a * 10 + 4;\n    cout &lt;&lt; \"Numero locale: \" &lt;&lt; a &lt;&lt; endl;\n  }\n  cout &lt;&lt; \"Tu hai inserito: \" &lt;&lt; a &lt;&lt; endl;\n  return 0;\n}\n\n\nInserisci un numero: 9\nNumero locale:       14\nTu hai inserito:  9\n\n\nInizializzazione di una variabile con dei calcoli\n\nUna variabile puo’ essere inizializzata con un calcolo di altre\nvariabili, per esempio:\n\nusing namespace std;\n#include &lt;iostream&gt;\nint main ()\n{\n  double a = 12 * 3.25;\n  double b = a + 1.112;\n  cout &lt;&lt; \"a contiene: \" &lt;&lt; a &lt;&lt; endl;\n  cout &lt;&lt; \"b contiene: \" &lt;&lt; b &lt;&lt; endl;\n  \n  a = a * 2 + b;\n  double c = a + b * a;\n  cout &lt;&lt; \"c contiene: \" &lt;&lt; c &lt;&lt; endl;\n  \n  return 0;\n}\n\n\na contiene: 39\nb contiene: 40.112\nc contiene: 4855.82\n\n\nVariabile dichiarate nella dichiarazione di un loop\n\nIl C++ consente di definire delle variabili locali per un loop:\n\nusing namespace std;\n#include &lt;iostream&gt;\nint main ()\n{\n  int i;\n  i = 487;                     // dichiarazione di i\n  for (int i = 0; i &lt; 4; i++)  // dichiarazione locale di i\n  {\n     cout &lt;&lt; i &lt;&lt; endl;  // questo manda in output 0, 1, 2 e 3\n  }\n  cout &lt;&lt; i &lt;&lt; endl;     // questo invece 487\n}\nreturn 0;\n\n\n0\n1\n2\n3\n487\n\n\nNel caso in cui la variabile non sia dichiarata da qualche parte prima\ndel loop, una persona potrebbe essere tentata di usarla anche dopo il\nloop stesso. Alcuni vecchi compilatori accettano questo comportamento.\nIn quel caso la variabile mantiene l’ultimo valore che aveva alla fine\ndel loop stesso. E’ molto SCONSIGLIATO usare questo modo di programmare\n(viene considerata una bad practice) che puo’ indurre ad errori\ndifficilmente trovabili).\n\nusing namespace std;\n#include &lt;iostream&gt;\nint main ()\n  {\n   for (int i = 0; i &lt; 4; i++)\n   {\n     cout &lt;&lt; i &lt;&lt; endl;\n   }\n   cout &lt;&lt; i &lt;&lt; endl;   // bad practice\n   i += 5;              // bad practice\n   cout &lt;&lt; i &lt;&lt; endl;   // bad practice \n\n   return 0;\n}\n\n\nt.cpp: In function ‘int main()’:\nt.cpp:12: error: name lookup of ‘i’ changed for new ISO ‘for’ scoping\nt.cpp:7: error: using obsolete binding at ‘i’\n\n\nAccesso alle variabili globali, anche se delle variabili locali hanno lo stesso nome\n\nSi puo’ accedere ad una variabile globale anche se all’interno di una\nfunzione si e’ dichiarata un’altra variabile con lo stesso nome.\n\nusing namespace std;\n#include &lt;iostream&gt;\ndouble a = 128;\nint main ()\n  {\n  double a = 256;\n  cout &lt;&lt; \"Local a: \" &lt;&lt; a &lt;&lt; endl;\n  cout &lt;&lt; \"Global a: \" &lt;&lt; ::a &lt;&lt; endl;  // nota l'operatore :: \n  return 0;\n} \n\n\nLocal a: 256\nGlobal a: 128 \n\n\nE’ possibile dichiarare una REFERENZA ad un’altra variabile\n\nE’ possibile dichiarare una REFERENZA ad un’altra variabile. In pratica\nquesto fa si’ che una variabile diventi un’altra variabile, e quindi\nsiano collegate tra loro (si usa per questo il simbolo di refereziazione\n&amp;). Detto in altri termini, si costruisce un altro nome della stessa\nvariabile.\n\nusing namespace std;\n#include &lt;iostream&gt;\nint main ()\n{\n  double a = 3.1415927;\n  double &amp;b = a;                        // b e' un altro nome per a!\n  b = 89;\n  cout &lt;&lt; \"a contiene: \" &lt;&lt; a &lt;&lt; endl;  // mostra 89\n  return 0;\n} \n\n\na contiene: 89 \n\n\nSe sei abituato ai puntatori e vuoi assolutamente sapere cosa succede,\nsemplicemente pensalo in questo modo:\n\ndouble &amp;b  = a =&gt; double *b= &amp;a e tutti i successivi b sono\nrimpiazzati da *b\\\nSe si e’ creata una referenza da una variabile ad un altra, questo non\npuo’ poi essere modificato nel seguito del codice per collegare la\nvariabile ad una nuova variabile. Per esempio non e’ possibile scrivere,\npoche linee dopo, &amp;b=c ed aspettarci che ora b sia c. Non funziona. La\ndichiarazione iniziale definisce una volta per tutte b. La b e a sono\nsposate per sempre e nulla le separera’.\n\nLe referenze possono essere usate per consentire ad una\nfunzione di modificare una variabile chiamante:\n\nusing namespace std;\n#include &lt;iostream&gt;\nvoid change (double &amp;r, double s)\n  {\n  r = 100;\n  s = 200;\n  }\nint main ()\n  {\n  double k, m;\n  k = 3;\n  m = 4;\n  change (k, m);\n  cout &lt;&lt; k &lt;&lt; \", \" &lt;&lt; m &lt;&lt; endl;  // mostra 100, 4\n  return 0;\n}\n\n\n100, 4 \n\n\nChiaramente lo stesso risultato poteva essere ottenuto tramite i\npuntatori in C, in particolare il compilatore C++, se si dovesse\ntradurre questo codice in C, scriverebbe:\n\nusing namespace std;\n#include &lt;iostream&gt;\nvoid change (double *r, double s)\n  {\n  *r = 100;      \n   s = 200;\n  }\nint main ()\n  {\n  double k, m;\n  k = 3;\n  m = 4;\n  change (&amp;k, m);       \n  cout &lt;&lt; k &lt;&lt; \", \" &lt;&lt; m &lt;&lt; endl; // mostra 100, 4\n  return 0;\n} \n\n\n100, 4 \n\n\nUna referenza puo’ essere usata per consentire ad una funzione di\nrestituire una variabile:\n\nusing namespace std;\n#include &lt;iostream&gt;\ndouble &amp;maggiore (double &amp;r, double &amp;s) // nota l'operatore &amp; prima di maggiore\n{\n   if (r &gt; s) return r;\n   else\n   return s;\n}\nint main ()\n{\n   double k = 3;\n   double m = 7;\n   \n   cout &lt;&lt; \"k: \" &lt;&lt; k &lt;&lt; endl;   // mostra 3\n   cout &lt;&lt; \"m: \" &lt;&lt; m &lt;&lt; endl;   // mostra 7\n   cout &lt;&lt; endl;\n   \n   maggiore (k, m) = 10;    // ho assegnato un valore alla funzione\n   \n   cout &lt;&lt; \"k: \" &lt;&lt; k &lt;&lt; endl;   // mostra  3\n   cout &lt;&lt; \"m: \" &lt;&lt; m &lt;&lt; endl;   // mostra 10\n   cout &lt;&lt; endl;\n\n   maggiore (k, m) ++;     // aggiungo uno al valore della funzione \n                           //   (dopo averla chiamata)\n                           \n   cout &lt;&lt; \"k: \" &lt;&lt; k &lt;&lt; endl;  // mostra  3\n   cout &lt;&lt; \"m: \" &lt;&lt; m &lt;&lt; endl;  // mostra 11\n   cout &lt;&lt; endl;\n\n  return 0;\n} \n\n\nk: 3\nm: 7\n\nk: 3\nm: 10\n\nk: 3\nm: 11\n\n\nAncora una volta, se si e’ abituati ai puntatori del C e si domanda come\nquesta notazione funzioni, basta immaginare che il compilatore traduca\nquanto scritto sopra nel seguente codice C standard:\n\nusing namespace std;\n#include &lt;iostream&gt;\ndouble *maggiore (double *r, double *s)\n{\n  if (*r &gt; *s) return r;\n  else\n return s;\n}\nint main ()\n{\n  double k = 3;\n  double m = 7;\n  \n  cout &lt;&lt; \"k: \" &lt;&lt; k &lt;&lt; endl;\n  cout &lt;&lt; \"m: \" &lt;&lt; m &lt;&lt; endl;\n  cout &lt;&lt; endl;\n  \n  (*(maggiore (&amp;k, &amp;m))) = 10;\n  \n  cout &lt;&lt; \"k: \" &lt;&lt; k &lt;&lt; endl;\n  cout &lt;&lt; \"m: \" &lt;&lt; m &lt;&lt; endl;\n  cout &lt;&lt; endl;\n  \n  (*(maggiore (&amp;k, &amp;m))) ++;\n  \n  cout &lt;&lt; \"k: \" &lt;&lt; k &lt;&lt; endl;\n  cout &lt;&lt; \"m: \" &lt;&lt; m &lt;&lt; endl;\n  cout &lt;&lt; endl;\n  return 0;\n}\n\n\nk: 3\nm: 7\n\nk: 3\nm: 10\n\nk: 3\nm: 11\n\n\nPer finire, per le persone che non amano i puntatori ma devono\ninteragire con essi, le referenze possono essere utili\nper in pratica fare un “un-pointer” delle variabili. Attenzione che\nquesto tipo di azione puo’ essere considerata una “bad practice” e puo’\ncreare problemi. Vedasi l’esempio:\n\nhttps://www.embedded.com/electronics-blogs/programming-pointers/4023307/References-vs-Pointers\n\nusing namespace std;\n#include &lt;iostream&gt;\ndouble *silly_function ()  // questa funzione restituisce un puntatore ad un double\n{\n  static double r = 342;\n  return &amp;r;\n}\nint main ()\n{\n  double *a;\n  a = silly_function();\n  double &amp;b = *a;   // ora b e' il double verso cui punta!\n\n  b += 1;           // ottimo!\n  b = b * b;        // non c'e' bisogno di scrivere *a ovunque! \n  b += 4;\n\n  cout &lt;&lt; \"Contenuto di *a, b and r: \" &lt;&lt; b &lt;&lt; endl;\n  return 0;\n}\n\n\ncontenuto di *a, b e r: 117635 \n\n\nE’ possibile dichiarare dei namespace\n\nSi possono dichiarare dei namespace. Le variabili dichiarate entro un\nnamespace possono essere usate tramite l’operatore ::\n\nusing namespace std;\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\nnamespace first\n{\n  int a;\n  int b;\n}\n\nnamespace second\n{\n  double a;\n  double b;\n}\n\nint main ()\n{\n   first::a = 2;\n   first::b = 5;\n   second::a = 6.453;\n   second::b = 4.1e4;\n   cout &lt;&lt; first::a + second::a &lt;&lt; endl;\n   cout &lt;&lt; first::b + second::b &lt;&lt; endl;\n\n   return 0;\n} \n\n\n 8.453\n 41005\n\n\nUna funzione puo’ essere dichiarata inline\n\nSe una funzione contiene semplici linee di codice e non contiene\nfor loop o simili, allora puo’ essere dichiarata\ninline. Questo implica che il codice della funzione\nstessa, al momento della compliazione, verra’ inserito in tutti i luoghi\ndove essa viene usata. In pratica diventa simile ad una macro. Il\nvantaggio principale e’ che il codice diventa piu’ veloce. Come piccolo\ndifetto c’e’ il fatto che l’eseguibile diventera’ un po’ piu’ grande\nperche’ tutte le linee della funzione verranno ripetute ovunque venga\nchiamata.\n\n \nusing namespace std;\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\ninline double ipotenusa (double a, double b)\n{\n   return sqrt (a * a + b * b);\n}\nint main ()\n{\n   double k = 6, m = 9;\n// le seguenti due linee producono esattamente lo stesso eseguibile:\n \n   cout &lt;&lt; ipotenusa (k, m) &lt;&lt; endl;\n   cout &lt;&lt; sqrt (k * k + m * m) &lt;&lt; endl;\n\n   return 0;\n} \n\n\n10.8167\n10.8167\n\n\nE’ stata aggiunta la struttura exception\n\nOltre alle classiche strutture di controllo del C: for, if, do,\nwhile, switch… nel C++ viene inserita una nuova struttura\nchiamata exception:\n\nusing namespace std;\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\nint main ()\n{\n   int a, b;\n   cout &lt;&lt; \"inserisci un numero: \";\n   cin &gt;&gt; a;\n   cout &lt;&lt; endl;\n   try\n   {\n       if (a &gt; 100) throw 100;\n       if (a &lt; 10) throw 10;\n       throw a / 3;\n   }\n   catch (int risultato)\n   {\n       cout &lt;&lt; \"il risultato e' : \" &lt;&lt; risultato &lt;&lt; endl;\n       b = risultato + 1;\n   }\n   cout &lt;&lt; \"b contiene: \" &lt;&lt; b &lt;&lt; endl;\n   cout &lt;&lt; endl;\n   \n   // un altro esempio dell'uso di exception:\n   \n   char zero [] = \"zero\";\n   char pair [] = \"pari\";\n   char notprime [] = \"non primo\";\n   char prime [] = \"primo\";\n   \n   try\n   {\n       if (a == 0) throw zero;\n       if ((a / 2) * 2 == a) throw pair;\n       for (int i = 3; i &lt;= sqrt (a); i++)\n       {\n          if ((a / i) * i == a) throw notprime;\n       }\n       throw prime;\n   }\n   catch (char *conclusion)\n   {\n       cout &lt;&lt; \"il numero che hai inserito e' \"&lt;&lt; conclusion &lt;&lt; endl;\n   }\n   \n   cout &lt;&lt; endl;\n   return 0;\n} \n\n\n Inserisci un numero: 5\n \n il risultato e': 10\n b  contiene: 11\n \n il numero che hai inserito e' primo\n\n\nE’ possibile definire valori di default per gli argomenti delle funzioni\n\nusing namespace std;\n#include &lt;iostream&gt;\ndouble test (double a, double b = 7)  // se non sepcificato, b=7\n{\n  return a - b;\n}\nint main ()\n{\n   cout &lt;&lt; test (14, 5) &lt;&lt; endl;  // mostra a video 14 - 5\n   cout &lt;&lt; test (14) &lt;&lt; endl;     // mostra a video 14 - 7\n}\nreturn 0;\n \n\n\n 9\n 7\n\n\nOverload delle funzioni\n\nUn notevole vantaggio del C e’ la possibilita’ di fare\nl’overload delle funzioni. Questo significa che\nfunzioni differenti possono avere lo stesso nome, basta\nche ci sia qualcosa che consenta al compilatore di distinguerle in modo\nunivoco, per esempio: il numero di parametri, il\ntipo dei parametri,…\n\nusing namespace std;\n#include &lt;iostream&gt;\ndouble test (double a, double b) // questa funzione prende 2 double e li somma\n{\n  return a + b;\n}\nint test (int a, int b)     // questa, invece, prende 2 interi e li sottrae\n{                           // ma ha lo stesso nome, \"test\", di quella che somma\n  return a - b;\n}\nint main ()\n{\n   double   m = 7,   n = 4;\n   int      k = 5,   p = 3;\n   cout &lt;&lt; test(m, n) &lt;&lt; \" , \" &lt;&lt; test(k, p) &lt;&lt; endl;\n   return 0;\n} \n\n\n11, 2 \n\n\nOverload di operatori (+-*/…) per il loro utilizzo con nuovi tipi di dato\n\nL’overload di operatori puo’ essere usato per ridefinire dei simboli di\nbase per lavorare con nuovi tipi di parametri:\n\nusing namespace std;\n#include &lt;iostream&gt;\nstruct vettore   // creo l'oggetto vettore\n{\n   double x;\n   double y;\n};\n \nvettore operator * (double a, vettore b)  // \n{               // fa prodotto PER uno scalare e un vettore 2D\n   vettore r;        \n   r.x = a * b.x;\n   r.y = a * b.y;\n   return r;                            \n}\n\nint main ()\n{\n   vettore k, m;       // Non c'e' bisogno di scrivere \"struct vettore\"\n   k.x = 2;            // per essere in grado di scrivere\n   k.y = -1;           // k = vettore (2, -1)\n                       // vedi il Cap 19.\n   m = 3.1415927 * k;  // Magia!\n   \n   cout &lt;&lt; \"(\" &lt;&lt; m.x &lt;&lt; \", \" &lt;&lt; m.y &lt;&lt; \")\" &lt;&lt; endl;\n   return 0;\n} \n\n\n (6.28319, -3.14159)\n\n\nOltre all’operatore di moltiplicazione (*), in C++ ci sono altri 43\noperatori di base di cui si puo’ fare overload, tra cui ci sono\n+=, ++, l’array [], e cosi’ via…\n\nTramite un overload, l’operatore &lt;&lt; normalmente impiegato per lo\nshifting binario di interi, puo’ portare all’output di uno stream (per\nesempio cout «. E’ possibile fare ulteriori overload\ndell’operatore &lt;&lt;, per l’output di nuovi tipi, come i vettori:\n\nusing namespace std;\n#include &lt;iostream&gt;\nstruct vettore\n{\n  double x;\n  double y;\n};\nostream&amp; operator &lt;&lt; (ostream&amp; o, vettore a)  // tipo in uscita e' un ostream\n{\n   o &lt;&lt; \"(\" &lt;&lt; a.x &lt;&lt; \", \" &lt;&lt; a.y &lt;&lt; \")\";\n   return o;\n}\nint main ()\n{\n  vettore a;\n  a.x = 35;\n  a.y = 23;\n  cout &lt;&lt; a &lt;&lt; endl;  // mostra a video (35,23)\n  return 0;\n} \n\n\n(35,23)\n\n\nTemplate: funzioni indipendenti dal tipo\n\nStanchi di definire la stessa funzione 5 volte? Una definizione per\nparametri di tipo int, una nuova definizione per\nparametri di tipo double, una per i\nfloat… Non ti sarai dimenticato un tipo? E se dovessi\nusare la stessa funzione con un nuovo tipo? Nessun problema il\ncompilatore C++ puo’ generare automaticamente tutte le versioni delle\nfunzioni che siano necessarie! Basta specificare come e’ fatta la\nfunzione dichiarando una funzione template:\n\nusing namespace std;\n#include &lt;iostream&gt;\n\ntemplate &lt;class ttype&gt;   \nttype minimo (ttype a, ttype b)\n{\n   ttype r;\n   r = a;\n   if (b &lt; a) r = b;  // gli operatori \"&lt;\" e \"=\" devono essere \n                      // definiti per tutti tipi per cui sono usati\n\n   return r;\n}   \nint main ()\n{\n   int i1, i2, i3;\n   i1 = 34;\n   i2 = 6;\n   i3 = minimo (i1, i2);\n   cout &lt;&lt; \"Piu' piccolo: \" &lt;&lt; i3 &lt;&lt; endl;\n   \n   double d1, d2, d3;\n   d1 = 7.9;\n   d2 = 32.1;\n   d3 = minimo (d1, d2);\n   cout &lt;&lt; \"Piu' piccolo: \" &lt;&lt; d3 &lt;&lt; endl;\n   \n   cout &lt;&lt; \"Piu' piccolo: \" &lt;&lt; minimo (d3, 3.5) &lt;&lt; endl;\n   \n   return 0;\n} \n\n\nPiu' piccolo: 6\nPiu' piccolo: 7.9\nPiu' piccolo: 3.5\n\n\nLa funzione minimo viene usata tre volte nel codice qui\nsopra, nondimeno il compilatore C++ genera solo 2 versioni di essa:\n\n\n  \n     int     minimo(int a   , int    b)\n  \n  \n     double  minimo(double a, double b)\n  \n\n\nQuesto e’ sufficiente per tutto il programma. Cosa sarebbe successo se\navessi provato a calcolare qualcosa del tipo\nminimo(i1,d1)? (ovvero mettendo un int come primo\ningresso e un double come secondo). Il compilatore avrebbe restituito un\nerrore. Questo perche’, nella forma scelta nell’esempio, nel\ntemplate entrambi i parametri hanno lo stesso tipo. In\ngenereale, fortunatamente, si puo’ usare un numero arbitrario di tipi\nquando si definisce un template che possono essere “tipi” standard\n(char, int, double,…) o definiti dall’utente. Qui\nsotto c’e’ un esempio dove la funzione minimo accetta parametri di\nqualunque tipo (differenti o identici tra loro) e restituisce un valore\ndi somma che ha lo stesso tipo del primo parametro:\n\nusing namespace std;\n#include &lt;iostream&gt;\ntemplate &lt;class type1, class type2&gt;  // tipe1 primo argomento, tipe2 secondo\ntype1 minimo (type1 a, type2 b)\n{\n   type1 r, b_convertito;      // dichiara un paio di oggetti di type1\n   r = a;                      // di base prende a come minimo il primo\n   b_convertito = (type1) b;   // fa un cast del secondo parametro nel tipo del primo\n   if (b_convertito &lt; a) r = b_convertito; // controlla se il secondo e' minore\n   return r;\n}\nint main ()\n{\n   int i;\n   double d;\n   i = 45;\n   d = 7.41;\n   \n   cout &lt;&lt; \"Piu' piccolo: \" &lt;&lt; minimo (i, d) &lt;&lt; endl;     // int    vs double\n   cout &lt;&lt; \"Piu' piccolo: \" &lt;&lt; minimo (d, i) &lt;&lt; endl;     // double vs int\n   cout &lt;&lt; \"Piu' piccolo: \" &lt;&lt; minimo ('A', i) &lt;&lt; endl;   // char   vs int \n\n   return 0;\n}   \n\n\nPiu' piccolo: 7\nPiu' piccolo: 7.41\nPiu' piccolo: -\n\n\n(Si noti che il codice ASCII per il carattere ’-’ e’ 45, mentre il\ncodice di ’A’ e’ 65, quindi nel caso dell’operatore &lt; tra\nchar, converte automaticamente nel corrispondente\ncodice ASCII.\n\nE’ meglio usare NEW e DELETE per alloccare e dealloccare la memoria\n\nI comandi new e delete possono essere\nusati per alloccare e dealloccare la memoria. Sono in qualche modo piu’\npuliti rispetto alle funzioni malloc e\nfree del C standard. Si noti che per gli array si usano\ninvece:\n\n\n  \n    new []\n  \n  \n    delete []\n  \n\n\nusing namespace std;\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nint main ()\n{\ndouble *d;   // d e' una variabile il cui scopo\n             // e' di contenere l'indirizzo di\n             // memoria dove e' posto un double\n\nd = new double;  // new allocca una zona di memoria\n                 // grande abbastanza da contenere un double\n                 // e restituisce il suo indirizzo.\n                 // L'indirizzo e' qunidi messo in d.\n             \n*d= 45.3        // Il numero 45.3 e' messo \n                // nella zona di memoria, il cui\n                // indirizzo e' dato da d.\n\n\ncout &lt;&lt; \"Inserisci un numero: \";\ncin &gt;&gt; *d;\n*d = *d + 5;\ncout &lt;&lt; \"Risultato: \" &lt;&lt; *d &lt;&lt; endl;\n                \n                \ndelete d;  //  delete deallocca la zona \n           //  di memoria il cui indirizzo\n           //  e' dato dal puntatore d\n           //  quell'indirizzo non puo' piu' essere usato\n\n\n           \nd = new double[15] // allocca una zona per un array di 15 double\n                   // Nota che ognuno dei 15 double viene costruito.\n                   // In questo caso non serve, ma e' fondamentale\n                   // quando si usano dei tipi di dato\n                   // che necessitino che il loro constructor sia \n                   // usato per ogni istanza\n                   \nd[0]=4456;\nd[1]=d[0]+567;\n\ncout &lt;&lt; \"Contenuto di d[1]: \" &lt;&lt; d[1] &lt;&lt; endl;\n\ndelete [] d;       // delete [] distrugge la zona di memoria\n                   // Nota che ognuno dei 15 ingressi di tipo\n                   // double verra' distrutto. Anche in questo\n                   // caso, ora non e' importante, ma al momento in\n                   // cui verranno usati i destructor per le istanze\n                   // delle classi (il metodo ~). Se venisse usato\n                   // delete senza mettere le parentesi quadre\n                   // questo provocherebbe la dealloccazione della\n                   // zona di memoria, senza distruggere ognuna delle 15 istanze\n                   // Questo comportamento puo' causare un memory leakage.\n\nint n = 30;\nd = new double[n]; // new puo' essere usato per alloccare un array \n                   // dinamicamente, ad una grandezza n \nfor (int i = 0; i &lt; n; i++)\n{\n  d[i] = i;\n}\n                \ndelete [] d;\n\nchar *s;    \ns = new char[100];\n\nstrcpy (s, \"Ciao!\");\n\ncout &lt;&lt; s &lt;&lt; endl;\n\ndelete [] s;\n            \nreturn 0;\n}           \n\n\nInserisci un numero: 6\nRisultato: 11\nContenuto di d[1]: 5023\nCiao!\n\n\nSi possono mettere delle funzioni (metodi) in uno Struct o una Classe\n\nNel C standard, uno struct contiene solo dati. In C++,\nuno struct puo’ contenere anche delle funzioni. Queste\nfunzioni sono possedute dallo struct e sono pensate per\noperare sui dati dello struct stesso. Queste funzioni\nsono chiamate METODI. Nel seguito viene mostrato il\nmetodo superficie associato allo struct\nvettore:\n\nusing namespace std;\n#include &lt;iostream&gt;\nstruct vettore\n{\n   double x;\n   double y;\n   double superficie () // intesa come rettangolo di cui il vettore e' diagonale\n   {\n      double s;\n      s = x * y;\n      if (s &lt; 0) s = -s;\n      return s;\n   }\n};\nint main ()\n{\n   vettore a;\n   a.x = 3;\n   a.y = 4;\n \n   cout &lt;&lt; \"La superficie di a: \" &lt;&lt; a.superficie() &lt;&lt; endl;\n   return 0;\n} \n\n\nLa superficie di a: 12 \n\n\nNell’esempio qui sopra a e’ un’\nistanza dello struct “vettore”. (Si noti che il comando\n“struct” non era necessario quando si e’ dichiarato il\nvettore a).\n\nProprio come per le funzioni, un metodo puo’ essere un overload di\nqualsiasi operatore del C++, puo’ avere un numero arbitrario di\nparametri (ma uno di questi parametri e’ implicito: l’istanza su cui\nagisce), restituire qualunque tipo di parametri o nessuno (un metodo e’\nuna funzione…).\n\nClassi\n\n\n  \n    Cos’e’ una class (classe)?\n  \n  \n    Una classe e’ una struct che\nmantiene i propri dati nascosti.\n  \n  \n    solo i metodi della classe possono accedere ai dati. Non e’\npossibile accedere ai dati di una classe direttamente, a meno che\nquesti siano stati definiti tramite la direttiva:\npublic.\n  \n\n\nQui sotto c’e’ un esempio della definizione di una\nclasse, che si comporta esattamente come lo struct\nsopra perche’ i dati x e y sono\ndefiniti come public:\n\nusing namespace std;\n#include &lt;iostream&gt;\nclass vettore\n{\n   public:\n   double y;\n   double x;\n  \n   double superficie ()\n   {\n      double s;\n      s = x * y;\n      if (s &lt; 0) s = -s; \n      return s;\n   }\n};         \n\n\nint main ()\n{\n   vettore a;\n   a.x = 3;\n   a.y = 4;\n   cout &lt;&lt; \"La superficie di a: \" &lt;&lt; a.superficie() &lt;&lt; endl;\n   return 0;\n} \n\n\nLa superficie di a: 12 \n\n\nNell’esempio qui sopra, direttamente dal main e’\npossibile modificare i dati dell’istanza del vettore, usando:\n\n\n  \n    a.x=3\n  \n  \n    a.y=4\n  \n\n\nQuesto e’ stato possibile per la direttiva public:\nusata nella definizione della classe. L’uso della public e’\nconsiderata bad practice! si veda il Capitolo 30.\n\nAd un metodo e’ consentito cambiare le variabili dell’istanza su cui\nagisce:\n\nusing namespace std;\n#include &lt;iostream&gt;\nclass vettore\n{\n  public:\n  double x;    // parametri della classe (accessibili dall'esterno per il public)\n  double y;    // parametri della classe (             \"                        )\n\n  vettore costruisci_opposto() // metodo che RESTITUISCE l'opposto dell'istanza\n  {                            // nota che questo metodo ha un \"tipo\"\n     vettore r;                // e' proprio la stessa classe!  \n     r.x = -x;\n     r.y = -y;\n     return r; \n  }\n\n  void trasforma_in_opposto()    // metodo che TRASFORMA l'istanza nel suo opposto\n  {                      // e' un metodo VOID, non restituisce nulla!\n      x = -x;            // trasforma soltanto l'istanza su cui agisce \n      y = -y;\n  }\n  void da_calcolare (double a, double b, double c, double d) \n                        // metodo che MODIFICA l'istanza\n  {                     // (e' void)\n     x = a - c;         // ATTENZIONE non c'e' un return...\n     y = b - d;         // \n  }\n  \n  vettore operator * (double a) // overload del prodotto\n  {                      // occhio che non e' come un metodo normale\n     vettore r;          // in cui gli argomenti vanno messi tra tonde ()\n     r.x = x * a;        // l'istanza della classe va messa prima del *  \n     r.y = y * a;        // il double va messo dopo. NON si usano le parentesi\n     return r;           // crea una NUOVA istanza  \n  }\n};\n\nint main ()\n{\n   vettore a, b;\n   a.x = 3;\n   a.y = 5;\n   b = a.costruisci_opposto();\n   \n   cout &lt;&lt; \"Vector a: \" &lt;&lt; a.x &lt;&lt; \", \" &lt;&lt; a.y &lt;&lt; endl;\n   cout &lt;&lt; \"Vector b: \" &lt;&lt; b.x &lt;&lt; \", \" &lt;&lt; b.y &lt;&lt; endl;\n   \n   b.trasforma_in_opposto();\n   cout &lt;&lt; \"Vector b: \" &lt;&lt; b.x &lt;&lt; \", \" &lt;&lt; b.y &lt;&lt; endl;\n \n   a.da_calcolare (7, 8, 3, 2);\n   cout &lt;&lt; \"Vector a: \" &lt;&lt; a.x &lt;&lt; \", \" &lt;&lt; a.y &lt;&lt; endl;\n   a = b * 2;     // questo e' istruttivo, avendo fatto\n                  //l'OVERLOAD del *, il primo ingresso\n                  //sara' un vettore, il secondo un double\n                  // che era tra parentesi nella definizione del\n                  // metodo. Nessuno degli \"ingressi\" dell'\n                  // operatore, va messo tra parentesi (), si\n                  // continua ad usare il * come al solito\n   \n   cout &lt;&lt; \"Vector a: \" &lt;&lt; a.x &lt;&lt; \", \" &lt;&lt; a.y &lt;&lt; endl;\n   a = b.costruisci_opposto() * 2;\n   \n   cout &lt;&lt; \"Vector a: \" &lt;&lt; a.x &lt;&lt; \", \" &lt;&lt; a.y &lt;&lt; endl;\n   cout &lt;&lt; \"x dell'opposto di a: \" &lt;&lt; a.trasforma_in_opposto().x &lt;&lt; endl;\n   \n   return 0;\n} \n\n\nVector a: 3, 5\nVector b: -3, -5\nVector b: 3, 5\nVector a: 4, 6\nVector a: 6, 10\nVector a: -6, -10\nx dell'opposto di a: 6 \n\n\nConstructor e destructor: inizializzare e distruggere istanze di una classe\n\nEsistono dei metodi speciali ed essenziali che sono i:\n\n\n  \n    constructor (costruttore)\n  \n  \n    destructor (distruttore)\n  \n\n\nQuesti metodi vengono chiamati automaticamente nei seguenti casi:\n\n\n  \n    al momento di creazione di un’istanza della classe (p.es. con un\nnew)\n  \n  \n    al momento di distruzione di un’istanza della classe (con un\ndelete)\n  \n  \n    alla fine del programma\n  \n  \n    …\n  \n\n\nIl costruttore (constructor) (e’ un metodo con lo\nstesso nome della classe):\n\n\n  \n    inizializzera’ le variabili dell’istanza\n  \n  \n    fara’ dei calcoli (definiti nella classe)\n  \n  \n    allocchera’ della memoria\n  \n  \n    mandera’ a video delle scritte\n  \n  \n    …\n  \n\n\nIn generale il costruttore viene scritto per fare tutto quello che e’\nnecessario per la classe. Nel seguito vediamo un esempio della\ndefinizione di una classe con due costruttori di cui viene fatto\nl’overload (sono funzioni… quindi si puo’ fare l’overload dei\ncostruttori):\n\nusing namespace std;\n#include &lt;iostream&gt;\nclass vettore\n{\n   public:\n   double x;\n   double y;\n\n   vettore ()  // questo e' un costruttore, lo si riconosce \n   {          // perche' ha lo stesso NOME della classe\n      x = 0;  // se viene fatta una istanza senza indicare\n      y = 0;  // le componenti, questo le mette a 0 di default\n   }\n\n   vettore (double a, double b) // anche questo e' un costruttore \n   {                           // ed e' un overload, perche' questo\n       x = a;                  // viene chiamato con 2 argomenti  \n       y = b;                  // in particolare 2 double\n   }                           // che diventeranno le componenti \n};\n\nint main ()\n{\n   vettore k;            // il costruttore vettore () viene chiamato\n   cout &lt;&lt; \"vettore k: \" &lt;&lt; k.x &lt;&lt; \", \" &lt;&lt; k.y &lt;&lt; endl &lt;&lt; endl;\n   \n   vettore m (45, 2);    // qui viene chiamato vettore (double, double)\n   cout &lt;&lt; \"vettore m: \" &lt;&lt; m.x &lt;&lt; \", \" &lt;&lt; m.y &lt;&lt; endl &lt;&lt; endl;\n   \n   k = vettore (23, 2); // viene creato un vettore, copiato  in k,\n                        // e poi cancellato \n                        // perche' viene cancellato? perche' finisce l'esecuzione\n   cout &lt;&lt; \"vettore k: \" &lt;&lt; k.x &lt;&lt; \", \" &lt;&lt; k.y &lt;&lt; endl &lt;&lt; endl;\n   \n   return 0;\n}\n\n\nvettore k: 0, 0\n\nvettore m: 45, 2\n\nvettore k: 23, 2 \n\n\nLa buona pratica di scrittura di un codice suggerisce di non fare\nl’overload dei costruttori. Sarebbe meglio dichiarare solo un\ncostruttore e dargli dei valori di default quando possibile.\n\nusing namespace std;\n#include &lt;iostream&gt;\nclass vettore\n{\n   public:\n   double x;\n   double y;\n   \n   vettore (double a = 0, double b = 0)\n   {\n      x = a;\n      y = b;\n   }\n};\n\nint main ()\n{\n   vettore k;\n   cout &lt;&lt; \"vettore k: \" &lt;&lt; k.x &lt;&lt; \", \" &lt;&lt; k.y &lt;&lt; endl &lt;&lt; endl;\n\n   vettore m (45, 2);\n   cout &lt;&lt; \"vettore m: \" &lt;&lt; m.x &lt;&lt; \", \" &lt;&lt; m.y &lt;&lt; endl &lt;&lt; endl;\n   \n   vettore p (3);\n   cout &lt;&lt; \"vettore p: \" &lt;&lt; p.x &lt;&lt; \", \" &lt;&lt; p.y &lt;&lt; endl &lt;&lt; endl;\n   return 0;\n}   \n\n\nvettore k: 0, 0\n\nvettore m: 45, 2\n\nvettore p: 3, 0 \n\n\nIl distruttore e’ spesso non necessario. Puo’ essere usato per fare dei\ncalcoli quando l’istanza viene distrutta o per mandare a video dei testi\nper il debug. Se pero’ le variabili dell’istanza puntano a qualche area\ndi memoria alloccata, allora il ruolo del distruttore e’ essenziale:\ndeve liberare la memoria! Qui vediamio un esempio di un\ntale utilizzo:\n\nusing namespace std;\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nclass persona\n{\n   public:\n   char *name;\n   int anni;\n   persona (char *n = \"nessun nome\", int a = 0)  // costruttore\n   {\n      nome = new char [100];  // new e' meglio di malloc!\n      strcpy (name, n);\n      anni = a;\n      cout &lt;&lt; \"Instanza inizializzata, 100 bytes allocati\" &lt;&lt; endl;\n   }\n   ~persona ()  // DISTRUTTORE, c'e' la ~ davanti al nome!\n   {\n       delete [] nome; // invece che un semplice free, uso delete\n                       // si noti che potrebbe funzionare con un\n                       // semplice delete senza  le [], questo \n                       // perche' l'array non contiene C++ sub-oggetti\n                       // che debbano essere cancellati. Pero', visto che\n                       // il comportamento senza le [] non e' definito, e'\n                       // meglio andare sul sicuro e mettere le quadre.\n\n       cout &lt;&lt; \"L'istanza viene rimossa, 100 byte vengono liberati\" &lt;&lt; endl;\n   }\n};        // fine della definizione della classe\n\n\n\nint main ()\n{\n   cout &lt;&lt; \"Ciao!\" &lt;&lt; endl &lt;&lt; endl;\n   persona a;\n   \n   cout &lt;&lt; a.nome &lt;&lt; \", anni \" &lt;&lt; a.anni &lt;&lt; endl &lt;&lt; endl;\n   persona b (\"John\");\n   \n   cout &lt;&lt; b.nome &lt;&lt; \", anni \" &lt;&lt; b.anni &lt;&lt; endl &lt;&lt; endl;\n                       \n   b.anni = 21;\n   cout &lt;&lt; b.nome &lt;&lt; \", anni \" &lt;&lt; b.anni &lt;&lt; endl &lt;&lt; endl;\n   \n   persona c (\"Miki\", 45);\n   \n   cout &lt;&lt; c.nome &lt;&lt; \", anni \" &lt;&lt; c.anni &lt;&lt; endl &lt;&lt; endl;\n   cout &lt;&lt; \"Ciao ciao!\" &lt;&lt; endl &lt;&lt; endl;\n   \n   return 0;\n}\n \n\n\nCiao!\n\nL'istanza viene inizializzata, 100 byte allocati\nnessun nome, anni 0\n\nL'istanza viene inizializzata, 100 byte allocati\nJohn, anni 0\n\nJohn, anni 21\n\nL'istanza viene inizializzata, 100 byte alloccati\nMiki, anni 45\n\nCiao ciao!\n\nL'istanza viene rimossa, 100 byte vengono liberati\nL'istanza viene rimossa, 100 byte vengono liberati\nL'istanza viene rimossa, 100 byte vengono liberati\n\n\nQui invece verra’ mostrato un breve esempio di una definizione di una\nclasse chiamata “array”. C’e’ poi un metodo che e’ un overload\ndell’operatore [] e restituisce come valore una\nreferenza (&amp;) ed e’ usato per generare un errore se si\ntenta di accedere a dati al di fuori dei limiti dell’array.\n\nusing namespace std;\n#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\nclass array\n{\n   public:\n   int size;\n   double *data;\n   array (int s)\n   {\n      size = s;\n      data = new double [s];\n   }\n   ~array ()\n   {\n      delete [] data;\n   }\n   \n   double &amp;operator [] (int i) // overload dell'operatore []\n   {                           // restituisce un double \n      if (i &lt; 0 || i &gt;= size)  // ha come parametro di ingresso un intero\n      {\n          cerr &lt;&lt; endl &lt;&lt; \"Fuori dai limiti\" &lt;&lt; endl;\n          exit (EXIT_FAILURE);\n      }\n      else return data [i];\n   }\n};\n\n\nint main ()\n{\n   array t (5);         // OK\n   t[0] = 45;           // Ok\n   t[4] = t[0] + 6;     // Ok \n   \n   cout &lt;&lt; t[4] &lt;&lt; endl;\n   \n   t[10] = 7;           // ERRORE!\n    \n   return 0;\n}\n \n\n\n 51\n \n Fuori dai limiti\n\n\nCOPY constructor e l’overload dell’operatore “=” per copiare istanze\n\nSe si copia un oggetto come un vettore, non c’e’ nessun problema. Per\nesempio, se si ha il vettore k, di coordinate\n(4,7), dopo averlo copiato m=k, il\nvettore m conterra’ anche lui coordinate\n(4,7). I valori di k.x e\nk.y sono stati semplicemente copiati in\nm.x e m.y.\n\nSupponiamo ora che si stia usando un oggetto come la classe\npersona definita precedentemente. Questo tipo di\noggetti contiene un puntatore ad una stringa di\ncaratteri. Se si fa la copia dell’oggetto persona\nscrivendo p=r diventa necessario che qualche funzione\nsi incarichi di produrre una copia corretta da p a\nr. Altrimenti, p.nome puntera’ alla\nstessa stringa di r.nome.\n\nInoltre la precedente stringa puntata da p.nome e’\npersa e diventa un o zombi di memoria. Il risultato sarebbe\ncatastrofico, un disastro di puntatori e dati persi. I metodi che\nrisolvono questo tipo di problemi sono:\n\n\n  \n    COPY constructor\n  \n  \n    un overload dell’operatore =\n  \n\n\nusing namespace std;\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nclass persona\n{\n   public:\n   char *name;\n   int anni;\n   persona (char *n = \"nessun nome\", int a = 0)  // costruttore\n   {\n      name = new char[100];\n      strcpy (name, n);\n      anni = a;\n   }\n   \n   persona (const persona &amp;s)  // l'argomento di constructor e' un oggetto \n   {                           // di tipo \"persona\"\n      name = new char[100];    // allocca della nuova memoria\n      strcpy (name, s.nome); // copia il nome dell'oggetto passato come nuovo nome\n      anni = s.anni;    // mette come eta' quella della \"persona\" in argomento  \n   }\n   \n   persona&amp; operator= (const persona &amp;s) // overload dell' =, restituisce \n   {                                     // un oggetto di tipo persona e prende\n      strcpy (name, s.nome);             // come argomento un oggetto persona\n      anni = s.anni;                     // associa l'eta' dell'argomento\n      return *this;                // restituisce l'istanza appena costruita\n    }\n    \n    ~persona ()  // DISTRUTTORE\n    {\n       delete [] name;            // l'unica quantita' alloccata era per il nome\n    }\n};            \n\n\nvoid modifica_persona (persona&amp; h)  // nota che questa e' una funzione\n                                    // NON e' un metodo!\n{                                  \n   h.anni += 7;               // semplicemente modifica la \"persona\" passata\n}\n\npersona calcola_persona (persona h) \n{                                     \n   h.anni += 7;\n   return h;\n}\n\n \nint main ()\n{\n   persona p;\n   cout &lt;&lt; p.nome &lt;&lt; \", anni \" &lt;&lt; p.anni &lt;&lt; endl &lt;&lt; endl;\n   // output: nessun nome, anni 0\n   \n   persona k (\"John\", 56);\n   cout &lt;&lt; k.nome &lt;&lt; \", anni \" &lt;&lt; k.anni &lt;&lt; endl &lt;&lt; endl;\n   // output: John, anni 56\n   \n   p = k;\n   cout &lt;&lt; p.nome &lt;&lt; \", anni \" &lt;&lt; p.anni &lt;&lt; endl &lt;&lt; endl;\n   // output: John, anni 56\n   \n   p = persona (\"Bob\", 10);\n   cout &lt;&lt; p.nome &lt;&lt; \", anni \" &lt;&lt; p.anni &lt;&lt; endl &lt;&lt; endl;\n   // output: Bob, anni 10 \n   \n   // Ne il copy constructor ne l'overload \n   // dell' = sono necessari per l'operazione che modifica \n   // p dato (che faremo qui sotto) che solo la referenza verso p\n   // e' passata alla funzione modifica_persona   \n   modifica_persona (p);\n   \n   cout &lt;&lt; p.nome &lt;&lt; \", anni \" &lt;&lt; p.anni &lt;&lt; endl &lt;&lt; endl;\n   // output: Bob, anni 17\n   \n   // Il copy constructor e' chiamato per passare una\n   // copia completa di p alla funzione calcola_persona.\n   // La funzione usa quella copia per fare i suoi calcoli\n   // poi una copia di quella copia modificata viene fatta per \n   // restituire i risultati. In fine l'overload dell'=\n   // viene chiamato per incollare la seconda copia dentro k\n   \n   k = calcola_persona (p);\n   cout &lt;&lt; p.nome &lt;&lt; \", anni \" &lt;&lt; p.anni &lt;&lt; endl &lt;&lt; endl;\n   // output: Bob, anni 17\n   \n   cout &lt;&lt; k.nome &lt;&lt; \", anni \" &lt;&lt; k.anni &lt;&lt; endl &lt;&lt; endl;\n   // output: Bob, anni 24\n   \n   return 0;\n}\n\n\nnessun nome, anni 0\n\nJohn, anni 56\n\nJohn, anni 56\n\nBob, anni 10\n\nBob, anni 17\n\nBob, anni 17\n\nBob, anni 24\n\n\nIl copy constructor consente al programma di fare copie delle istanze\nquando ci sono dei calcoli. E’ un metodo chiave. Durante i calcoli, le\nistanze sono create per mantenere i riultati intermedi. Sono modificate,\ncopiate e distrutte senza che il programmatore lo noti. Questo e’ il\nmotivo per cui questi metodi sono utili anche per oggetti semplici (vedi\nCapitolo 14).\n\nIn tutti gli esempi sopra, i metodi sono definiti all’interno delle\ndefinizioni delle classi. Questo implica che sono automaticamente dei\nmetodi inline.\n\nPrototipi: definire i metodi sotto la definizione di una classe\n\nConsideriamo i seguenti casi:\n\n\n  \n    se un metodo non puo’ essere inline (per esempio perche’ ha un loop\nal suo interno)\n  \n  \n    se non si vuole che il metodo diventi inline (per non ingrandire\ntroppo l’eseguibile)\n  \n  \n    se si vuole che la definizione di una classe contenga solo un\n“riassunto” dei metodi in modo che sia leggibile\n  \n  \n    se, semplicemente, si vuole separare l’header file .h dal sorgente\n.cpp\n  \n\n\nallora:\n\n\n  \n    nella classe si inserisce solo il prototipo\n(prototype) del metodo\n  \n  \n    il metodo stesso va definito sotto la definizione\ndella classe stessa o in un file sorgente .cpp separato\n  \n\n\nusing namespace std;\n#include &lt;iostream&gt;\nclass vettore\n{\n   public:\n   double x;\n   double y;\n\n   double superficie(); // il ; e il fatto che non ci siano {} mostra che e' un prototipo\n};                      // &lt;=== fine della definizione della classe \n\n\ndouble vettore::superficie()  // qui sotto definisco esplicitamente il metodo\n{\n   double s = 0;\n   for (double i = 0; i &lt; x; i++)\n   {\n      s = s + y;  // e' una specie di modo per fare il prodotto\n   }\n   return s;\n}\n\n\nint main ()\n{\n   vettore k;\n   k.x = 4;\n   k.y = 5;\n   \n   cout &lt;&lt; \"Superficie: \" &lt;&lt; k.superficie() &lt;&lt; endl;\n   return 0;\n}\n\n\nSuperficie: 20 \n\n\nPer chi e’ alle prime armi\n\nSe volete sviluppare un codice C o C++ serio, avete bisogno di separare\nil file sorgente in:\n\n\n  \n    uno (o piu’) file header .h\n  \n  \n    uno (o piu’) file sorgente .cpp\n  \n\n\nQui c’e’ un breve esempio di come questo viene fatto. Il programma qui\nsopra viene diviso in 3 file:\n\n\n  \n    vettore.h contenente la classe e i prototipi dei\nmetodi\n  \n  \n    vettore.cpp dove vengono definiti i metodi della\nclasse vettore\n  \n  \n    main.cpp dov c’e’ il main\n  \n\n\nil file header vettore.h e’:\n\nclass vettore\n{\n   public:\n   double x; \n   double y;\n\n   double superficie();\n}; \n\n\nIl file sorgente vettore.cpp:\n\nusing namespace std;\n#include \"vettore.h\"\ndouble vettore::superficie()\n{\n   double s = 0;\n   for (double i = 0; i &lt; x; i++)\n   {\n      s = s + y;\n   }\n   return s;\n}\n\n\ned infine un nuovo file sorgente chiamato main.cpp\n\nusing namespace std;\n#include &lt;iostream&gt;\n#include \"vettore.h\"\nint main ()\n{\n   vettore k;\n   k.x = 4;\n   k.y = 5;\n   cout &lt;&lt; \"Superficie: \" &lt;&lt; k.superficie() &lt;&lt; endl;\n   return 0;\n} \n\n\nSe si assume che il file vettore.cpp sia perfetto,\nallora abbiamo bisogno di compliarlo una volta sola in un file\n.o (un “object file”), tramite il comando (per\nesempio):\n\ng++ -c vettore.cpp\n\n\n(che produce un file vettore.o).\n\nOgni volta che il file main.cpp viene modifcato, va\ncompilato in un file eseguibile, per esempio chiamato\ntest20, per fare questo bisogna dire esplicitamente al\ncompilatore che deve “linkare” l’oggetto vettore.o\nall’interno dell’esegubile test20:\n\ng++ main.cpp vettore.o -o test20 \n\n\nL’eseguibile (su macchine tipo Unix) viene fatto “girare” con:\n\n ./test20\n\n\nQuesto procedimento ha un certo numero di vantaggi:\n\n\n  \n    Il codice sorgente vettore.cpp deve essere compilato solo una\nvolta. Questo fa risparmiare molto tempo nei progetti grandi (fare\nil “linking” del file vettore.o nell’eseguibile test20 e’\nmolto veloce).\n  \n  \n    E’ possibile passare i file .h e i .o. In questo modo possono\nusare il tuo programma ma non cambiarlo perche’ non hanno i file\n.cpp (non fidarti molto di questo, aspetta fino a quando avrai una\ncomprensione piena di questi problemi).\n  \n\n\nSi noti che e’ possibile compilare anche il file main.cpp in un file\ndi tipo “object” e poi linkarlo con vettore.o:\n\n g++ -c main.cpp\n \n g++ main.o vettore.o test20\n\n\nMAKEFILE\n\nQui viene fatta una digressione rispetto all’argomento “differenze tra C\ne C++”. Se si vuole apparire come veri programmatori, si dovrebbe\ncondensare i comandi qui sopra in un Makefile e compilare usando il\ncomando make. Il contenuto del file sotto e’ una versione super\nsemplificata di un tale Makefile. Prova a copiarlo in un file chiamato\nproprio Makefile. Attenzione nota che, ed e’ molto importante, lo\nspazio tra i comandi del g++ deve obbligatoriamente\nessere un Tab. Non usare lo spazio, usa invece il carattere di\ntabulazione (tutto a sinistra di una tastiera internazionale sopra il\ncaps lock).\n\ntest20: main.o vettore.o\n        g++ main.o vettore.o -o test20\n        \nmain.o: main.cpp vettore.h\n        g++ -c main.cpp\n        \nvettore.o: vettore.cpp vettore.h\n          g++ -c vettore.cpp\n\n\nPer utilizzare questo Makefile per compilare, e’ sufficiente usare\nquesto comando:\n\nmake test20\n\n\nIl comando make fara’ un “parse” (legge i comandi parola per\nparola) attraverso il Makefile e capira’ quello che deve essere fatto.\nAll’inizio, viene detto che:\n\n\n  \n    test20 dipende da main.o e vettore.o\n  \n  \n    a questo punto lancera’ automaticamente make main.o e\nmake vettore.o\n  \n  \n    poi controllera’ se test20 esiste gia’ e controllera’\nse la data di creazione dei file main.o e\nvettore.o e’ precedente a test20. Nel caso in cui il comando\nmake determini che la versione corrente di test20 e’ aggiornata\nnon fara’ nulla e dira’ che non ha fatto nulla.\n  \n  \n    altrimenti se test20 non esiste, oppure main.o o vettore.o\nsono piu’ recenti di test20 il comando creera’ una versione\naggiornata di test20, eseguendo: g++ main.o vettore.o -o test20\n  \n\n\nLa versione di seguito del Makefile e’ piu’ vicina allo “standard”\nMakefile:\n\nall: test20\n\ntest20: main.o vettore.o\n        g++ main.o vettore.o -o test20\n        \nmain.o: main.cpp vettore.h\n        g++ -c main.cpp\n        \nvettore.o: vettore.cpp vettore.h\n        g++ -c vettore.cpp\n          \nclean:  \n        rm -f *.o test20 *~ #* \n\n\nSi fa partire la compilazione con il comando make.\n\n\n  la prima linea nel Makefile implica che se scrivi solo make, in\nrealta’ intendi: make  test20\n\n\nSe si usa il comando seguente, tutti i file prodotti durante la\ncompilazione e tutti i file di testo di backup verranno cancellati:\n\nmake clean \n\n\nThis: per puntare all’istanza su cui sta agendo un metodo\n\nQuando un metodo e’ applicato ad un’istanza, quel metodo puo’ usare le\nvariabili dell’istanza e modificarle… ma alle volte e’ necessario\nconoscere l’indirizzo di un’istanza. Nessun problema, il comando\nthis serve proprio a questo scopo:\n\nusing namespace std;\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\nclass vettore\n{\n   public:\n   double x;\n   double y;\n   \n   vettore (double a = 0, double b = 0)\n   {\n      x = a;\n      y = b;\n   }\n   \n   double modulo()\n   {\n      return sqrt (x * x + y * y);\n   }\n   \n   void definisci_lunghezza (double a = 1)\n   {\n      double lunghezza;\n      \n      lunghezza = this-&gt;modulo(); // fa il il modulo di QUESTA istanza\n      \n      x = x / lunghezza * a;\n      y = y / lunghezza * a;\n   }\n};\n\nint main ()\n{\n   vettore c (3, 5);\n   cout &lt;&lt; \"Il modulo del vettore c: \" &lt;&lt; c.modulo() &lt;&lt; endl;\n   \n   c.definisci_lunghezza(2);       // Transforma c in un vettore di lunghezza 2.\n   cout &lt;&lt; \"Il modulo del vettore c:\" &lt;&lt; c.modulo() &lt;&lt; endl;\n   \n   c.definisci_lunghezza();        // Transforma b in un vettore unitario.\n   cout &lt;&lt; \"Il modulo del vettore c: \" &lt;&lt; c.modulo() &lt;&lt; endl;\n   \n   return 0;\n}\n \n\n\nIl modulo del vettore c: 5.83095\nIl modulo del vettore c: 2\nIl modulo del vettore c: 1 \n\n\nArray di istanze di classi\n\nOvviamente e’ possibile dichiarare degli oggetti che sono array di\nclassi:\n\nusing namespace std;\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\nclass vettore\n{\n   public:\n   double x; \n   double y;\n\n   vettore (double a = 0, double b = 0)\n   {\n      x = a;\n      y = b;\n   }\n   \n   double modulo ()\n   {\n      return sqrt (x * x + y * y);\n   }\n};\n\nint main ()\n{\n   vettore s [1000];\n   vettore t[3] = {vettore(4, 5), vettore(5, 5), vettore(2, 4)};\n   \n   s[23] = t[2];\n   cout &lt;&lt; t[0].modulo() &lt;&lt; endl;\n   return 0;\n}\n\n\n6.40312 \n\n\nEsempio di dichiarazione di una classe\n\nusing namespace std;\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\nclass vettore\n{\n  public:\n     double x;\n     double y;\n\n     vettore (double = 0, double = 0);  // questo e' il costruttore\n     vettore operator + (vettore);      // overload del +  \n     vettore operator - (vettore);      // overload del -\n     vettore operator - ();        // overload del - davanti alla classe stessa   \n     vettore operator * (double a);// overload del * prodotto per uno scalare    \n     double modulo();              // metodo per calcolare il modulo della classe\n     void definisci_lunghezza (double = 1); // modifica il modulo della classe   \n};\n\n\nvettore::vettore (double a, double b)    // specifico cosa fa il costruttore\n{\n  x = a;\n  y = b;\n}\n\nvettore vettore::operator + (vettore a)   // specifico l'overload del +\n{\n   return vettore (x + a.x, y + a.y);\n}\n\nvettore vettore::operator - (vettore a)   // specifico l'overload del -\n{\n   return vettore (x - a.x, y - a.y);\n}\n\nvettore vettore::operator - ()   // se tra parentesi non c'e' nulla, allora \n{                                // l'operatore va messo davanti alla istanza\n   return vettore (-x, -y);      // su cui deve agire\n}\n\nvettore vettore::operator * (double a)   // overload del * per fare prodotto per scalare\n{\n   return vettore (x * a, y * a);\n}\n\ndouble vettore::modulo()          // nota che questo metodo ha un tipo e un \n{                                 // HA un valore di return \n   return sqrt (x * x + y * y);        \n}\n\nvoid vettore::definisci_lunghezza (double a) // questo metodo invece e' void, e   \n{                                            // NON ha un valore di return \n   double lunghezza = this-&gt;modulo();\n   x = x / lunghezza * a;  \n   y = y / lunghezza * a;\n}\n\nostream&amp; operator &lt;&lt; (ostream&amp; o, vettore a) // questo NON e' un metodo\n{                                            // infatti non era tra i\n   o &lt;&lt; \"(\" &lt;&lt; a.x &lt;&lt; \", \" &lt;&lt; a.y &lt;&lt; \")\";    // prototipi\n   return o;\n}\n\nint main ()\n{\n   vettore a;         \n   vettore b;\n   vettore c (3, 5);\n   \n   a = c * 3;\n   a = b + c;\n   c = b - c + a + (b - a) * 7;\n\n   c = -c;\n   \n   cout &lt;&lt; \"Il modulo del vettore c: \" &lt;&lt; c.modulo() &lt;&lt; endl;\n   cout &lt;&lt; \"Il contenuto del vettore a: \" &lt;&lt; a &lt;&lt; endl;\n   cout &lt;&lt; \"L'opposto del vettore a: \" &lt;&lt; -a &lt;&lt; endl;\n   \n   c.definisci_lunghezza(2);   // Transforma c in un vettore di modulo 2\n   \n   a = vettore (56, -3);\n   b = vettore (7, c.y);\n   b.definisci_lunghezza();    // Transforma b in un vettore unitario\n   \n   cout &lt;&lt; \"Il contenuto del vettore b: \" &lt;&lt; b &lt;&lt; endl;\n   \n   double k;\n   \n   k = vettore(1, 1).modulo(); // k conterra' 1.4142 (=radice di 2)\n   cout &lt;&lt; \"k contiene: \" &lt;&lt; k &lt;&lt; endl;\n   return 0;\n}\n\n\nIl modulo del vettore c: 40.8167\nIl contenuto del vettore a: (3, 5)\nL' opposto del vettore a: (-3, -5)\nIl contenuto del vettore b: (0.971275, 0.23796)\nk contiene: 1.41421 \n\n\nE’ altresi’ possibile definire una funzione che produca la somma di due\noggetti vettore senza che questo venga menzionato all’interno della\ndefinizione della classe. In questo caso non sara’ un metodo della\nclasse, ma piuttosto una funzione che usa vettori:\n\nvettore operator + (vettore a, vettore b)\n{\nreturn vettore (a.x + b.x, a.y + b.y);\n} \n\n\nNell’esempio delle definizione della classe vettore qui sopra e’\ndefinita la moltiplicazione di un vettore per un double. Supponiamo di\nvolere la moltiplicazione di un double per un vettore. In questo caso\ndobbiamo scrivere una funzione isolata fuori dalla classe:\n\nvettore operator * (double a, vettore b)\n{\nreturn vettore (a * b.x, a * b.y);\n} \n\n\nChiaramente le keyword new e delete\nfunzionano anche per le istanze delle classi. In piu’,\nnew automaticamente chiama il constructor per\ninizializzare gli oggetti, e delete automaticamente\nchiama il destructor prima di dealloccare la memoria delle variabili\ndell’istanza come:\n\nusing namespace std;\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\nclass vettore\n{\n   public:\n   double x;\n   double y;\n\n   vettore (double = 0, double = 0);\n   vettore operator + (vettore);\n   vettore operator - (vettore);\n   vettore operator - ();\n   vettore operator * (double);\n   \n   double modulo();\n   void definisci_lunghezza (double = 1);\n};\n\nvettore::vettore (double a, double b)\n{\n   x = a;\n   y = b;\n}\n\nvettore vettore::operator + (vettore a)\n{\n   return vettore (x + a.x, y + a.y);\n}\n\nvettore vettore::operator - (vettore a)\n{\n   return vettore (x - a.x, y - a.y);\n}\n\nvettore vettore::operator - ()\n{\n   return vettore (-x, -y);\n}\n\nvettore vettore::operator * (double a)\n{\n   return vettore (a * x, a * y);\n}\n\ndouble vettore::modulo()\n{\n   return sqrt (x * x + y * y);\n}\n\nvoid vettore::definisci_lunghezza (double a)\n{\n   vettore &amp;il_vettore = *this;\n   double lunghezza = il_vettore.modulo();\n   x = x / lunghezza * a;\n   y = y / lunghezza * a;\n}\n\nostream&amp; operator &lt;&lt; (ostream&amp; o, vettore a)\n{\n   o &lt;&lt; \"(\" &lt;&lt; a.x &lt;&lt; \", \" &lt;&lt; a.y &lt;&lt; \")\";\n   return o;\n}\n\nint main ()\n{\n   vettore c (3, 5);\n   vettore *r;     // r e' un puntatore a vettore.\n   r = new vettore;//  new alloccca la memoria necessaria\n                   // per contenere le variabili di vettore,\n                   // chiama il costruttore che le \n                   // inizializza a 0, 0. Infine \n                   // new restituisce l'indirizzo dell'istanza di vettore \n                   \n   cout &lt;&lt; *r &lt;&lt; endl;                \n                   \n   r-&gt;x = 94;\n   r-&gt;y = 345;\n   cout &lt;&lt; *r &lt;&lt; endl;\n\n   *r = vettore (94, 343);\n   cout &lt;&lt; *r &lt;&lt; endl;\n   \n   *r = *r - c;\n   r-&gt;definisci_lunghezza(3);\n   cout &lt;&lt; *r &lt;&lt; endl;\n   \n   *r = (-c * 3 + -*r * 4) * 5;\n   cout &lt;&lt; *r &lt;&lt; endl;\n   delete r;  // Chiama il distruttore di vettore \n              // poi libera la memoria.\n              \n   r = &amp;c;    // r punta verso il vettore c\n   cout &lt;&lt; *r &lt;&lt; endl;\n   r = new vettore (78, 345);  // Crea un nuovo vettore.\n   cout &lt;&lt; *r &lt;&lt; endl;         // Il costruttore  inizializzera'\n                               // la x e la y di vettore a 78 and 345\n                               \n   cout &lt;&lt; \"componente x di r: \" &lt;&lt; r-&gt;x &lt;&lt; endl;\n   cout &lt;&lt; \"componente y di r: \" &lt;&lt; (*r).x &lt;&lt; endl;\n   \n   delete r;\n   r = new vettore[4];  // crea un array di 4 vettore\n   r[3] = vettore (4, 5);\n   cout &lt;&lt; r[3].modulo() &lt;&lt; endl;\n   delete [] r;         // cancella l'array\n   \n   int n = 5;\n   r = new vettore[n];  // bello!\n   r[1] = vettore (432, 3);\n   cout &lt;&lt; r[1] &lt;&lt; endl;\n   delete [] r;\n   \n   return 0;\n}\n\n\n(0, 0)\n(94, 345)\n(94, 343)\n(0.77992, 2.89685)\n(-60.5984, -132.937)\n(3, 5)\n(78, 345)\ncomponente y di r: 78\ncomponente x di r: 78\n6.40312\n(432, 3) \n\n\nVariabili “static” in una classe\n\nUna o piu’ variabili in una classe possono essere dichiarate\nstatic. In questo caso:\n\n\n  \n    esiste una sola istanza di una variabile static\n  \n  \n    questa variabile e’ condivisa da tutte le istanze\ndella classe\n  \n  \n    questa variabile deve essere inizializzata fuori\ndalla dichiarazione della classe (e puo’ essere modificata)\n  \n\n\nusing namespace std;\n#include &lt;iostream&gt;\nclass vettore\n{\n   public:\n      double x;\n      double y;\n      static int count;   // &lt;= count e' una variabile STATIC\n      \n      vettore (double a = 0, double b = 0)  // COSTRUTTORE\n      {\n         x = a;\n         y = b;\n         count++;  // ogni volta che viene chiamato, si aggiunge 1 a count\n      }\n      \n      ~vettore()    // DISTRUTTORE\n      {\n         count--;  // ogni volta che viene chiamato si toglie 1 a count\n      }\n};\n\nint vettore::count = 0; // Inizializzazione FUORI \n                        // dalla definizione della classe\n\nint main ()\n{\n   cout &lt;&lt; \"Quanti vettore ci sono:\" &lt;&lt; endl;\n   \n   vettore a;    // istanza di vettore, il costruttore aggiunge 1 a count!      \n   cout &lt;&lt; vettore::count &lt;&lt; endl; \n   \n   vettore b;   // altra istanza, count diventa 2!\n   cout &lt;&lt; vettore::count &lt;&lt; endl;\n   \n   vettore *r, *u;  // due puntatori, il costruttore NON e' ancora chiamato\n   r = new vettore; // new chiama il costruttore, count diventa 3\n   cout &lt;&lt; vettore::count &lt;&lt; endl;\n   \n   u = new vettore; // new chiama il costruttore, count diventa 4\n   cout &lt;&lt; a.count &lt;&lt; endl;\n   delete r;       // delete chiama il DISTRUTTORE, count diventa 3\n   cout &lt;&lt; vettore::count &lt;&lt; endl;\n   \n   delete u;       // altro delete, count diventa 2\n   cout &lt;&lt; b.count &lt;&lt; endl;\n\n   return 0;\n} \n\n\nQuanti vettore ci sono:\n1\n2\n3\n4\n3\n2\n\n\nVariabili “const” in una classe\n\nUn tipo diverso di variabile e’ la const. Una variabile\nconst:\n\n\n  \n    viene definita all’interno della classe\n  \n  \n    non puo’ piu’ essere modificata\n  \n\n\nusing namespace std;\n#include &lt;iostream&gt;\nclass vettore\n{\n   public:\n      double x;\n      double y;\n      const static double pi = 3.1415927; // &lt;= pi greco non puo' essere modificato\n      \n      vettore (double a = 0, double b = 0)\n      {\n         x = a;\n         y = b;\n      }\n      \n      double cylinder_volume ()\n      {\n         return x * x / 4 * pi * y;\n      }\n};\n\nint main()\n{\n   cout &lt;&lt; \"Il valore di pi greco: \" &lt;&lt; vettore::pi &lt;&lt; endl &lt;&lt; endl;\n   \n   vettore k (3, 4);  \n   cout &lt;&lt; \"Risultato: \" &lt;&lt; k.cylinder_volume() &lt;&lt; endl;\n   return 0;\n}\n\n\nIl valore di pi greco: 3.14159\n\nRisultato: 28.2743\n\n\nE’ possibile DERIVARE un’altra classe da un’altra\n\nUna classe puo’ essere derivata da un’altra classe. La nuova classe,\neredita (inherits) le variabili e i metodi dalla\nbase class. Si possono aggiungere nuovi metodi e\nvariabili alla classe appena creata:\n\nusing namespace std;\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\nclass vettore\n{\n   public:\n      double x;\n      double y;\n\n      vettore (double a = 0, double b = 0)\n      {\n         x = a;\n         y = b;\n      }\n      \n     double modulo()\n     {\n        return sqrt (x*x + y*y);\n     }\n     \n     double superficie()\n     {\n        return x * y;\n    }\n};\n\nclass trivettore: public vettore  // trivettore e' derivato da vettore\n{\n   public:\n   double z;  // variabile in piu' rispetto a x e y di vettore\n   \n   trivettore (double m=0, double n=0, double p=0): vettore (m, n)\n   {\n      z = p; // il constructor di vettore verra'  \n             // chiamato PRIMA del costruttore di trivettore\n             // con parametri m e n\n   }\n   \n   trivettore (vettore a)// questo constructor indica cosa fare nel caso in cui\n   {                     // venga fatto un cast da un vettore a un trivettore \n      x = a.x;\n      y = a.y;\n      z = 0;\n   }\n\n   double modulo ()  // ri-definisce il modulo() per un trivettore\n   {\n      return sqrt (x*x + y*y + z*z);\n   }\n\n   double volume ()\n   { \n       return this-&gt;superficie() * z; // usa il metodo \"superficie\" di questa istanza  \n   }\n};\n\nint main ()\n{\n   vettore a (4, 5);\n   trivettore b (1, 2, 3);\n   cout &lt;&lt; \"a (4, 5)    b (1, 2, 3)  *r = b\" &lt;&lt; endl &lt;&lt; endl;\n   cout &lt;&lt; \"Superficie di a: \" &lt;&lt; a.superficie() &lt;&lt; endl; \n   cout &lt;&lt; \"Volume di b: \" &lt;&lt; b.volume() &lt;&lt; endl;\n   cout &lt;&lt; \"Superficie della base di b: \" &lt;&lt; b.superficie() &lt;&lt; endl;\n   cout &lt;&lt; \"Modulo di a: \" &lt;&lt; a.modulo() &lt;&lt; endl;\n   cout &lt;&lt; \"Modulo di b: \" &lt;&lt; b.modulo() &lt;&lt; endl; \n   cout &lt;&lt; \"Modulo di base di b: \" &lt;&lt; b.vettore::modulo() &lt;&lt; endl;\n   \n   trivettore k;\n   k = a;     // grazie alla definizione di trivettore(vettore)\n              // copia di x e y,      k.z = 0\n   vettore j;\n   j = b;     // copia di x e y.      b.z non fa nulla\n   \n   vettore *r; // puntatore di un vettore\n   r = &amp;b;    // che pero' punta ad un TRIVECTOR\n   cout &lt;&lt; \"Superficie di r: \" &lt;&lt; r-&gt;superficie() &lt;&lt; endl;\n   cout &lt;&lt; \"Modulo di r: \" &lt;&lt; r-&gt;modulo() &lt;&lt; endl;\n\n   return 0;\n}\n\n\na (4, 5)  b (1, 2, 3)  *r = b\n\nSuperficie di a: 20\nVolume di b: 6\nSuperficie della base di b: 2\nModulo di a: 6.40312\nModulo di b: 3.74166\nModulo della base di b: 2.23607\nSuperficie di r: 2\nModulo di r: 2.23607 \n\n\nMetodi virtuali\n\nSe un metodo viene dichiarato virtuale, il programma controllera’ sempre\nil tipo dell’istanza a cui punta e usera’ il metodo appropriato.\n\nNel programma qui sopra, r-&gt;modulo() calcola il modulo\ndel vettore, usando x e y, perche’\nr e’ stato dichiarato come un puntatore ad un vettore.\nIl fatto che r in pratica punti ad un trivettore non\nviene preso in considerazione. Se vuoi che il programma controlli il\ntipo dell’oggetto puntato e scelga il metodo appropriato, allora bisogna\ndichiarare il metodo come virtuale all’interno della\nclasse di base.\n\nSe perlomeno uno dei metodi della classe di base e’ virtuale, allora un\n“header” di 4 byte viene aggiunto ad ogni istanza della classe.\nQuesto consente al programma di determinare a cosa punti un vettore (4\nbyte e’ probabilmente specifico del compilatore usato, su una macchina a\n64 bit forse sono 8 byte).\n\nusing namespace std;\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\nclass vettore\n{\n   public:\n   double x;\n   double y;\n\n   vettore (double a = 0, double b = 0)\n   {\n      x = a;\n      y = b;\n   }\n   virtual double modulo() //   metodo dichiarato come VIRTUALE\n   {\n      return sqrt (x*x + y*y);\n   }\n};\n\nclass trivettore: public vettore\n{\n   public:\n      double z;\n      trivettore (double m = 0, double n = 0, double p = 0)\n      {\n         x = m;  // Solo per fare un esempio pertinente\n         y = n;  // qui NON viene chiamato il costruttore   \n         z = p;  // di vettore e si lascia che il costruttore\n                 // di trivettore faccia tutto il lavoro. \n                 // Il risultato non cambia\n      }            \n      double modulo ()\n      {\n         return sqrt (x*x + y*y + z*z);\n      }\n};\n\nvoid test (vettore &amp;k)\n{\n   cout &lt;&lt; \"Risultato della funzione test:  \" &lt;&lt; k.modulo() &lt;&lt; endl;\n}\n\nint main ()\n{\n   vettore a (4, 5);\n   trivettore b (1, 2, 3);\n   cout &lt;&lt; \"a (4, 5)  b (1, 2, 3)\" &lt;&lt; endl &lt;&lt; endl;\n   vettore *r;\n   r = &amp;a;\n   cout &lt;&lt; \"modulo di vettore a: \" &lt;&lt; r-&gt;modulo() &lt;&lt; endl;\n   r = &amp;b;\n   cout &lt;&lt; \"modulo di trivettore b: \" &lt;&lt; r-&gt;modulo() &lt;&lt; endl;\n   test (a);\n   test (b);\n   \n   vettore &amp;s = b;\n   cout &lt;&lt; \"modulo di trivettore b: \" &lt;&lt; s.modulo() &lt;&lt; endl;\n   return 0;\n} \n\n\na (4, 5) b (1, 2, 3)\n\nmodulo di vettore a: 6.40312\nmodulo di trivettore b: 3.74166\nRisultato della funzione test:\n 6.40312\nRisultato della funzione test:\n 3.74166\nmodulo di trivettore b: 3.74166 \n\n\nDerivare una classe da piu’ di una classe di base\n\nSe vi state domandando se si possa derivare una classe da piu’ di una\nclasse di base, la risposta e’ si’:\n\nusing namespace std;\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\nclass vettore\n{\n   public:\n      double x;\n      double y;\n\n      vettore (double a = 0, double b = 0)\n      {\n         x = a;\n         y = b;\n      }\n      \n      double superficie()\n      {\n         return fabs (x * y);\n      }\n};\n\nclass numero\n{\n   public:\n      double z;\n      numero (double a)\n      {\n         z = a;\n      }\n      \n      int is_negative () \n      {\n         if (z &lt; 0) return 1;\n         else\n         return 0;\n      }\n};\n\nclass trivettore: public vettore, public numero\n{\n   public:\n      trivettore(double a=0, double b=0, double c=0): vettore(a,b), numero(c)\n      {\n      }  // Il costruttore di trivettore chiama il\n         // costruttore di vettore, poi il costruttore\n         // di numero e in questo esempio non fa nulla\n         // di piu'                                 \n      double volume()\n      {\n         return fabs (x * y * z); \n      }\n};\n\nint main ()\n{\n   trivettore a(2, 3, -4);\n   cout &lt;&lt; a.volume() &lt;&lt; endl;\n   cout &lt;&lt; a.superficie() &lt;&lt; endl;\n   cout &lt;&lt; a.is_negative() &lt;&lt; endl;\n \nreturn 0;\n}\n\n\n24\n6\n1 \n\n\nDerivazione delle classi e metodi generici\n\nLa derivazione da classi gia’ esistenti consente di costruire classi\npiu’ complesse costruite a partire da una classe di base. Esiste\nun’altra applicazione della derivazione delle classi: consentire al\nprogrammatore di scrivere delle generic functions.\n\nSupponiamo di definire una classe di base senza alcuna variabile. In\npratica, non ha senso usare istanze di quella classe all’interno del\nproprio programma. Supponiamo pero’ di avere costruito una funzione, il\ncui scopo sia quello di ordinare istanze proprio di quella classe.\nQuesta funzione sara’ in grado di ordinare qualunque tutti gli oggetti,\nche siano istanze di classi derivate dalla classe di base iniziale. La\nsola condizione e’ che all’interno dei ognuna delle definizioni di\nclasse derivata, tutti i metodi di cui ha bisogno la funzione di\nordinamento siano definiti correttamente:\n\nusing namespace std;\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\nclass octopus                     // costruiamo una classe senza argomenti\n{\n   public:\n\n      virtual double modulo() = 0;// =0 implica che la funzione non e' definita\n                                  // Questo fa si' che istanze di questa\n                                  // classe non possano essere dichiarate \n};\n\ndouble modulo_maggiore (octopus &amp;a, octopus &amp;b, octopus &amp;c)\n{\n   double r = a.modulo();    // questa funzione restituisce come valore il modulo\n   if (b.modulo() &gt; r) r = b.modulo();  // della istanza com modulo\n                                        // maggiore tra le 3\n   if (c.modulo() &gt; r) r = c.modulo();\n   return r;\n}\n\nclass vettore: public octopus   // costruisco una nuova classe\n                                // che eredita da octopus\n{\n   public:\n   double x; \n   double y;\n\n   vettore (double a = 0, double b = 0)\n   {\n      x = a;\n      y = b;\n   }\n   \n   double modulo()           // ha un metodo modulo come la classe di base\n   {\n      return sqrt (x * x + y * y);\n   }\n};\n\nclass numero: public octopus  // costruisco un'altra classe derivata da octopus\n{\n   public:\n      double n;\n      numero (double a = 0)\n      {\n         n = a;\n      }\n      double modulo()        // anche questa ha un metodo chiamato modulo\n      {\n         if (n &gt;= 0) return n;\n         else       return -n;\n      }\n};\n\nint main ()\n{\n   vettore k (1,2), m (6,7), n (100, 0);\n   numero p (5),  q (-3), r (-150);\n   cout &lt;&lt; modulo_maggiore (k, m, n) &lt;&lt; endl; // accetta tutte le classi\n   cout &lt;&lt; modulo_maggiore (p, q, r) &lt;&lt; endl; // che sono derivate da octopus\n   cout &lt;&lt; modulo_maggiore (p, q, n) &lt;&lt; endl; // quindi anche vettore e numero\n   \n   return 0;\n}\n\n\n100\n150\n100\n\n\nUna persona potrebbe pensare: ”ok, l’idea di derivare classi dalla\nclasse octopus e’ buona perche’, in quel modo posso\napplicare loro istanze dei metodi della mia classe e funzioni che erano\nstate progettate in modo generico per la classe\noctopus. Cosa potrebbe succedere se ci fosse un’altra\nclasse di base, chiamata cuttlefish, che ha dei metodi\ne delle funzioni molto interessanti? E’ forse necessario scegliere tra\noctopus e cuttlefish quando si vuole\nderivare una classe?” No chiaramente no!. Una classe derivata puo’\nessere derivata sia da octopus che da\ncuttlefish.\n\nQuesto e’ POLIMORFISMO\nLa classe derivata, semplicemente, deve definire sia metodi necessari\nper octopus che per cuttlefish:\n\nclass octopus\n{\n   virtual double modulo() = 0;\n};\n\nclass cuttlefish\n{\n   virtual int test() = 0;\n};\n\nclass vettore: public octopus, public cuttlefish\n{\n   double x;\n   double y;\n   double modulo ()\n   {\n      return sqrt (x * x + y * y); \n   }\n   \n   int test ()\n   {\n      if (x &gt; y) return 1;\n      else       return 0;\n   }\n}\n\n\nEncapsulation: public, protected e private\n\n\n  \n    La direttiva public, significa che, ovunque nel\nprogramma, si puo’ accedere ed usare le variabili e i metodi scritti\ndi seguito alla direttiva stessa.\n  \n  \n    La direttiva protected, significa che le variabili\ne i metodi scritti sotto ad essa sono accedibili ed usabili solo\ntramite metodi della classe stessa E metodi di\nclassi derivate da essa.\n  \n  \n    La direttiva private e’ ancora piu’ restrittiva, e’\npossibile accedere alle variabili ed ai metodi della classe stessa\n(non da quelle derivate o dall’esterno).\n  \n\n\nIl fatto che le variabili o i metodi siano dichiarati\nprivate or protected significa che\nnulla esterno alla classe puo’ accedere a loro o usarli. Questo tipo di\ncaratteristica si chiama ENCAPSULATION (se si vuole\ndare ad una funzione il diritto di accesso a quei metodi o a quelle\nvariabili, allora e’ necessario includere il prototype\ndella funzione all’interno della definizione di classe, con davanti la\nkeyword: friend.\n\nE’ considerata una buona pratica di programmazione il fatto di fare\n“encapsulation” per tutte le variabili di una classe. Questo\ncomportamento puo’ sembrare strano se si e’ abituati agli\nstruct, in C. In effetti uno struct ha\nsenso solo se e’ possibile accedere a tutti i dati al suo interno. In\nC++, invece, si deve creare un metodo apposito per accedere ai dati\nall’interno di una classe. L’esempio seguente usa l’esempio di base del\ncapitolo [ch:metodiClassi], ma dichiara i dati della classe come\nprotected:\n\nusing namespace std;\n#include &lt;iostream&gt;\nclass vettore\n{\n   protected:\n     double x;\n     double y;\n\n   public:\n      void definisci_x (int n)\n      {\n         x = n;\n      }\n      \n      void definisci_y (int n)\n      {\n         y = n;\n      }\n      \n      double superficie ()\n      {\n         double s;\n         s = x * y;\n         if (s &lt; 0) s = -s;\n         return s;\n      }\n};\n\nint main ()\n{\n   vettore a;\n   a.definisci_x (3);\n   a.definisci_y (4);\n   cout &lt;&lt; \"La superficie di a: \" &lt;&lt; a.superficie() &lt;&lt; endl;\n   \n   return 0;\n}\n\n\nLa superficie di a: 12 \n\n\nL’esempio di cui sopra, e’ un po’ strano dato che i parametri x e y\ndella classe possono essere inizializzati, ma non letti! Qualunque\ntentativo, all’interno del main() di leggere a.x o\na.y portera’ ad un errore di compilazione. Nell’esempio\nseguente, invece si potra’ anche leggere sia x che y:\n\nusing namespace std;\n#include &lt;iostream&gt;\nclass vettore\n{\n   protected:\n      double x;\n      double y;\n      \n   public:\n      void definisci_x (int n)\n      {\n         x = n;\n      }\n      \n      void definisci_y (int n)\n      {\n         y = n;\n      }\n      \n      double ottieni_x ()\n      {\n         return x;\n      }\n      \n      double ottieni_y ()\n      {\n         return y;\n      }\n      \n      double superficie ()\n      {\n         double s;\n         s = x * y;\n         if (s &lt; 0) s = -s;\n         return s;\n      }\n};\n\nint main ()\n{\n   vettore a;\n   a.definisci_x(3);\n   a.definisci_y(4);\n\n   cout &lt;&lt; \"La superficie di a: \" &lt;&lt; a.superficie() &lt;&lt; endl;\n   cout &lt;&lt; \"La larghezza di a:  \" &lt;&lt; a.ottieni_x() &lt;&lt; endl;\n   cout &lt;&lt; \"L'altezza di a: \" &lt;&lt; a.ottieni_y() &lt;&lt; endl;\n\n   return 0; \n}   \n\n\nLa superficie di a: 12\nLa larghezza di a: 3\nL'altezza di a: 4 \n\n\nIn C++ una persona non dovrebbe poter accedere ai dati di una classe\ndirettamente. Si dovrebbero dichiarare dei metodi appositi. Perche’\nviene richiesto questo comportamento? Ci sono molte ragioni. Una di\nqueste e’ che in questo modo si consente di cambiare il modo in cui i\ndati sono rappresentati all’interno della classe. Un’altra ragione e’\nche quasto consente ai dati all’interno della classe di essere\n“cross-dependent”. Supponiamo che x e y debbano sempre avere lo\nstesso segno, altrimenti questo causi dei problemi… Se fosse\nconsentito accedere ai dati della classe direttamente, sarebbe possibile\ne semplice imporre per esempio che x sia positivo e negativo.\nNell’esempio qui sotto questo e’ controllato strettamente.\n\nusing namespace std;\n#include &lt;iostream&gt;\nint sign (double n)\n{\n   if (n &gt;= 0) return 1;\n   return -1;\n}\nclass vettore\n{\n   protected:\n      double x;\n      double y;\n\n   public:\n      void definisci_x (int n)\n      {\n         x = n;\n         if (sign (x) != sign(y)) y = -y;\n      }\n      \n      void definisci_y (int n)\n      {\n         y = n;\n         if (sign (y) != sign(x)) x = -x;\n      }\n      \n      double ottieni_x ()\n      {\n         return x;\n      }\n      \n      double ottieni_y ()\n      {\n         return y;\n      }\n      \n      double superficie ()\n      {\n         double s;\n         s = x * y;\n         if (s &lt; 0) s = -s;\n         return s;\n      }\n};\n\nint main ()\n{\n   vettore a;\n   a.definisci_x(3);\n   a.definisci_y(4);\n\n   cout &lt;&lt; \"La superficie di a: \" &lt;&lt; a.superficie() &lt;&lt; endl;\n   cout &lt;&lt; \"La larghezza di a: \" &lt;&lt; a.ottieni_x() &lt;&lt; endl;\n   cout &lt;&lt; \"L'altezza di a: \" &lt;&lt; a.ottieni_y() &lt;&lt; endl;\n\n   return 0;\n} \n\n\nLa superficie di a: 12\nLa larghezza di a: 3\nL'altezza di a: 4\n\n\nBrevi cenni all’ Input e output di file\n\nParliamo ora di input/output. Questo e’ un argomento molto vasto per\nquanto riguarda il C++. Nel seguito c’e’ un programma che scrive un\nfile:\n\nusing namespace std;\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\nint main ()\n{\n   fstream f;\n   f.open(\"test.txt\", ios::out);\n   f &lt;&lt; \"Questo testo e' inviato in output ad un file.\" &lt;&lt; endl;\n   double a = 345;\n   f &lt;&lt; \"Il numero a: \" &lt;&lt; a &lt;&lt; endl;\n   f.close();\n    \n   return 0;\n} \n\n\nIl contenuto del file test.txt:\nQuesto testo e' inviato in output ad un file.\nIl numero a: 345\n\n\nQui invece c’e’ il programma che legge da file:\n\nusing namespace std;\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\nint main ()\n{\n   fstream f;\n   char c;\n   \n   cout &lt;&lt; \"Cosa c'e' nel file test.txt\" &lt;&lt; endl;\n   cout &lt;&lt; endl;\n   \n   f.open(\"test.txt\", ios::in);\n   while (! f.eof() )\n   {\n      f.get(c);\n      cout &lt;&lt; c;\n   }\n\n   f.close();\n   return 0; \n}   \n\n\nQuesto testo e' inviato in output ad un file.\nIl numero a: 345\n\n\nArray di character possono essere usati come file\n\nIn generale e’ possibile fare le stesse operazioni sugli array di\ncharacter che sui file. Questo risulta molto utile per convertire dati o\nper gestire array di memoria.\n\nQui c’e’ un programma che scrive su un array di character:\n\nusing namespace std;\n#include &lt;iostream&gt;\n#include &lt;strstream&gt;\n#include &lt;cstring&gt;\n#include &lt;cmath&gt;\nint main ()\n{\n   char a[1024];\n   ostrstream b(a, 1024);\n   b.seekp(0);                       // Inizia dal primo char.\n   b &lt;&lt; \"2 + 2 = \" &lt;&lt; 2 + 2 &lt;&lt; ends; // OCCHIO usa il comando \"ends\", non \"endl\" \n                                     // \"ends\" e' semplicemente il\n                                     // carattere null o '\\0'\n\n   cout &lt;&lt; a &lt;&lt; endl;\n   double v = 2;\n   strcpy (a, \"A sinus: \");\n   b.seekp(strlen (a));\n   b &lt;&lt; \"sin (\" &lt;&lt; v &lt;&lt; \") = \" &lt;&lt; sin(v) &lt;&lt; ends;\n   cout &lt;&lt; a &lt;&lt; endl;\n   return 0;\n} \n\n\n2 + 2 = 4\nA sinus: sin (2) = 0.909297 \n\n\nUn programma che legge da una stringa di caratteri:\n\nusing namespace std;\n#include &lt;iostream&gt;\n#include &lt;strstream&gt;\n#include &lt;cstring&gt;\nint main ()\n{\n   char a[1024];\n   istrstream b(a, 1024);\n   strcpy (a, \"45.656\");\n   double k, p;\n   b.seekg(0);  // Inizia dal primo carattere.\n   b &gt;&gt; k;\n   k = k + 1;\n   cout &lt;&lt; k &lt;&lt; endl;\n   strcpy (a, \"444.23 56.89\");\n   b.seekg(0);\n   b &gt;&gt; k &gt;&gt; p;\n   cout &lt;&lt; k &lt;&lt; \", \" &lt;&lt; p + 1 &lt;&lt; endl;\n   return 0;\n} \n\n\n46.656\n444.23  57.89\n\n\nUn esempio di output formattato\n\nQuesto programma produce un output formattato in due modi. Si noti che i\nMODIFICATORI width() e setw() hanno\neffetto SOLO sul prossimio output dello stream. Elementi successivi non\nverranno influenzati dai MODIFICATORI.\n\nusing namespace std;\n#include &lt;iostream&gt;\n#include&lt;iomanip&gt;\n\nint main ()\n{\n   int i;\n   cout &lt;&lt; \"Una lista di numeri:\" &lt;&lt; endl;\n   for (i = 1; i &lt;= 1024; i *= 2)\n   {\n      cout.width (7);\n      cout &lt;&lt; i &lt;&lt; endl; \n   }\n   \n   cout &lt;&lt; \"Una tabella di numeri:\" &lt;&lt; endl;\n   for (i = 0; i &lt;= 4; i++)\n   {\n      cout &lt;&lt; setw(3) &lt;&lt; i &lt;&lt; setw(5) &lt;&lt; i * i * i &lt;&lt; endl;\n   }\n\n   return 0;\n}\n\n\nUna lista di numeri:\n1\n2\n4\n8\n16\n32\n64\n128\n256\n512\n1024\nUna tabella di numeri:\n0 0\n1 1\n2 8\n3 27\n4 64 \n\n\nA questo punto avete una conoscenza di base del C++. Da un buon libro\npotrete imparare molte altre cose. Il file management system e’ molto\npotente, e ha a disposizione molte altre possibilita’ rispetto a quelle\nillustrate in questa guida. C’e’ molto altro da dire riguardo alle\nclassi, classi template, clssi\nvirtual, … Per poter lavorare efficacemente con il C++ avrete\nbisogno di un buon libro di riferimento, proprio come succede con il C.\nAvrete inoltre bisogno di sapere come il C++ viene usato nel vostro\nparticolare dominio di lavoro. Gli standard, l’approccio globale, i\ntrucchi, i tipici problemi che si incontrano e le loro soluzioni… La\nmigliore referenza sono ovviamente i libri scritti da Bjarne Stroutrup\n(non ricordo quale io abbia letto). Il seguente libro contiene\npraticamente ogni dettaglio del C e C++, ed e’ costruito in modo molto\nsimile a questo testo e contiene un CD:\n\nJamsa's C/C++ Programmer's Bible\n&amp;copyright; 1998 Jamsa Press\nLas Vegas, United States\n\nFrench edition:\nC/C++ La Bible du programmeur\nKris Jamsa, Ph.D - Lars Klander \nFrance : Editions Eyrolles\nwww.eyrolles.com\nCanada : Les Editions Reynald Goulet inc.\nwww.goulet.ca\nISBN 2-212-09058-7\n\n\nQuesto e’ ormai obsoleto ed e’ ora:\n\nIt has been obsoleted and is now:\nJamsa's C/C++/C# Programmer's Bible\nOnword Press \n\n\nAltre referenze:\n\naccu:www.accu.org/bookreviews/public/reviews/0hr/index.htm\n\nCoderSource.net: www.codersource.net/\n\nC++ Guide:\ngoogle-styleguide.googlecode.com/svn/trunk/cppguide.xml\n\nC++ Reference:\nfresh2refresh.com/c/c-language-history\n\nA similar tutorial for Ada is available at\nwww.adahome.com/Ammo/cpp2ada.html\n\nA Haskell tutorial by a C programmer:\nlearnyouahaskell.com\n\nDesidero ringraziare Didier Bizzarri, Toni Ronkko,\nFrédéric Cloth, Jack Lam, Morten Brix\nPedersen, Elmer Fittery, Ana Yuseepi, William L. Dye, Bahjat F. Qaqish,\nMuthukumar Veluswamy, Marco Cimarosti, Jarrod Miller, Nikolaos Pothitos,\nRalph Wu, Dave Abercrombie, Alex Pennington, Scott Marsden, Robert\nKrten, Dave Panter, Cihat Imamoglu, Bohdan Zograf, David L. Markowitz,\nMarko Pozner, Filip Zaludek, Kevin Wheeler e Patrick Einheber per la\nloro ispirazione, suggerimenti, aiuti, dati, controllo sui bug,\nreferenze, miglioramento della versione inglese e traduzione.\n\nEric Brasseur - 23 Febbraio 1998 fino al 25 Dicembre 2016"
					}
					
				
			
		
			
				
					,
					
					"openmp-18-19": {
						"id": "openmp-18-19",
						"title": "OpenMp, Calcolo Parallelo, UNIMIB",
						"categories": "italiano",
						"url": " /OpenMP-18-19",
						"content": "OpenMP a.a. 2019-2020. Le differenze tra queste diapositive e quelle \ndell’anno precedente riguardano nuove immagini e la correzione di alcuni errori.\n  \n  \n    OpenMP a.a. 2018-2019, questa presentazione non contiene\n le soluzioni degli esercizi ed e’ in formato handout, quindi le “animazioni” non sono visibili, ma \nle diapositive sono piu’ leggibili in quanto non compaiono un pezzo per volta.\n  \n  \n    i \nfile da usare per gli esercizi proposti\nnon contengono le soluzioni ma velocizzano la scrittura del codice (si devono solo apportare le modifiche\nrichieste).\n  \n\n\nI link qui sopra si riferiscono alle note che ho scritto per la parte di OpenMP \ndel corso di “Sistemi di Calcolo Parallelo” presso il DISCo,\nall’Universita’ di Milano-Bicocca. Ho utilizzato varie fonti per scriverle\ne mi sono basato anche esperimenti numerici. \nCi possono essere alcuni richiami a  MPI\n(che viene presentato prima di OpenMP durante il corso).\n\nOpenMP: contesto:\n\ngrossolanamente parlando, OpenMP si rivolge a chi ha delle CPU multicore.\nI vari core condividono la memoria (shared memory) e comunicano tramite essa.\n\nOpenMP: perche’?\nSupponiamo che si abbia un ciclo for (C/C++) o un do loop (Fortran).\nCon una aggiunta di 3-4 righe al codice, OpenMP puo’ ridistribuire il calcolo\ndel ciclo tra i vari core. Smplice. Pulito. L’ideale per un fisico alle prime armi\nche debba velocizzare un codice senza dover impazzire a leggere centinaia di pagine di spiegazioni.\n\nOpenMP: attenzione.\n\nNonostante possa essere usato in modo molto semplice all’inizio, puo’ essere \ningannevole. Non e’ difficile cadere in condizioni di race-condition, ovvero\nquando i core accedono, leggono e (sovra) scrivono lo stesso oggetto. A causa\ndi una race-condition il risultato del calcolo non e’ deterministico:\ndipende dall’ordine di accesso dei core alla risorsa!"
					}
					
				
			
		
			
				
					,
					
					"mpi-18-19": {
						"id": "mpi-18-19",
						"title": "MPI, Calcolo Parallelo, UNIMIB",
						"categories": "italiano",
						"url": " /MPI-18-19",
						"content": "MPI a.a. 2019-2020,  diapositive in formato handout.\nHo aggiunto varie animazioni, corretto errori e modificato alcune parti rispetto all’anno precedente.\n  \n  \n    MPI a.a. 2018-2019, queste diapositive sono in\n formato handout (scritte con Latex-beamer)\n  \n  \n    i file riguardanti gli esercizi proposti durante il corso sono qui.\n  \n\n\nIn questa pagina ci sono i link del materiale che ho scritto per la parte di MPI del corso di Sistemi di Calcolo Parallelo presso il DISCo \n all’Universita’ degli Studi di Milano-Bicocca.\n\nA chi e’ rivolto MPI?\n\nGrossolanamente parlando chi ha un cluster e vuole fare dei calcoli paralleli.\nIn partica ci si aspetta che le varie unita’ di calcolo abbiano risorse separate\ne per questo motivo debbano comunicare informazioni durante un calcolo parallelo.\nNon e’ un caso che questo standard si chiami infatti Message Passing Interface.\n\nLa curva di apprendimento e’ un po’ piu’ ripida, all’inizio, rispetto a \nOpenMP.\n\nIl punto di partenza che deve essere tenuto bene a mente e’ che ogni unita’\ndi calcolo, in linea di principio, esegue TUTTO il codice che abbiamo scritto.\nPer questo motivo si devono usare delle condizioni if/then abbinate a degli\nidentificativi della macchina stessa (forniti da MPI tramite apposite API) per suddividere un calcolo\ntra le varie unita’ di processazione."
					}
					
				
			
		
			
				
					,
					
					"categorie": {
						"id": "categorie",
						"title": "Prova slug italiano",
						"categories": "italiano",
						"url": " /categorie",
						"content": "aggiungo qualche linea di testo"
					}
					
				
			
		
	};
</script>

		</div>
	</div>
</main>

	<script src="/assets/js/jquery-1.11.0.min.js"></script>
<script type="text/javascript">
  jQuery(document).ready(function($){
    // browser window scroll (in pixels) after which the "back to top" link is shown
    var offset = 300,
      //browser window scroll (in pixels) after which the "back to top" link opacity is reduced
      offset_opacity = 1200,
      //duration of the top scrolling animation (in ms)
      scroll_top_duration = 700,
      //grab the "back to top" link
      $back_to_top = $('.cd-top');

    //hide or show the "back to top" link
    $(window).scroll(function(){
      ( $(this).scrollTop() > offset ) ? $back_to_top.addClass('cd-is-visible') : $back_to_top.removeClass('cd-is-visible cd-fade-out');
      // if( $(this).scrollTop() > offset_opacity ) { 
      //  $back_to_top.addClass('cd-fade-out');
      // }
    });

    //smooth scroll to top
    $back_to_top.on('click', function(event){
      event.preventDefault();
      $('body,html').animate({
        scrollTop: 0 ,
        }, scroll_top_duration
      );
    });

  });
</script>
<style type="text/css">
.cd-top {
  display: inline-block;
  height: 50px;
  width: 50px;
  position: fixed;
  bottom: 2%;
  right: 2%;
  border-radius: 40px;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.05);
  /* image replacement properties */
  overflow: hidden;
  text-indent: 100%;
  white-space: nowrap;
  background: #bbb url(/images/cd-top-arrow.svg) no-repeat center 50%;
  visibility: hidden;
  opacity: 0;
  -webkit-transition: opacity .3s 0s, visibility 0s .3s;
  -moz-transition: opacity .3s 0s, visibility 0s .3s;
  transition: opacity .3s 0s, visibility 0s .3s;
}
.cd-top.cd-is-visible, .cd-top.cd-fade-out, .no-touch .cd-top:hover {
  -webkit-transition: opacity .3s 0s, visibility 0s 0s;
  -moz-transition: opacity .3s 0s, visibility 0s 0s;
  transition: opacity .3s 0s, visibility 0s 0s;
}
.cd-top.cd-is-visible {
  /* the button becomes visible */
  visibility: visible;
  opacity: 1;
}
.cd-top.cd-fade-out {
  /* if the user keeps scrolling down, the button is out of focus and becomes less visible */
  opacity: .5;
}
.no-touch .cd-top:hover {
  background-color: #e86256;
  opacity: 1;
}
</style>

<a href="#0" class="cd-top">Top</a>
	<footer class="page-footer light-blue accent-4">  
  <div class="footer-copyright">
    <div class="container text-white">
     <a href="">4Phycs</a> &#xA9; 2020 Inherited from <a href="https://shawnteoh.github.io/matjek/">MatJeck</a>.
    </div>
  </div>
</footer>

<script src="//code.jquery.com/jquery-2.2.4.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/materialize/0.99.0/js/materialize.min.js"></script>




  
    <script src="/assets/js/lunr.min.js"></script>
  

  
    <script src="/assets/js/search.js"></script>
  



<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})
  (window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', '', 'auto');
  ga('send', 'pageview');
</script>

<script src="/assets/js/main.js"></script>

        <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-158698892-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-158698892-1');
</script>

</body>
</html>
